/* Module synfuncs.n */

/* Functions to connect cells, either by making synapses directly or 
   by growing dendrites and then making synapses.
   For use with retsim1.n nc script.  
   2/16/04 J. Tukker
   8/02/05 R.G. Smith
*/

/*------------------------------------------------------------*/

if(notinit(dsconninfo)) dsconninfo=0; 	/* info about sb-dsgc specific conns */

/* arrays to store individual cell connections */
/* We use separate arrays to save space, because  */
/*  larger cells have more connections but are fewer. */

func getz(ct,parm) { return (getn(ct,parm)+1); };

dim cone_out[ncones+1][NCONNO+1][getz(xcone,MAXSYNO)] = {{0}};
dim cone_in [ncones+1][NCONNI+1][getz(xcone,MAXSYNI)] = {{0}};

dim ha_out[ha+1][NCONNO+1][getz(ha,MAXSYNO)]    = {{0}};
dim ha_in [ha+1][NCONNI+1][getz(ha,MAXSYNI)]    = {{0}};

dim hb_out[hb+1][NCONNO+1][getz(hb,MAXSYNO)]    = {{0}};
dim hb_in [hb+1][NCONNI+1][getz(hb,MAXSYNI)]    = {{0}};

dim hbat_out[hbat+1][NCONNO+1][getz(hbat,MAXSYNO)]    = {{0}};
dim hbat_in [hbat+1][NCONNI+1][getz(hbat,MAXSYNI)]    = {{0}};

dim cbp_out[ncbp+1][NCONNO+1][getz(cbp,MAXSYNO)]    = {{0}};
dim cbp_in [ncbp+1][NCONNI+1][getz(cbp,MAXSYNI)]    = {{0}};

dim hbp_out[nhbp+1][NCONNO+1][getz(hbp,MAXSYNO)]    = {{0}};
dim hbp_in [nhbp+1][NCONNI+1][getz(hbp,MAXSYNI)]    = {{0}};

dim rod_out[nrods+1][NCONNO+1][getz(xrod,MAXSYNO)]   = {{0}};
dim rod_in [nrods+1][NCONNI+1][getz(xrod,MAXSYNI)]   = {{0}};

dim rbp_out[nrbp+1][NCONNO+1][getz(rbp,MAXSYNO)]    = {{0}};
dim rbp_in [nrbp+1][NCONNI+1][getz(rbp,MAXSYNI)]    = {{0}};

dim ha_out [nha+1][NCONNO+1][getz(ha,MAXSYNO)]     = {{0}};
dim ha_in  [nha+1][NCONNI+1][getz(ha,MAXSYNI)]     = {{0}};

dim hb_out [nhb+1][NCONNO+1][getz(hb,MAXSYNO)]     = {{0}};
dim hb_in  [nhb+1][NCONNI+1][getz(hb,MAXSYNI)]     = {{0}};

dim sb_out [nsb+1][NCONNO+1][getz(sb,MAXSYNO)]     = {{0}};
dim sb_in  [nsb+1][NCONNI+1][getz(sb,MAXSYNI)]     = {{0}};

dim a17_out [na17+1][NCONNO+1][getz(a17,MAXSYNO)]   = {{0}};
dim a17_in  [na17+1][NCONNI+1][getz(a17,MAXSYNI)]   = {{0}};

dim am_out [nam+1][NCONNO+1][getz(am,MAXSYNO)]     = {{0}};
dim am_in  [nam+1][NCONNI+1][getz(am,MAXSYNI)]     = {{0}};

dim amh_out [namh+1][NCONNO+1][getz(amh,MAXSYNO)]   = {{0}};
dim amh_in  [namh+1][NCONNI+1][getz(amh,MAXSYNI)]   = {{0}};

dim ams_out [nams+1][NCONNO+1][getz(ams,MAXSYNO)]   = {{0}};
dim ams_in  [nams+1][NCONNI+1][getz(ams,MAXSYNI)]   = {{0}};

dim aii_out [naii+1][NCONNO+1][getz(aii,MAXSYNO)]  = {{0}};
dim aii_in  [naii+1][NCONNI+1][getz(aii,MAXSYNI)]  = {{0}};

dim gc_in    [ngc+1]   [NCONNI+1][getz(gc,MAXSYNI)] = {{0}};
dim dsgc_in  [ndsgc+1] [NCONNI+1][getz(dsgc,MAXSYNI)] = {{0}};
dim gcoff_in [ngcoff+1][NCONNI+1][getz(gcoff,MAXSYNI)] = {{0}};

/*------------------------------------------------------------*/

proc set_cell_in(ct,cellnum,n,cn,val) 

{
  if (cn <= getn(ct,MAXSYNI)) {
    if      (ct==xcone)  cone_in [cellnum][n][cn] = val
    else if (ct==xrod)    rod_in [cellnum][n][cn] = val
    else if (ct==ha)       ha_in [cellnum][n][cn] = val
    else if (ct==hb)       hb_in [cellnum][n][cn] = val
    else if (ct==hbat)   hbat_in [cellnum][n][cn] = val
    else if (ct==cbp)     cbp_in [cellnum][n][cn] = val
    else if (ct==rbp)     rbp_in [cellnum][n][cn] = val
    else if (ct==hbp)     hbp_in [cellnum][n][cn] = val
    else if (ct==sb)       sb_in [cellnum][n][cn] = val
    else if (ct==am)       am_in [cellnum][n][cn] = val
    else if (ct==amh)     amh_in [cellnum][n][cn] = val
    else if (ct==ams)     ams_in [cellnum][n][cn] = val
    else if (ct==a17)     a17_in [cellnum][n][cn] = val
    else if (ct==aii)     aii_in [cellnum][n][cn] = val
    else if (ct==gc)       gc_in [cellnum][n][cn] = val
    else if (ct==dsgc)   dsgc_in [cellnum][n][cn] = val
    else if (ct==gcoff) gcoff_in [cellnum][n][cn] = val;
  }
  else fprintf (stderr,"set_cell_in, too many connections %g\n",val);
};

/*------------------------------------------------------------*/

proc set_cell_out(ct,cellnum,n,cn,val) 

{
  if (n > NCONNO) 
    fprintf (stderr,"set_cell_out, connection number for %s too large %g\n",
						cname[ct],n);
  if (cn <= getn(ct,MAXSYNO)) {
    if      (ct==xcone) cone_out[cellnum][n][cn] = val
    else if (ct==xrod)  rod_out [cellnum][n][cn] = val
    else if (ct==ha)     ha_out [cellnum][n][cn] = val
    else if (ct==hb)     hb_out [cellnum][n][cn] = val
    else if (ct==hbat) hbat_out [cellnum][n][cn] = val
    else if (ct==cbp)   cbp_out [cellnum][n][cn] = val
    else if (ct==rbp)   rbp_out [cellnum][n][cn] = val
    else if (ct==hbp)   hbp_out [cellnum][n][cn] = val
    else if (ct==sb)    sb_out  [cellnum][n][cn] = val
    else if (ct==am)    am_out  [cellnum][n][cn] = val
    else if (ct==amh)  amh_out  [cellnum][n][cn] = val
    else if (ct==ams)  ams_out  [cellnum][n][cn] = val
    else if (ct==a17)  a17_out  [cellnum][n][cn] = val
    else if (ct==aii)  aii_out  [cellnum][n][cn] = val;
  }
  else fprintf (stderr,"set_cell_out, too many connections %g\n",val);
};

/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

func get_cell_in(ct,cellnum,n,cn)

{
    local val;

  if (n > NCONNI) 
    fprintf (stderr,"get_cell_in, connection number for %s too large %g\n",
						cname[ct],n);
  if      (ct==xcone) val = cone_in  [cellnum][n][cn]
  else if (ct==xrod)  val = rod_in   [cellnum][n][cn]
  else if (ct==ha)    val = ha_in    [cellnum][n][cn]
  else if (ct==hb)    val = hb_in    [cellnum][n][cn]
  else if (ct==hbat)  val = hbat_in  [cellnum][n][cn]
  else if (ct==cbp)   val = cbp_in   [cellnum][n][cn]
  else if (ct==rbp)   val = rbp_in   [cellnum][n][cn]
  else if (ct==hbp)   val = hbp_in   [cellnum][n][cn]
  else if (ct==sb)    val = sb_in    [cellnum][n][cn]
  else if (ct==am)    val = am_in    [cellnum][n][cn]
  else if (ct==amh)   val = amh_in   [cellnum][n][cn]
  else if (ct==ams)   val = ams_in   [cellnum][n][cn]
  else if (ct==a17)   val = a17_in   [cellnum][n][cn]
  else if (ct==aii)   val = aii_in   [cellnum][n][cn]
  else if (ct==gc)    val = gc_in    [cellnum][n][cn]
  else if (ct==dsgc)  val = dsgc_in  [cellnum][n][cn]
  else if (ct==gcoff) val = gcoff_in [cellnum][n][cn]
  else val = 0;
  return val;
};

/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

func get_cell_out(ct,cellnum,n,cn) 

{
    local val;

  if (n > NCONNO) 
    fprintf (stderr,"get_cell_out, connection number for %s too large %g\n",
						cname[ct],n);
  if      (ct==xcone) val = cone_out[cellnum][n][cn]
  else if (ct==xrod)  val = rod_out [cellnum][n][cn]
  else if (ct==ha)    val = ha_out  [cellnum][n][cn]
  else if (ct==hb)    val = hb_out  [cellnum][n][cn]
  else if (ct==hbat)  val = hbat_out[cellnum][n][cn]
  else if (ct==cbp)   val = cbp_out [cellnum][n][cn]
  else if (ct==rbp)   val = rbp_out [cellnum][n][cn]
  else if (ct==hbp)   val = hbp_out [cellnum][n][cn]
  else if (ct==sb)    val = sb_out  [cellnum][n][cn]
  else if (ct==am)    val = am_out  [cellnum][n][cn]
  else if (ct==amh)   val = amh_out [cellnum][n][cn]
  else if (ct==ams)   val = ams_out [cellnum][n][cn]
  else if (ct==a17)   val = a17_out [cellnum][n][cn]
  else if (ct==aii)   val = aii_out [cellnum][n][cn]
  else val = 0;
  return val;
};


/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

func ncel_out (from_celltype, from_cellnum, to_celltype)

/* return number of postsynaptic cells of type "to_celltype" */

{
   local n,val;

  n = getconn(from_celltype,to_celltype);
  val = get_cell_out(from_celltype,from_cellnum,n,NCELLS);
  return val;
};

/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

func tot_ncel_out (from_celltype, from_cellnum)

/* return total number of postsynaptic cells of all types */

{
   local i,totval;

  for (totval=0,i=1; i<=NCONNO; i++) {
    totval += get_cell_out(from_celltype,from_cellnum,i,NCELLS);
  };
  //fprintf (stderr,"tot_ncel_out %g %g %g\n",from_celltype,from_cellnum,totval);
  return totval;
};

/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

func tot_ncel_outd (from_celltype, from_cellnum)

/* return total number of postsynaptic cells of different type */

{
   local i,totval;

  for (totval=0,i=1; i<=NCONNO; i++) {
    if (getsv(from_celltype,CELPOST,i)!=from_celltype)
       totval += get_cell_out(from_celltype,from_cellnum,i,NCELLS);
  };
  //fprintf (stderr,"tot_ncel_out %g %g %g\n",from_celltype,from_cellnum,totval);
  return totval;
};

/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

func cel_out_num (from_celltype, from_cellnum, to_celltype, numcon)

/* return cell number of postsynaptic cell */

{
   local n,val;

  n = getconn(from_celltype,to_celltype);
  val = get_cell_out(from_celltype,from_cellnum,n,numcon);
  return val;
};

/*------------------------------------------------------------*/

func ncel_in (to_celltype, to_cellnum, from_celltype)

/* return number of presynaptic cells */

{
   local i,n,val;

  n = getconn(from_celltype,to_celltype);
  i = getsv(from_celltype,CONPOST,n);	/* presynaptic connection number */
  val = get_cell_in(to_celltype,to_cellnum,i,NCELLS);
  return val;
};

/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

func tot_ncel_in (to_celltype, to_cellnum)

/* return number of presynaptic cells */

{
   local i,val,totval;

  for (totval=0,i=1; i<=NCONNI; i++) {
     totval += get_cell_in(to_celltype,to_cellnum,i,NCELLS);
  };
  return totval;
};

/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

func tot_ncel_ind (to_celltype, to_cellnum)

/* return number of presynaptic cells of different type */

{
   local i,val,totval;

  for (totval=0,i=1; i<=NCONNI; i++) {
     if (getcv(to_celltype,CELPRE,i)!=to_celltype) 
       totval += get_cell_in(to_celltype,to_cellnum,i,NCELLS);
  };
  return totval;
};

/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

func cel_in_num (to_celltype, to_cellnum, from_celltype, numcon)

/* return cell number of presynaptic cell */

{
   local i,n,val;

  n = getconn(from_celltype,to_celltype);
  i = getsv(from_celltype,CONPOST,n);	/* presynaptic connection number */
  val = get_cell_in(to_celltype,to_cellnum,i,numcon);
  return val;
};

/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

func connected (from_celltype, from_cellnum, to_celltype, to_cellnum)

{
    local n,i, ncells, found;

  found = 0;
  n = getconn(from_celltype,to_celltype);
  ncells = get_cell_out(from_celltype,from_cellnum,n,NCELLS);
  for (i=CELN; i<=ncells; i++) {
    if (to_cellnum==get_cell_out(from_celltype,from_cellnum,n,i)) {
      found = 1;
      break;
    };
  };
  return found;
};

/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

proc setcelconn (from_celltype, from_cellnum, to_celltype, to_cellnum)

/* set cell count and cell number of postsynaptic cell */

{
    local i, n, val;

                                                /* only register first syn */
  if (connected(from_celltype,from_cellnum,to_celltype,to_cellnum)) return;

  n = getconn(from_celltype,to_celltype);	/* set output connection */

  val = get_cell_out(from_celltype,from_cellnum,n,NCELLS) + 1;
  if (val <= getn(from_celltype,MAXSYNO)) {
    set_cell_out(from_celltype,from_cellnum,n,NCELLS,val);
    set_cell_out(from_celltype,from_cellnum,n,val,to_cellnum);
  }
  else fprintf (stderr,"too many output conns %g from %s to %s\n",val,
			cname[from_celltype],cname[to_celltype],val);

  i = getsv(from_celltype,CONPOST,n);	/* presynaptic connection number */
 					/* set input connection */

  val = get_cell_in(to_celltype,to_cellnum,i,NCELLS) + 1;
  if (val <= getn(to_celltype,MAXSYNI)) {
    set_cell_in(to_celltype,to_cellnum,i,NCELLS,val);
    set_cell_in(to_celltype,to_cellnum,i,val,from_cellnum);
  }
  else fprintf (stderr,"too many input conns %g from %s to %s\n",val,
			cname[from_celltype],cname[to_celltype],val);
  if (ninfo >= 4) 
    fprintf (stderr,"# setcelconn %s %g to %s %g\n",cname[from_celltype],from_cellnum,
						  cname[to_celltype],to_cellnum);
};

/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

proc rmconni (to_celltype,to_cellnum,from_cellconn,from_cellnum)

/* remove info about input connections to a cell */
{
    local i, k, n, nc, val;

  n = from_cellconn;
  nc = get_cell_in(to_celltype,to_cellnum,n,NCELLS);	/* get number of input cells */

  for (found=0,i=CELN; i<=nc; i++) {
    if (get_cell_in(to_celltype,to_cellnum,n,i)==from_cellnum) {
      found=1;
      set_cell_in(to_celltype,to_cellnum,n,NCELLS, nc-1);
      for (k=i; k<nc; k++) {
	 val = get_cell_in(to_celltype,to_cellnum,n,k+1); 
         set_cell_in      (to_celltype,to_cellnum,n,k,val);	  /* erase conn */ 
      };	   
      break;
    };
  };
  if (!found) fprintf 
	(stderr,"rmconni: connection not found to %s %g from conn %g %g\n",
			cname[to_celltype], to_cellnum, from_cellconn, from_cellnum);
};

/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

proc rmconno (from_celltype,from_cellnum,to_cellconn,to_cellnum)

/* remove info about output connection from a cell */
{
    local i, k, n, nc, val;

  n = to_cellconn;

  nc = get_cell_out(from_celltype,from_cellnum,n,NCELLS);  /* get number of output cells */
  for (found=0,i=CELN; i<=nc; i++) {
    if (get_cell_out(from_celltype,from_cellnum,n,i)==to_cellnum) {
      found=1;
      set_cell_out(from_celltype,from_cellnum,n,NCELLS,nc-1);
      for (k=i; k<nc; k++) {
         val = get_cell_out(from_celltype,from_cellnum,n,k+1);    /* erase conn */
	 set_cell_out      (from_celltype,from_cellnum,n,k,val); 
      };	   
      break;
    };
  };
  if (!found) fprintf 
     (stderr,"rmconno: connection not found from %s %g\n",cname[from_celltype],from_cellnum);
     (stderr,"rmconno: connection not found from %s %g %g %g\n",
			cname[from_celltype], from_cellnum, to_cellconn, to_cellnum);
};


/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

proc rmcelconn (celltype, cellnum)

/* remove info about a cell's connections, and other cells' connections to it */

{
    local n, nc, cci, cti, cni, cco, cto, cno;

  for (n=1; n<=NCONNI; n++) {			 /* for each input connection type */
    nc = get_cell_in(celltype,cellnum,n,NCELLS); /* get number of presynaptic cells */
    cto = getcv(celltype,CELPRE,n);
    cco = getcv(celltype,CONPRE,n);
    for (i=CELN; i<=nc; i++) {
       cno = get_cell_in(celltype,cellnum,n,i);
       rmconno(cto,cno,cco,cellnum); 		/* remove other cell's output */
    };
    set_cell_in(celltype,cellnum,n,NCELLS,0);
  };

  for (n=1; n<=NCONNO; n++) {			  /* for each output connection type */
    nc = get_cell_out(celltype,cellnum,n,NCELLS); /* get number of postsynaptic cells */
    cti = getsv(celltype,CELPOST,n);		  /* get postsynaptic cell type */
    cci = getsv(celltype,CONPOST,n);		  /* get conn number for postsynaptic cell */
    for (i=CELN; i<=nc; i++) {			  /* for all postsynaptic cells */
       cni = get_cell_out(celltype,cellnum,n,i);  /* get the cell number */ 
       rmconni(cti,cni,cci,cellnum); 		  /* remove other cell's input */
    };
    set_cell_out(celltype,cellnum,n,NCELLS,0);
  };

};

/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

proc print_connections (ct)

/* Print connections for all cells of a given type. 
   Need to check all cells in connection arrays, even those that
   have been erased, because the cells' locations in array are not
   changed when others are erased.
*/
 
{
      local i, cn, l, n, nc, ncells, s, tci, buf, sbuf;
      local ctpre, conpre;

  ncells = getn(ct,NMADE) + ncell_erased[ct];
  if (ncells==1) s=""
  else           s="s";
  if (ncells>0) fprintf (stderr,"# cell type %s, %g cell%s:\n",cname[ct],ncells,s);
  for (cn=1; cn<=ncells; cn++) {
    if (tci=tot_ncel_in(ct,cn) > 0) {
      fprintf (stderr," cell %g: ",cn);

      for (n=1; n<=NCONNI; n++) {
        nc = get_cell_in(ct,cn,n,NCELLS);    /* get number of input cells */
        if (nc>0) {
          if (nc==1) s=""
          else       s="s";
          ctpre = getcv(ct,CELPRE,n);
          conpre = getcv(ct,CONPRE,n);
          fprintf(stderr,"%s from %-s, ",
		rname[getsv(ctpre,SRESP,conpre)],cname[getcv(ct,CELPRE,n)]);
          fprintf(stderr,"%g cell%s: ",nc,s);
          for (i=CELN; i<=nc; i++) {
            fprintf(stderr," %g ",get_cell_in(ct,cn,n,i));
          };
        };
      };
      fprintf (stderr,"\n");
    };

    if (tot_ncel_out(ct,cn) > 0) {
      sprintf (buf,"%g",cn);
      l = strlen(buf);
      if (l==1)      sbuf="         "
      else if (l==2) sbuf="          "
      else if (l==3) sbuf="           "
      else           sbuf="            ";
      if (tci==0) fprintf (stderr," cell %g: ",cn)
      else        fprintf (stderr,sbuf);
      for (n=1; n<=NCONNO; n++) {
        nc = get_cell_out(ct,cn,n,NCELLS);    /* get number of output cells */
        if (nc>0) {
          if (nc==1) s=""
          else       s="s";		/* plural */
          fprintf(stderr,"%s to   %-s, ",
			rname[getsv(ct,SRESP,n)],cname[getsv(ct,CELPOST,n)]);
          fprintf(stderr,"%g cell%s: ", nc,s);
          for (i=CELN; i<=nc; i++) {
            fprintf(stderr," %g ",get_cell_out(ct,cn,n,i));
          };
        };
      };
      fprintf (stderr,"\n");
    };
  };  /* for (cn;;) */
};

/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

proc print_avg_connections (ct)

/* for each cell type, print the average number of connections to other types */

{
      local avgci, avgco, ci, cn, n, nc, ncells, totcells, tci, tnci, tnco, buf, s;

  ncells = getn(ct,NMADE);
  totcells = ncells + ncell_erased[ct];
  if (ncells==1) s=""
  else           s="s";
  if (ncells>0) {
      fprintf (stderr,"# cell type %5s, %5g cell%s: ",cname[ct],ncells,s);

    ci = 0;   				/* =1 -> has at least some inputs */
    for (n=1; n<=NCONNI; n++) {
      for (tnci=0,cn=1; cn<=totcells; cn++) {
        tnci += get_cell_in(ct,cn,n,NCELLS);    /* get number of input cells */
      };
      avgci = tnci/ncells;
      if (avgci>0) {
        ci = 1;
        if (n>1)
	 fprintf(stderr,", ");
        fprintf (stderr,"conv from %-ss = %.3g", cname[getcv(ct,CELPRE,n)],avgci);
      };
    };

    for (n=1; n<=NCONNO; n++) {
      for (tnco=0,cn=1; cn<=totcells; cn++) {
        tnco += get_cell_out(ct,cn,n,NCELLS);    /* get number of output cells */
      };
      avgco = tnco/ncells;
      if (avgco>0) {
        if (ci>0) fprintf (stderr,", ");
        fprintf(stderr,"div to %-ss = %.3g",
  	  cname[getsv(ct,CELPOST,n)],avgco);
      };
    };
    fprintf(stderr,"\n");
  };  /* if (ncells>0) */
};

/*------------------------------------------------------------*/

/* variables for "gs(param)" function */

/* synapse types */

rcs = 0;
rcr = 0;
hcf = 0;
pct = 0;

func gs(sparam)

/* "macro" for synaptic parameters */


{
   return (getsv(pct,sparam,rcs));
};


/* #define gs(sparam) getsv(prect,sparam,rcs) */

/*-------------------------------------------------------------*/

func connect_cell (prect,precn,postct,postcn,usedyad,dyadtyp,dyadc,growpre,growpost,postden)

/* Connect pre and postsynaptic cell with synapse. */

/*  prect = presynaptic cell type    */
/*  precn = presynaptic cell number  */
/*  postct = postsynaptic cell type  */
/*  postcn = postsynaptic cell number */
/*  usedyad =1 -> use previously made synapse as dyad */
/*  dyadtyp = cell type to look for previous synapse for dyad */
/*  growpre  =1 -> grow presynaptic cell  */
/*  growpost =1 -> grow postsynaptic cell */
/*  dyadc = 1 -> connect postsynaptic cell to dyad cell */

{
    local c,k,dd,dist,xytol,zdist,ztol,zdistsav;
    local arbpre,arbpost;
    local crm,cvrest;
    local maxrc, isgj;
    local make_new_syn;
    local hden;
    local bnod,hnod;
    local elemtype,cmindist;
    local rand_cl;
    local dfound,lsyn;
    local dyad_syn,nwodyad;
    local frac,nnod;
    local diabs,diaspc;
    local axtip;
    local xn,yn,FRACD;
    local s_ct,s_cn;
    local do_connect, connname;
    local sbnod,dsgcnod,conncount;
    local rvsyn, synout;

    local dim dyadsyn[100][4];
    local dim oksyn[100];

  pct = prect;

  crm    = getn(postct,RM);
  cvrest = getn(postct,VSTART);

  rcs  = getconn(prect,postct);		/* synapse type prect -> postct */
  rcr  = getconn(postct,prect);		/* synapse type postct -> prect */
  hcf  = getconn(postct,dyadtyp);	/* synapse type postct -> dyad typ */
  isgj = (getsv(prect,SRESP,rcs)==xgapj);/* = 1 -> conn is gap junction */

  arbpre  = getn(prect,DENDARB);	/* arborization type: br, nbr, etc. */
  arbpost = getn(postct,DENDARB);	/* arborization type: br, nbr, etc. */
  xytol   = getn(prect,AXARBDIA)/2; 	/* arborization X,Y tolerance */
  ztol    = getn(postct,DENZDIST);	/* arborization Z tolerance */

  do_connect=0;
  make_new_syn=0;

  if (ninfo>=4) printf("# connect_cell %s %2g to %s %2g\n",
                           cname[prect],precn,cname[postct],postcn); /* */

  /* first sort out the problem by eliminating branches that are too far away */

  if (arbpost>=BRANCHED) {

    /* presynaptic cells synapsing onto branched postsyn dendritic tree */

    cmindist = 1e10; /* now find closest dendrite on cell we're growing */
    c = -1;
    dd = prend = 0;
    zdist = 0;
    zdistsav = hden = hnod = 0;
    foreach node [prect][precn] ?prend { 	  /* for each prect,precn node */

      if (arbpre==NBRANCHED) prend = axtrm;
      foreach cable ?c node [postct][postcn] ?dd 	  /* eliminate if too far */
		within2d xytol+5 node [prect][precn][prend] { 

      elemtype = element c ->elabl;
      if (elemtype !="axon" && elemtype !="axon_long" &&
          elemtype !="axon_thin" && elemtype !="hillock") {

        dist=e3dist([prect][precn][prend],c);
        zdist = ezdist([prect][precn][prend],c); 
    /* fprintf(stderr,"foreach loop: cable=%g, cbp nr=%g, dist=%g zdist %g\n", 
		c,precn,dist,zdist); /* */
    /* fprintf(stderr,"foreach loop: elemtype %s\n",elemtype);  /* */

        if (dist<cmindist && abs(zdist)<ztol) { /* closest? */

	/* fprintf (stderr,
	"foreach loop: distance from [%s][%g][%g] to cable %g = %g\n",
	cname[prect],precn,prend,c,dist); /* */

	  cmindist = dist;                   /* remember this dist */
	  zdistsav = zdist;
	  hden = c;                          /* remember this cable */
	  hnod = dd;                         /* remenber this node */
          //fprintf(stderr, "dd=%g=hnod=%g; cable=%g\n",dd, hnod, hden);
        };
      };
     };     /* foreach cable */
     if (arpre==NBRANCHED) break;
    };     /* foreach presynaptic node */
    presyn = prend; 
    postsyn = hnod; 
    zdist = zdistsav;
    if (ninfo>=4) printf("# connect_cell cmindist %g\n",cmindist);
    if (hden==0) return 0;
  }

  else {  /* arbpost == NBRANCHED */

    cmindist = n2dist([prect][precn][soma],[postct][postcn][soma]);
    zdist    = nzdist([prect][precn][soma],[postct][postcn][soma]);
    presyn  = axtrm;
    postsyn = soma;
    hnod = soma;
  };

     /* Don't connect if outside of selected dendrite */

  if (postden>0)  if (!trace_node(postct,postcn,postsyn,postden)) return 0;

     /* Don't connect if presynaptic cell is too far away in Z. */

  if (ninfo >= 4) printf ("# connect_cell zdist %g ztol %g\n",zdist,ztol);

  if (abs(zdist) > ztol) return 0;

/*  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  */

/* "celnode[][]" should be set to the pre-existing number of dendrites(nodes)*/

  if (growpost) {
      local newpost;

    /* calculate position for new node */

    xn = node [prect][precn][soma]->xloc;
    yn = node [prect][precn][soma]->yloc;

    /* Make new dendrite on postsynaptic cell */

    if (arbpost==BRANCHED) { /* branched dendritic tree */

      newpost = ++celnode[postct][postcn];
      at [postct][postcn][newpost] loc (xn,yn,getn(prect,AXARBZ)-0.5);
      frac=efrac ([prect][precn][axtrm],hden);   /* closest place on cable */
      if (frac == 0.0)
        nnod = element hden->node1c
      else if (frac == 1.0)
        nnod = element hden->node2c
      else {                                /* make new node on cable */
        nnod = ++celnode[postct][postcn];
        at [postct][postcn][hnod]: hden offset=frac*0.6 
			put [postct][postcn][nnod];
      };

/* printf ("N %g %g %g %g frac %g %g %g\n", 
		postct, postcn, newpost, nnod, frac,
		element hden->node1b, element hden->node2b);
*/

      /* if the new node is exactly at the old, then move it just a little */
      if (n3dist ([postct][postcn][newpost],[postct][postcn][nnod]) < 0.1) {
        at [postct][postcn][newpost] loc (
                node [postct][postcn][newpost]->xloc,
                node [postct][postcn][newpost]->yloc,
                 getn(postct,SOMAZ) - .1);
      };

      do_connect = 1;
      diabs  = getn(postct,TAPERABS);
      diaspc = getn(postct,TAPERSPC);
      celnode[postct][postcn] = taperdistden(postct,postcn,nnod,newpost,diabs/2,
      					diaspc, celnode[postct][postcn]);

      if (ninfo>=4) {
        printf("#  conn br %s %g %g ",cname[postct],postcn,newpost);
        printf("to %s %g 0 den %g\n", 
			cname[postct],postcn,celnode[postct][postcn]);
      };
    }	/* BRANCHED */

    else if (arbpost==NBRANCHED) {  /* unbranched dentritic tree*/
         local dtol;

      if (isgj) {	

        FRACD = 0.45;  /* if gj, grow pre and postsyn branches half way */

        xn = xn*FRACD + node [postct][postcn][soma]->xloc * (1-FRACD);
        yn = yn*FRACD + node [postct][postcn][soma]->yloc * (1-FRACD);

        rcr = hcf = 0;			/* don't make reverse connection */
      };

       /* Check to see if an existing dendrite of postsynaptic cell is within a small dist
           of the presynaptic terminal. If so, then connect directly to it instead
           of growing a new dendrite */

      dtol = 1.5;
      MINZDIST = 1.5;
      zdistsav = 1e6;
      bnod = dd = 0;
      foreach cable ?c node [postct][postcn] ?dd 	  /* eliminate if too far */
		within2d dtol node [prect][precn][axtrm] { 

         zdist    = nzdist([prect][precn][axtrm],[postct][postcn][dd]);
         if (zdist<zdistsav) {                  /* closest? */
            zdistsav = zdist;
            bnod = dd;                          /* remenber this node */
         };
      };
        // fprintf (stderr,"cn %-3d nod %-3d dend zdist %g\n",postcn,dd,zdistsav);
      if (zdistsav < MINZDIST) {                /* if near enough, connect to the dendrite */
        newpost = bnod;
      }
      else {                                    /* otherwise, make new dendrite to soma */
        newpost = ++celnode[postct][postcn];
        at [postct][postcn][newpost] loc (xn,yn,getn(prect,AXARBZ)-0.5);
        make_celseg (postct, postcn, newpost, soma,  cd1=getn(postct,DTIPDIA), cd2=0,DEND);
      };
      do_connect = 1;

      if (ninfo>=5) {
        printf("#  conn unbr %s %g %g\n",cname[postct],postcn,newpost);
      };

    };  /* if (arbpost==NBRANCHED) */

    presyn = axtrm;		/* set node for photorec to bip */
    postsyn = newpost;		/* set node for synapse on bip */

  };   /* if (growpost) */

/*  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  */

  if (growpre) {
      local primaxon,newpre;

    newpre = ++celnode[prect][precn];
    primaxon = 1;
    if (arbpre==BRANCHED) {	/* branched dendritic tree */
      if (cmindist <= xytol) {
        frac=efrac ([prect][precn][axtrm],hden);   /* closest place on cable */
        if (frac == 0.0)
          nnod = element hden->node1c
        else if (frac == 1.0)
          nnod = element hden->node2c
        else {                                /* make new node on cable */
          nnod = ++celnode[postct][postcn];
          at [postct][postcn][hnod]: hden offset=frac 
					put [postct][postcn][nnod];
        };
	at [prect][precn][newpre] loc (node [postct][postcn][nnod]->xloc,
			               node [postct][postcn][nnod]->yloc,
				       node [postct][postcn][nnod]->zloc+0.2);

        make_celseg (prect, precn, newpre, axtrm, 
					cd1=getn(prect,AXTIPDIA),cd2=0,AXON);

        presyn = newpre;	/* set node for synapse to gc */
        postsyn = nnod;		/* set node for synapse from bip */
	do_connect = 1;
      }
      else
        do_connect = 0;

    }	/* BRANCHED */

    else if (arbpre==NBRANCHED) { 	/* branched dendritic tree */
      if (isgj) {	

        xn = node [prect][precn][soma]->xloc;
        yn = node [prect][precn][soma]->yloc;

        xn = xn*(1-FRACD) + node [postct][postcn][soma]->xloc*FRACD;
        yn = yn*(1-FRACD) + node [postct][postcn][soma]->yloc*FRACD;
      };
      do_connect = 1;
      at [prect][precn][newpre] loc (xn,yn,getn(prect,AXARBZ)-0.5);
      make_celseg (prect, precn, newpre, soma,  cd1=getn(prect,DTIPDIA),
						cd2=0,DEND);
      presyn = newpre;
    };
  };     /* if (growpre) */

/*  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  */

  if (!growpre && !growpost) {

    if(prect==sb && postct==dsgc) {
      if(sbdsgc_conn(prect,precn,postct,postcn))
        do_connect = 1;
    }
    else if (isgj) {	
        presyn = soma;		/* set presynaptic node for gj */
        postsyn = soma;		/* set postsynaptic node for gj */
        do_connect = 1;
    }
    else {
	/* otherwise, make synapse if nearest node is near enough */

      if (cmindist<xytol)
        do_connect = 1;
    };

   /*
    fprintf(stderr, "connect_cell: prect axarbdia=%g cmindist=%g\n", 
			getn(prect,AXARBDIA), cmindist);
      fprintf(stderr, "hnod=%g hden=%g cmindist=%g \n", 
			hnod, hden, cmindist); /* */
  };

/*  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  */

  /* Now make synapse. */
  /* Find how many synapses from presyn -> postsyn dyadtype cell. */

  lsyn = 0;
  if (usedyad && dyadtyp>0) {
    for (k=0; k<100; k++) {
      dyadsyn[k][0] = 0;	/* the synapse elem number */
      dyadsyn[k][1] = 0;	/* count of synapse's dyads */
      dyadsyn[k][2] = 0;	/* postsyn cell number */
      dyadsyn[k][3] = 0;	/* count of synapses going to same */
				/* postsynaptic cell */
    };

    /* for all synapses from presynaptic cell */
    lsyn = 0;
    foreach synapse ?s node [prect][precn][axtrm] {

      s_ct = element s->node2a;	/* postsyn cell type */
      s_cn = element s->node2b;	/* postsyn cell number */

      if (element s->node2a == dyadtyp) {
        /* If synapse connects to original (bipolar) dyad cell type, */
        /*  count number of synapses connected to each presyn cell */

	for (dfound=0,k=0; k<lsyn; k++) { /* look at all previous checked */
          if (dyadsyn[k][2] == s_cn) { /*  synapses, count postsyn */
	    dyadsyn[k][3]++;
	    dfound = 1;
	  };
        };
        if (!dfound) {	/* if cell num has not been saved yet */
          dyadsyn[lsyn][2] = s_cn; /* save postsyn cell num */
	  dyadsyn[lsyn][3]++;	 /* incr number of cells */
        };
	dyadsyn[lsyn++][0] = s;	 	 /* save synapse number */
      }
      else {	/* postsynaptic type != dyadtyp */
        if (s_ct == postct && element s->scurve==ntype(dyad)) {
	  /* If connects to this cell type && if it's a dyad */

	  for (dfound=0,k=0; k<lsyn; k++) {
	    if (dyadsyn[k][0]==element s->sdyad) {
	      dyadsyn[k][1]++;	/* incr # of dyads */
	      dfound = 1;
	    };
	  };
	  if (! dfound) {
	    printf ("connect_cell: can't find synapse %g -> %g\n",
				s, element s->sdyad);
	  };
	};
      };	/* type != dyadtyp */
    };	/* foreach synapse ?s */
  };      /* if (dyadtyp) */

  if (do_connect) {

    if (rcs) {		/* standard feedforward synapse */
      if (usedyad) {
        for (k=0; k<100; k++)
	  oksyn[k] = 0;
	for (nwodyad=0,k=0; k<lsyn; k++) {	/* find synapse dyads to Hz */
          if ( dyadsyn[k][1] < 1)	/* find synapses w/o dyads */
		oksyn[nwodyad++] = dyadsyn[k][0];	/* synapse elem # */
	};

	//printf ("postct %g lsyn %g n %g\n",postct,lsyn,nwodyad);

	if (nwodyad>0) {	   /* if there are some synapses w/o dyads */
	  rand_cl = int(rand()*nwodyad);   /* select one at random */
	  dyad_syn = oksyn[rand_cl];

	  /* node at tip of spine: */

          conn [prect][precn][presyn] to [postct][postcn][postsyn]  
          synapse open dyad dyad_syn
			maxcond= gs(SCOND)
			thresh = gs(STHRESH)
                        vrev   = gs(SVREV)
			nfilt2 = gs(SNFILT) 
		        timec2 = gs(SDUR)
                        chnoise= gs(SCNOISE) 
                        nfilt3 = gs(SCNFILT)
		        timec3 = gs(SCDUR); /* */
          make_new_syn = 0;

	}			/* Can bp have multiple dyads? */

	else 		    /* If no free dyads, */
          make_new_syn = 1;      /* make new synapse here. */

      }  /* if usedyad */

      else make_new_syn = 1;

      if (make_new_syn) {   /* Make new synapse from prect to postct cell */

	make_new_syn = 0;	/* reset */

	if (prect==sb && postct==dsgc) {		/* sb to dsgc synapse */
             conn_sbdsgc (prect,precn,postct,postcn);
	}
        else if (gs(SRESP)==xmglur6) {	/* inverting cone-cbp synapse */

	  conn [prect][precn][presyn] to [postct][postcn][postsyn]
	    synapse close maxcond=0 
			expon=gs(SGAIN)
			vrev=gs(SVREV)
			thresh=gs(STHRESH)
			vgain=gs(SVGAIN) hcof=1
			vesnoise=gs(SVNOISE) vsize=gs(SVSIZ)
			nfilt2=gs(SNFILT) timec2=gs(SDUR)
			kd=1
			cgain=gs(SCGAIN)
			nfilt3=gs(SCNFILT) 
			timec3=gs(SCDUR)
			trconc=gs(STRCONC)	/* additional ves size factor */
			mesgout cGMP;


	  /* make cGMP channel */

	  at [postct][postcn][postsyn] chan cGMP type 1
			maxcond= gs(SCOND) 
			vrev   =gs(SVREV)
			caperm =0.1
			taua=1 taub=1
			tauc=1 taud=1
			chnoise=gs(SCNOISE)
			unit=20e-12
                        cacomp cshell 3 cai=10e-9
                        capump km=10e-6 vmax=2e-4
			ename synout
			;
	}
	else if (gs(SRESP)==xampa) {

          conn [prect][precn][presyn] to [postct][postcn][postsyn] 
               synapse open
			expon=gs(SGAIN)
			vgain=gs(SVGAIN)
			vrev=gs(SVREV)
			maxcond=gs(SCOND)
			thresh=gs(STHRESH)
			nfilt1h=gs(SNFILTH)
			timec1h=gs(SDURH)
			hgain=gs(SHGAIN)
                        vesnoise=gs(SVNOISE) vsize=gs(SVSIZ)
			nfilt2=gs(SNFILT) timec2=gs(SDUR)
			// mesgout GLU
			resp ampa
                        chnoise=gs(SCNOISE) 
                        ename synout; 
	  }
	else if (gs(SRESP)==xampa5) {

          conn [prect][precn][presyn] to [postct][postcn][postsyn] 
               synapse open
			expon=gs(SGAIN)
			vgain=gs(SVGAIN)
			vrev=gs(SVREV)
			maxcond=gs(SCOND)
			thresh=gs(STHRESH)
			nfilt1h=gs(SNFILTH)
			timec1h=gs(SDURH)
			hgain=gs(SHGAIN)
                        vesnoise=gs(SVNOISE) vsize=gs(SVSIZ)
			nfilt2=gs(SNFILT) timec2=gs(SDUR)
			// mesgout GLU
			trconc=gs(STRCONC)
			resp ampa type 5
                        chnoise=gs(SCNOISE) 
                        ename synout; 
	  }
	  else if (gs(SRESP)==xgaba) {

          conn [prect][precn][presyn] to [postct][postcn][postsyn] 
               synapse open
			expon=gs(SGAIN)
			vgain=gs(SVGAIN)
			vrev=gs(SVREV)
			maxcond=gs(SCOND)
			thresh=gs(STHRESH)
			nfilt1h=gs(SNFILTH)
			timec1h=gs(SDURH)
			hgain=gs(SHGAIN)
                        vesnoise=gs(SVNOISE) vsize=gs(SVSIZ)
			nfilt2=gs(SNFILT) timec2=gs(SDUR)
			trconc=gs(STRCONC)
			resp gaba type 1 
                        chnoise=gs(SCNOISE) 
                        ename synout; 
	  }
          else if (gs(SRESP)==xgapj) {	

            conn [prect][precn][presyn] to [postct][postcn][postsyn] 
               gj gs(SCOND);
	  }
          else  { 	/* (resp == xglut) */


          conn [prect][precn][presyn] to [postct][postcn][postsyn] 
               synapse open
			expon=gs(SGAIN)
			vgain=gs(SVGAIN)
			maxcond=gs(SCOND)
			thresh=gs(STHRESH)
			nfilt1h=gs(SNFILTH)
			timec1h=gs(SDURH)
			hgain=gs(SHGAIN)
                        vesnoise=gs(SVNOISE) vsize=gs(SVSIZ)
                        vrev= gs(SVREV)
			nfilt2=gs(SNFILT) timec2=gs(SDUR)
                        chnoise=gs(SCNOISE)
                        ename synout; /* */
	  };

	  if (prect==cbp) 
		save_cbp_syns (prect,precn,postct,postcn,hnod,synout);

      };  /* if make_new_syn */
    };	/* if (rcs) */


    if (rcr) {		/* feedback synapse */

      conn [postct][postcn][postsyn] to [prect][precn][presyn] 
          synapse open 
	    expon=getsv(postct,SGAIN,rcr)
	    vgain=getsv(postct,SVGAIN,rcr)
	    maxcond=getsv(postct,SCOND,rcr)
            thresh=getsv(postct,STHRESH,rcr) vrev= -.07
            vesnoise=getsv(postct,SVNOISE,rcr) vsize=getsv(postct,SVSIZ,rcr) 
	    nfilt2=1 timec2=getsv(postct,SDUR,rcr)
            ename rvsyn;

    };

    if (hcf) {	/* inhibitory feedforward (from hz to bp, or amac to gc) */
        local d_n2,d_n3;	/* node #s for dyadtyp cel */

      //if (notinit(nwodyad)) printf ("pre %g post %g\n",prec,postct);

      if (usedyad) {
	if (nwodyad>0) {/* if a suitable synapse to bp exists */

	  d_n2 = element oksyn[rand_cl] -> node2b;
	  d_n3 = element oksyn[rand_cl] -> node2c;

          conn [postct][postcn][postsyn] to [dyadtyp][d_n2][d_n3]/*fwd synap */
                 synapse open dyad rvsyn
		 maxcond=getsv(postct,SCOND,hcf)
                 thresh=getsv(postct,STHRESH,hcf) vrev= -.07
                 vesnoise=getsv(postct,SVNOISE,hcf) vsize=getsv(postct,SVSIZ,hcf) nfilt2=1
		 timec2=getsv(postct,SDUR,hcf);
	};
      }
      else {		/* connect hz to bp without dyad */

	for (k=0; k<100; k++)
	  oksyn[k] = 0;
	for (nwodyad=0,k=0; k<lsyn; k++) {	/* find synapse dyads to Hz */
	   if ( dyadsyn[k][1] < 1)		/* find synapses w/o dyads */
	     oksyn[nwodyad++] = dyadsyn[k][0];	/* synapse elem # */
	};
	if (nwodyad>0) {	   /* if there are appropriate bipolar cells  */
          rand_cl = int(rand()*nwodyad);   /* select one at random */
	  dyad_syn = oksyn[rand_cl];

	  d_n2 = element dyad_syn -> node2b;
	  d_n3 = element dyad_syn -> node2c;

          conn [postct][postcn][postsyn] to [dyadtyp][d_n2][d_n3]
                synapse open 
                expon=getsv(postct,SGAIN,hcf)
	        vgain=getsv(postct,SVGAIN,hcf)
		maxcond=getsv(postct,SCOND,hcf)
                thresh=getsv(postct,STHRESH,hcf) vrev= -.07
                vesnoise=getsv(postct,SVNOISE,hcf) 
                vsize=getsv(postct,SVSIZ,hcf) nfilt2=1
		timec2=getsv(postct,SDUR,hcf);
	};
      };

    };	/* hcf */

    /* store connections between individual cells */

    setcelconn (prect, precn, postct, postcn);
    if (gs(SRESP)==xgapj)
      setcelconn (postct, postcn, prect, precn);

  };  /* do_connect */

  if (ninfo>=5) {
    printf("# connect_cell end %g\n", do_connect);
  };
  return do_connect;

};  /* func connect_cell() */

/*-----------------------------------------*/

proc findnearest (prect,postct,nearest)

/* Find closest postsynaptic cells based on the location of their somas. 
   This must work for both growing and non-growing cells, so can't use 
   existing dendritic trees. 
*/

{
   local i,j,found,precn, postcn, nearrad, ntrials, nrad;
   local dim adim[2];

  adim = dims(nearest);
  maxcells = adim[1];		/* find size of array */

  ntrials = 8;
  nearrad = amax((getn(prect,DTREEDIA) + getn(postct,DTREEDIA)),
                 (getn(prect,AXARBDIA) + getn(postct,AXARBDIA))) * 1.5;
  foreach node [prect] ?precn [soma] {
    n = 1;
    for (i=0; i<ntrials; i++) {
    nrad = nearrad * (i+1) / ntrials;
    foreach node [postct] ?postcn [soma] 
	within2d nrad node [prect][precn][soma] {
         for (found=0,j=1; j<n; j++) {
            if (nearest[precn][j]==postcn) {
                found=1; break;
            };
          };
          if (found) continue;                   /* don't add cells already counted */
          if (prect!=postct || precn!=postcn)
            if (n <= nearest)  
              nearest[precn][n++] = postcn;
    }; /* foreach (postcn) */
    nearest[precn][NCELLS] = n-1;
   };
  }; /* foreach (precn) */
};

/*-----------------------------------------*/

proc shuffle(arr,ncel)

{
   local c,temp;

  for (c=1; c<=ncel; c++)	/* initialize arr */
    arr[c] = c;

  if(ncel>1){			/* if >1 cell, shuffle order of cells */
    for (c=1; c<=ncel; c++) {
      for (s=c; c==s; s)  		/* make source diff than dest */
        s = int(rand() * ncel) + 1;
      temp = arr[c];			/* swap for shuffle */
      arr[c] = arr[s];
      arr[s] = temp;			/* */
      /* fprintf(stderr,"c=%g, arr[c]=%g\n", c, arr[c]);	/* */
    };
  };
};

/*-----------------------------------------*/

proc connect_types_dyad (ctype1,ctype2,dyadc) 

/* Connect one type of cell to another type, with
competition between cells of same type. Assume that
photoreceptors exist and skeleton bipolar cells already exist in
correct number and location.  The photoreceptors are checked in
random sequence.  For each photoreceptor, find all the bipolar
cells whose dendritic fields it lies in, then pick one of them at
random to connect to.  The probability of connecting to a cell is
proportional to its weighting function, so a stochastic gaussian
weighting function is generated to decide which cells connect.
If "growpost" is set, extend a dendrite from the postsynaptic cell
to the presynaptic cell.  

 If "usedyad" is set, don't make any new synapses, but find
  previously made synapses from the same type of photoreceptor
  to a cell of "dyadtyp" and make the new synaptic connections
  be dyads to the previously made synaptic connections.  Thus,
  photoreceptors -> bipolar cells are normal synapses, and
  photoreceptors -> HCs are dyads.

*/

{
    local s,i,ct1,ct2,cn,cn1,cn2,n,c1,c2;
    local rcs,conv,div;
    local trials, maxtrials, radmin, radweight;
    local rdist,ctrad,isgj,nconn,oldn,oldn2,maxcov;
    local growpre, growpost, usedyad, dyadtyp;
    local postden, synnum;

    local dim ckd1[getn(ctype1,MAXNUM)] = {{-1}}; /* celltyp 1 chk arr*/
    local dim ckd2[maxcov=getn(ctype2,MAXCOV)*10] = {{-1}};

    local dim nearest[getn(ctype1,MAXNUM)][maxcov] = {{0}};

  ct1 = ctype1;			/* presynaptic cell type */
  ct2 = ctype2; 		/* postsynaptic cell type */

  /* Don't make synaptic connections if the cells are missing. */

  if (!getn(ct1,MAKE) || !getn(ct2,MAKE)) return; 

  ncel1 = getn(ct1,NMADE);	/* number of cells of presynaptic type */
  findnearest(ct1,ct2,nearest);	/* find nearby postsyn cells */
  rcs = getconn(ct1,ct2);	/* synapse type prect -> postct */

  if (ninfo >= 2) 
    fprintf(stderr,"# connecting %ss to %ss\n", cname[ct1], cname[ct2]);

  growpre  = getsv(ct1,GROWPRE,rcs); 	/* grow presynaptic cell ? */
  usedyad  = getsv(ct1,USEDYAD,rcs); 	/* use dyad when presynaptic cell ? */
  dyadtyp  = getsv(ct1,DYADTYP,rcs); 	/* dyad type to attach */
  growpost = getcv(ct2,GROWPOST,getsv(ct1,CONPOST,rcs));/* grow postsyn cell?*/

  conv  = getcv(ct2,CELCONV,getsv(ct1,CONPOST,rcs));
  div   = getsv(ct1,CELDIV,rcs);
  isgj  = (getsv(ct1,SRESP,rcs)==xgapj);
  synnum = getsv(ct1,SYNNUM,rcs);

  if (isgj) {	/* check axon arborization diameter for gj connections */
    radmin = 0.5;
    ctrad = (getn(ct1,AXARBDIA) + getn(ct2,AXARBDIA)); /* radius to check */
  }
  else {	/* for all other interactions, check dendritic tree dia */
    radmin = 0.2;
    ctrad = (getn(ct1,DTREEDIA) + getn(ct2,DTREEDIA)); /* radius to check */
  };

  oldn = oldn2 = 0;
  maxtrials = 15;
  for (trials=0; trials<maxtrials; trials++) { /* trials to connect */

    /* The idea here is to find the nearest connections first,
       which will tend to reliably connect the cells near the center 
       of the dendritic field, then stepwise increase the radius of 
       the Gaussian weighting function to allow the remainder of the
       connections to be made more randomly.
    */
 
   radweight = (trials+1)/maxtrials * (1-radmin) + radmin;

   shuffle (ckd1,ncel1);

   nconn = 0;
   for (c1=1; c1<=ncel1; c1++) {		/* For each presyn cell */

     c1n = ckd1[c1];			/* shuffle number for presyn cell*/
     ncel2 = nearest[c1n][NCELLS];
     shuffle (ckd2,ncel2);

      /* Find all postsyn cells that overlap with presynaptic cell */
      /*  and therefore could potentially connect. */

     for (c2=1; c2<=ncel2; c2++) {
        local ok, nsyn;

       c2n = nearest[c1n][ckd2[c2]];	     /* index into nearby cell2s */
       if (ct1==ct2 && c1n==c2n) continue;   /* don't connect cell to itself */

       rdist = n2dist([ct1][c1n][soma],[ct2][c2n][soma]); /* find radial dist*/

       if (ninfo>=4)
     fprintf (stderr,
	"# %s %-3g to %s %-3g rdist %4.3g, ctrad %g radweight %g growpre %g growpost %g\n",
          cname[ct1],c1n,cname[ct2],c2n,rdist,ctrad,radweight,growpre,growpost);

       if (growpost) {
         if (rdist <= ctrad && !connected(ct1,c1n,ct2,c2n) && 
           (ncel_in(ct2,c2n,ct1) < conv) && (ncel_out(ct1,c1n,ct2) < div)) {
            if (rand() < gauss(rdist,ctrad*radweight)) {

	    for (nsyn=0; nsyn<synnum; nsyn++) {
              ok = connect_cell (ct1,c1n,ct2,c2n,usedyad,dyadtyp,dyadc,
					growpre,growpost,postden=pickden[ctype2]);
	    };
	    if (ok) nconn++;
           }; /* if (rand()<gauss) */
         }; /* if (rdist<=ctrad) */
       }  /* if (growpost) */

       else { /* if (!growpost) */
         if (rdist <= ctrad*radweight && !connected(ct1,c1n,ct2,c2n) && 
           (ncel_in(ct2,c2n,ct1) < conv) && (ncel_out(ct1,c1n,ct2) < div)) {

	    for (nsyn=0; nsyn<synnum; nsyn++) {
              ok = connect_cell (ct1,c1n,ct2,c2n,usedyad,dyadtyp,dyadc,
					growpre,growpost,postden=pickden[ctype2]);
	    };
	    if (ok) nconn++;
         };
       };
       if (ncel_out(ct1,c1n,ct2) >= div) break;

      }; /* for (c2;;)  For all postsyn cells */
    };  /* for (c1;;) */
   if (ninfo >= 3) fprintf (stderr,"# trial %g nconn %g\n",trials,nconn);
   if (nconn==0 && oldn==0 && oldn2==0 && trials>3) break;
   oldn2 = oldn;
   oldn = nconn;
  };  /* for (trials;;) */
}; /* proc connect_types_dyad() */

/*-----------------------------------------*/

proc connect_types (ctype1,ctype2) 

{ 
   local dyadc;

  connect_types_dyad (ctype1,ctype2,dyadc=0);
};

