#! /usr/bin/nc -c

/* Creates ds ganglion cell and starburst amacrine cell */
/* contains HVA Ca channels at dendrites  */

dsversion = 5.0;

/* general simulation parameters */

timinc   = 1e-4;
ploti    = 1e-4;
crit     = 1e-8;
tempcel  = 35;
implicit = 0;
drm      = 20000;
plsep    = 1;
rseed    = 382145811;
//dcai = 50000e-9;
script = 0;		/* = 1 -> running script, don't show all output */

vcl = -0.065;
vk  = -0.080;
vna = +0.04;

dcavoff = 0;
calcnernst = 0;

amsomrm = 50000;
amrm = 50000;

soma = 0;
gc   = 1;
bp   = 2;
am   = 3;
con  = 4;
nceltypes = 5;

/* experiment control variables */

make_gc		= 1; 	 /* make ganglion cell */
make_bp		= 1; 	 /* make bipolar cell */
make_am  	= 1; 	 /* make amacrine cell */
make_photorec   = 1;	 /* make photoreceptor */
make_bpam	= 1; 	 /* make bipolar cell -> amac synapses */
make_bpgc	= 1; 	 /* make bipolar cell -> GC synapses */
make_amgc	= 1; 	 /* make amacrine cell -> GC synapses */
addca		= 0;	 /* add Ca-channels to dendrite outer thirds */
current_stim	= 1;
stimhalf	= 0;	 /* only run bar over half of cell with recpoints */
currvel		= 0;     /* run experiment to find current velocity */

postsyn_noise	= 0;
ves_noise       = 0;
//sim_oneden	= 0;


/* synaptic parameters */

condf 	  = 22e-12;	/* unit conductance of synapes */
nchanbpgc = 20;		/* N chan for bp -> gc. */
nchanbpam = 5;		/* N chan for bp -> am. */
nchanamgc = 30;		/* N chan for am -> gc */
amu       = 10e-12;	/* bp-> amacrine unitary current */
sfdur 	  = 2;
srdur 	  = .5;
dvsz      = 10;		/* default vesicle size when no noise */
vsiz	  = 10;

if (make_photorec) {	/* Two types of photoreceptors, "cone, "transducer" */
  exponcon  = 5;
  exponbp   = 3;
  exponam   = 4;
  thresh1   = -0.041;
  conethr   = -0.065;
}
else {
  exponbp   = 2;
  exponam   = 4;
  thresh1   = -0.045;
};

/* end: synaptic parameters */

/* experiments */

expt = "gc_surf_area";		/* calc surface area */
expt = "am_surf_area";		/* calc surface area */
expt = "make_sb";		/* make sb amacrine only */
expt = "sb_cc_tofro";		/* sb current clamp, bar moving right, left */
expt = "sb_vc_tofro";		/* sb voltage clamp, bar moving right, left */
expt = "sb_cc_stepbar";		/* sb current clamp, 2 bar */
expt = "sb_cc_stepspot";	/* sb current clamp, 2 spots */
expt = "sb_cc_annulus";		/* sb current clamp, shrink expand annulus */
expt = "sb_cc_sine";		/* sb current clamp, sine wave grating */
expt = "sb_cc_sine_simp";	/* sb current clamp, simple cable, sine wave stim at 2 locs*/
expt = "istim_soma";		/* somatic current */
expt = "gc_epsc";		/* spot, short flash with vclamp to see epsc*/
expt = "gc_epsp";		/* spot, short flash with cclamp to see epsp*/
expt = "gc_cc_tofro";		/* gc current clamp, bar moving right, left */
expt = "gc_vc_tofro";		/* gc voltage clamp, bar moving right, left */
expt = "sb_Rvalues"; 		/* compute R values using vclamps*/
expt = "help";  		/* Show "expt" values on command line or here */

bg_inten = 10000;		/* backgnd light inten for photoreceptors   */
v_bp_dark = -.05;		/* bp dark voltage (for "transducer")       */

ds_orient = 0;			/* amac cell orientation in degrees */
ds_odt    = 45;			/* amac cell random angle range in deg. */
am_output_dist = 50;		/* amac output closer */

gcdendn = 3;			/* which gc dendrite to use */

con_zloc = 20;			/* photoreceptor layer */
bp_zloc  = 15;			/* bp stratum */
am_zloc  = 10;			/* amacrine stratum */
gc_zloc  = 5;			/* GC dendrite arborization stratum */

ndens_R  = 1;			/* max number of dens for which to find R's */
somamode = 0;			/* compute DS at the soma also */

dd = setvar();			/* set values from command line */

//if (addca && make_photorec){
//   fprintf(stdout,"Choosing both Ca-chans and photorecs not yet possible. \n");
//   fprintf(stdout,"To run with ca-chans, type --make_photorec 0 \n");
//   exit;
//};

if (notinit(info)) info = 2;	/* level of information printout */

if (notinit(libdir)) libdir = "ds5_suppl/";   /* subdir with library funcs */
if (notinit(gcfile)) gcfile = "ds1a";        /* gc   cell anatomy */
if (notinit(amacfile)) amacfile = "sb1";  /* amac cell anatomy */
if (notinit(segfile))  segfile  = libdir+"dsseg5.n";     /* make cable segments */

if (notinit(gcdensfile)) gcdensfile = libdir+"gcdens.n";  /* gc cell biophysics */

if (addca) amdensfile = libdir+"amdensca.n";		   /* only cachans distal */
if (notinit(amdensfile)) amdensfile = libdir+"amdens.n";  /* am cell biophysics */

if (!notinit(make_amac)) make_am = make_amac;


if (expt != "help"	     &&	/* check for valid experiment */
    expt != "gc_surf_area"   &&
    expt != "am_surf_area"   &&
    expt != "make_sb"        &&
    expt != "sb_cc_tofro"    &&
    expt != "sb_vc_tofro"    &&
    expt != "sb_cc_stepbar"  &&
    expt != "sb_cc_stepspot" &&
    expt != "sb_cc_annulus"  &&
    expt != "sb_cc_sine"     &&
    expt != "sb_cc_sine_simp" &&
    expt != "sb_cc_sineann"  &&
    expt != "istim_soma"     &&
    expt != "gc_epsc"        &&
    expt != "gc_epsp"        &&
    expt != "gc_cc_tofro"    &&
    expt != "gc_vc_tofro"    &&
    expt != "sb_Rvalues")
  {
  fprintf (stderr,"ds: unknown experiment '%s'. Check with '%s --expt help'.\n",
    	expt,infile);
    exit;
  };

if (expt=="help") {

  fprintf (stderr,"DS GC simulation, version %s\n",print_version(dsversion));
  fprintf (stderr,"\n");
  fprintf (stderr,"Usage: ds3 [options] [-v] file.n [ | vid ] \n");
  fprintf (stderr," options:  -d 1     (display anatomy; see 'nc .h')\n");
  fprintf (stderr,"           -R       (display in ray trace mode)\n");
  fprintf (stderr,"           -v       (display in video mode)\n");
  fprintf (stderr,"           --expt  surf_area   | make_sb | istim_soma\n");
  fprintf (stderr,"                | gc_epsc      | gc_epsp \n");
  fprintf (stderr,"                | gc_cc_tofro  | gc_vc_tofro\n");
  fprintf (stderr,"                | sb_cc_tofro  | sb_vc_tofro\n");
  fprintf (stderr,"                | sb_cc_stepbar| sb_cc_stepspot\n");
  fprintf (stderr,"                | sb_cc_annulus\n");
  fprintf (stderr,"           --gcfile s    (ds1a)\n");
  fprintf (stderr,"           --amacfile s    (sb1)\n");
  fprintf (stderr,"           --segfile  s    (dsseg5.n)\n");
  fprintf (stderr,"           --densfile s    (gcdens.n)\n");
  fprintf (stderr,"           --densfile s    (amdens.n)\n");
  fprintf (stderr,"           --densfile x    (amdens.n)\n");
  fprintf (stderr,"           --make_bp   n   (1)\n");
  fprintf (stderr,"           --make_am   n   (1)\n");
  fprintf (stderr,"           --make_gc   n   (1)\n");
  fprintf (stderr,"           --am_morph n   (2)\n");
  fprintf (stderr,"           --gc_morph n   (0)\n");
  fprintf (stderr,"           --am_dend n     (select am dendrite (3))\n");
  fprintf (stderr,"           --rec_am_angle n(record from am angle (0 deg))\n");
  fprintf (stderr,"           --velocity n    (bar velocity (1000 um/sec))\n");
  fprintf (stderr,"           --amvstart n    (starting sbac voltage -.058V)\n");
  fprintf (stderr,"           --Rnod n    (find Rin for nodenr n)\n");
  fprintf (stderr,"	      --ndens_R n (find Rin for max n dendr (def=1))\n");
  fprintf (stderr,"           --ndendrec n (nr of rec-sites per dendrite (default=4))\n");
  fprintf (stderr,"           --stimdia n (stimulus diameter (default=30um))\n");
  fprintf (stderr,"           --showstim n (which stimulus to show (default=FUG) with -d 17)\n");
exit;
};

/*-------------- set build params ---------------------------*/

/* parameters to set before building model */

if (expt == "am_surf_area") {
  make_bp	= 0; 	 	/* =1 -> make bipolar cell */
  make_am	= 1; 	 	/* =1 -> make amacrine cell */
  make_gc	= 0; 	 	/* =1 -> make ganglion cell */
}
else if (expt == "istim_soma") { /* somatic current stimulus, one step */

  make_bp	= 0; 	 	/* =1 -> make bipolar cell */
  make_am	= 0; 	 	/* =1 -> make amacrine cell */
}
else if (expt == "make_sb") {	/* make sb amacrine only */
  make_bp	= 0; 	 	/* =1 -> make bipolar cell */
  make_am	= 1; 	 	/* =1 -> make amacrine cell */
  make_gc	= 0; 	 	/* =1 -> make ganglion cell */
  if (notinit(am_dend)) am_dend = -1;   /* make all am dendrites */
  if (notinit(am_morph)) am_morph = 0;  /* use real anatomy */
}
else if (expt == "sb_cc_tofro") {/* bar moving right, left */
  make_bp	= 1; 	 	/* =1 -> make bipolar cell */
  make_am	= 1; 	 	/* =1 -> make amacrine cell */
  make_gc	= 0; 	 	/* =1 -> make ganglion cell */
  if (notinit(am_dend)) am_dend = -1;   /* make all am dendrites */
  if (notinit(am_morph)) am_morph = 0;  /* use real anatomy */
  if (notinit(amvstart)) amvstart = -.058;  /* starting voltage on amac dtree */
}
else if (expt == "sb_vc_tofro") {/* bar moving right, left */
  make_bp	= 1; 	 	/* =1 -> make bipolar cell */
  make_am	= 1; 	 	/* =1 -> make amacrine cell */
  make_gc	= 0; 	 	/* =1 -> make ganglion cell */
  if (notinit(am_dend)) am_dend = -1;   /* make all am dendrites */
  if (notinit(am_morph)) am_morph = 0;  /* use real anatomy */
  if (notinit(amvstart)) amvstart = -.051;  /* starting voltage on amac dtree */
}
else if (expt == "sb_cc_stepbar") {/* 2 spots, short distance */
  make_bp	= 1; 	 	/* =1 -> make bipolar cell */
  make_am	= 1; 	 	/* =1 -> make amacrine cell */
  make_gc	= 0; 	 	/* =1 -> make ganglion cell */
  if (notinit(am_dend)) am_dend = -1;   /* make all am dendrites */
  if (notinit(am_morph)) am_morph = 0;  /* use real anatomy */
  if (notinit(amvstart)) amvstart = -.044;  /* starting voltage on amac dtree */
}
else if (expt == "sb_cc_stepspot") {/* 2 spots, short distance */
  make_bp	= 1; 	 	/* =1 -> make bipolar cell */
  make_am	= 1; 	 	/* =1 -> make amacrine cell */
  make_gc	= 0; 	 	/* =1 -> make ganglion cell */
  if (notinit(am_dend)) am_dend = -1;   /* make all am dendrites */
  if (notinit(am_morph)) am_morph = 0;  /* use real anatomy */
  if (notinit(amvstart)) amvstart = -.058;  /* starting voltage on amac dtree */
}
else if (expt == "sb_cc_annulus") {/* expand, shrink annulus */
  make_bp	= 1; 	 	/* =1 -> make bipolar cell */
  make_am	= 1; 	 	/* =1 -> make amacrine cell */
  make_gc	= 0; 	 	/* =1 -> make ganglion cell */
  if (notinit(am_dend)) am_dend = -1;   /* make all am dendrites */
  if (notinit(am_morph)) am_morph = 0;  /* use real anatomy */
  if (notinit(amvstart)) amvstart = -.058;  /* starting voltage on amac dtree */
}
else if (expt == "sb_cc_sineann") {/* expand, shrink sinewave-annulus */
  make_bp	= 1; 	 	/* =1 -> make bipolar cell */
  make_am	= 1; 	 	/* =1 -> make amacrine cell */
  make_gc	= 0; 	 	/* =1 -> make ganglion cell */
  if (notinit(am_dend)) am_dend = -1;   /* make all am dendrites */
  if (notinit(am_morph)) am_morph = 0;  /* use real anatomy */
  if (notinit(amvstart)) amvstart = -.0541;  /* starting voltage on amac dtree */
}
else if (expt == "sb_cc_sine") {/* move sine wave grating right, left */
  make_bp	= 1; 	 	/* =1 -> make bipolar cell */
  make_am	= 1; 	 	/* =1 -> make amacrine cell */
  make_gc	= 0; 	 	/* =1 -> make ganglion cell */
  if (notinit(am_dend)) am_dend = -1;   /* make all am dendrites */
  if (notinit(am_morph)) am_morph = 0;  /* use real anatomy */
  if (notinit(amvstart)) amvstart = -.054;  /* starting voltage on amac dtree */
}
else if (expt == "sb_cc_sine_simp") {/* move sine wave grating right, left */
  make_bp	= 1; 	 	/* =1 -> make bipolar cell */
  make_am	= 1; 	 	/* =1 -> make amacrine cell */
  make_gc	= 0; 	 	/* =1 -> make ganglion cell */
  if (notinit(am_dend)) am_dend = -1;   /* make all am dendrites */
  if (notinit(am_morph)) am_morph = 0;  /* use real anatomy */
  //amacfile = "sbsimpden2"; /* use a simple cable model */
  bpam_somasyns = 1;			/* make bpam synapses to soma */
  if(notinit(ransd)) ransd = 3456789;	/* use bp array with bp close to soma */
  if (notinit(amvstart)) amvstart = -.054;  /* starting voltage on amac dtree */
}
else if (expt == "sb_Rvalues")
{/* compute values of R and print them on screen */
  make_bp	= 1; 	 	/* =1 -> make bipolar cell */
  make_am	= 1; 	 	/* =1 -> make amacrine cell */
  make_gc	= 0; 	 	/* =1 -> make ganglion cell */
  if (notinit(am_dend)) am_dend = -1;  /* make all am dendrites */
  if (notinit(am_morph)) am_morph = 0;/* use real anatomy */
  if (notinit(amvstart)) amvstart = -.058;/* starting voltage on amac dtree */
}
else if (expt == "gc_epsc") 	/* short light flash, one step */{
  make_amgc	= 0; 	 	/* =1 -> make amacrine cell -> GC synapses */
}
else if (expt == "gc_epsp") {	/* short light flash, one step */
  make_amgc	= 0; 	 	/* =1 -> make amacrine cell -> GC synapses */
};

if (notinit(sblur)) sblur = 10;

/*-------------- make ---------------------------------------*/

if (!make_bp) {
  make_bpam = 0;
  make_bpgc = 0;
};

if (!make_am) {
  make_bpam = 0;
  make_amgc = 0;
};

if (!make_gc) {
  make_bpgc = 0;
  make_amgc = 0;
};

while (ds_orient >= 360) ds_orient -= 360;
while (ds_orient < 0) ds_orient += 360;


if (notinit(gcvstart)) gcvstart = -.06;   /* starting voltage on dend tree */
if (notinit(amvstart)) amvstart = -.058;  /* starting voltage on amac dtree */
if (notinit(amvrev))   amvrev = -.06;     /* vrev on amac dtree     */
if (notinit(ndens_R))  ndens_R = 1;       /* max. dens to compute R */

if (notinit(gc_dia_factor)) gc_dia_factor = 1;
if (notinit(am_dia_factor)) am_dia_factor = 1;
if (notinit(ath_dia)) ath_dia = 0.6667;  /* default diameter of thin segment */

if (notinit(gc_morph))   gc_morph   = 0;
if (notinit(am_morph))   am_morph   = 2;
if (notinit(gc_biophys)) gc_biophys = 0;
if (notinit(am_biophys)) am_biophys = 0;

if (addca) am_biophys = 1;	   /* addca = add (only) Ca chans in dist dens */

if (gc_biophys || am_biophys) memb_biophys = 1  /*  file if biophys */
else                          memb_biophys = 0;

if (memb_biophys) {		/* reduce time step for membr. channels */
  //timinc = 1e-5;
  //ploti  = 2e-5;
  timinc = 1e-4;
  ploti  = 1e-4;
};

/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

/*

  printf ("# /* DS GC simulation, version %s\n",print_version(dsversion));
  printf ("#\n");
  fprintf (stderr,"C");

  if (info>=1) {
  printf ("#   script name:    %s     \n",  infile);
  printf ("#   date:           %s     \n", ccstr(system("date")));
  printf ("#   machine:        %s     \n", ccstr(system("hostname -s")));
  printf ("#   nc version:     %s     \n", print_version(ncversion));
 if (gc_morph)
  printf ("#   gc cell:        %s     \n",  "simple")
 else
  printf ("#   gc cell:        %s     \n",  gcfile);
 if (am_morph>0)
  printf ("#   am cell:        %s %d  \n",  "simple",am_morph)
 else
  printf ("#   am cell:        %s     \n",  amacfile);
 if (memb_biophys) {
  printf ("#   gc_biophys:     %g     \n",  gc_biophys);
  printf ("#   am_biophys:     %g     \n",  am_biophys);
  printf ("#   gc dens file:   %s     \n",  gcdensfile);
  printf ("#   am dens file:   %s     \n",  amdensfile);
 };
  printf ("#   experiment:     %s     \n",  expt);
  printf ("#\n");
  };
*/

/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

MAXNUMCELL=1000;
dim celden[nceltypes][MAXNUMCELL] = {{0}};  //holds total nr of nodes

/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

include (libdir+"dsdefs.n");

include (segfile); 		/* functions to create gc and am cable segs */

/*  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  */

proc find_maxmin(ct)

 /* procedure to find how large the GC or AMAC dendritic tree arrays are */

{
    local c, d;

    xmax = -1e6;
    xmin =  1e6;
    ymax = -1e6;
    ymin =  1e6;
    foreach cable ?br node [ct] ?c ?d
    {  /* find existing dendritic tree */
    //print c, d, element br -> elabl;
       if ((element br -> elabl) == "dend" || (element br -> elabl) == "dend_dist")
       {
        if (node [ct][c][d] -> xloc > xmax) xmax = node [ct][c][d] -> xloc;
        if (node [ct][c][d] -> xloc < xmin) xmin = node [ct][c][d] -> xloc;
        if (node [ct][c][d] -> yloc > ymax) ymax = node [ct][c][d] -> yloc;
        if (node [ct][c][d] -> yloc < ymin) ymin = node [ct][c][d] -> yloc;
       };
    };
    if (xmax < xmin)
    {  xmax = 1;
       xmin = 0;
    };
    if (ymax < ymin)
    {  ymax = 1;
       ymin = 0;
    };
};

/*  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  */

if (make_gc)		//include functions to make ganglion cell
  include libdir+"gcfuncs.n"
else
  {		/* no gc */

    if (notinit(xmax))  xmax  =  200;
    if (notinit(xmin))  xmin  = -200;
    if (notinit(ymax))  ymax  =  200;
    if (notinit(ymin))  ymin  = -200;

    xsize = xmax - xmin;
    ysize = ymax - ymin;
    xcent = int((xmax + xmin) * .5);
    ycent = int((ymax + ymin) * .5);
  };



if (make_gc){
  local n;

  if (notinit(ngc)) ngc=1;	//nr of ganglion cells
  dim gc_arr [ngc][3] = {{0}}; //xloc, yloc, direction

  for(n=0;n<ngc;n++){
    make_gcell(n,gc_arr[n][LOCX],gc_arr[n][LOCY],gc_arr[n][DIR],gc_morph);
  };

};

/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

if (make_am) include (libdir+"amacfuncs_ds5.n");  //functions to make starburst amacrine

/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

if (!make_gc && make_am)
{
  find_maxmin(am); 		/* find out how large amacrine array is */
  if (am_morph==1 && am_nden==2) ammargin = 20;
  if (notinit(ammargin)) ammargin = 15;

  xmax += ammargin;
  ymax += ammargin;
  xmin -= ammargin;
  ymin -= ammargin;
}
else
{
  if (!make_gc) {		/* no gc or amac cells */
    if (notinit(xmax))  xmax  =  200;
    if (notinit(xmin))  xmin  = -200;
    if (notinit(ymax))  ymax  =  200;
    if (notinit(ymin))  ymin  = -200;

  };
};  /* if (!make_gc) */

xsize = xmax - xmin;
ysize = ymax - ymin;
xcent = int((xmax + xmin) * .5);
ycent = int((ymax + ymin) * .5);

/* find biggest radius for "sineann" stimulus (look along 2 axes) */
if (xmax>(0-xmin))
   sb_maxdenx = xmax
else
   sb_maxdenx = 0-xmin;

if (ymax>(0-ymin))
   sb_maxdeny = xmax
else
   sb_maxdeny = 0-xmin;

if (sb_maxdeny>sb_maxdenx)
   sb_maxden = sb_maxdeny
else
   sb_maxden = sb_maxdenx;

/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
n_bp = 0;

if (make_bp)

/* Compute nr of bipolar cell to make (global var n_bp);  */
/*  Make only enough bipolar cells to fill GC's dendritic field */

{
   if (notinit(bp_nn))  bp_nn = 12;
   if (notinit(ransd)) ransd = 1173;

   n_bp = gausnn (bparr, center (xcent,ycent), size (xsize,ysize),
		nnd=bp_nn, reg=10, rsd=ransd, ginfo=info);
   if (info >= 2)
     printf ("# number of bipolar cells  %g\n",n_bp);
};

/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

if (make_bp) dim allconenames[n_bp]={{0}};	//array to hold enames of all cones

if (make_bp) {

/* make bipolar cells */

  for (i=0; i<n_bp; i++) {
     local bpx,bpy,bpt,bpb;

     /* make random bipolar array */
    bpx = bparr[i][LOCX];		/* make random offset */
    bpy = bparr[i][LOCY];

    at [bp][i] loc (bpx,bpy,bp_zloc) sphere dia 5 vrev -.07 vrest -.07;

    if (make_photorec) {	/* make photoreceptors */
      at [con][i] loc  (bpx,bpy,con_zloc) sphere dia 5 vrev=-0.06;
      at [con][i] cone (bpx,bpy) dia 3 maxcond=50e-12 photnoise=0 linit=bg_inten
	 				 ename allconenames[i];
      connect [con][i] to [bp][i] synapse close maxcond=50e-12 vrev=0.0
	 				 thresh=conethr expon=exponcon;
    }
    else {			/* make transducer */
      at [bp][i] transducer (bpx,bpy);
    };
  };
};

/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

if (info>=1) {
  printf ("# Done making neurons.\n");
  printf ("#\n");
};

/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  /* limit the elements to within bounds */

  /* limit amacrine cells */
elimit X max xmax min xmin Y max ymax min ymin;

foreach element ?e node [-1][-1][-1]  {
  if ((element e ->elabl) == "dend" ||(element e ->elabl) == "dend_dist")
    elimit element e;
};

/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

if (make_bpgc) {
     dim bpgcsyns[n_bp+1];		/* array to hold synapse numbers */
};

if (make_bpam) {

     dim bpamsynsb[n_bp+1]={{-1}};       /* bipolar -> amacrine synapses */
     //dim bpamsynsa[n_am+1][n_amseg+1];   /* amacrine nodes contacted by bipolars */
     dim bpamsynsa[n_am+1][n_amseg*2]; 
};

if (make_amgc){
     dim amgcsyns [n_am+1][n_amseg+1];   /* amacrine -> gc synapses */
};

/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

include libdir+"synapsefuncs.n";	/* include functions to make synapses */

/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

/* Remove all bipolars not connected to amacrines */

conecount=n_bp;
if (make_photorec){
for(i=0;i<n_bp;i++) {
  if (bpamsynsb[i]<0) {		// = -1 -> no bpam synapse
     erase node [bp][i];	// erase bipolar nodes
     if (make_photorec) {	// if there are photoreceptors, erase them too
        erase node [con][i];
        conecount--;            // number of remaining cones
        allconenames[i]=-1;	// mark all erased conenames
     };
   };
};
};
/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

if (conecount>0) dim conenames[conecount]={{0}};	       //array to hold enames of nonerased cones

if (make_photorec) {
  for (r=i=0;i<n_bp;i++) {
    if (allconenames[i]!=-1) {	//if cone was not erased
       conenames[r++]=allconenames[i];  //put name in array conenames
    };
  };
};

/*-------------- display ------------------------------------*/


if (disp) {
 display size xsize;
 display center (xcent,ycent,10);
 //display cmap=4;
 //display calibline 20;
 if (notinit(dxrot)) dxrot = 0;
 display xrot dxrot;

/* display matching [gc][0][-1] except cable;			/* */
/* display sphere matching [bp][-1];				/* */
// display synapse matching [bp][-1] color 4;			/* */

if (1) { 			/* display gc */
  display sphere matching [gc][-1][-1] color 1;			/* */
  display cable  matching [gc][-1][-1] color 1 dscale 1;	/* */
  display node   matching [gc][-1][-1] color 5 dscale 1;	/* */
  display comps  matching [gc][-1][-1] color 4;			/* */
 };
if (0) { 			/* display bipolar */
  display sphere matching [bp][-1] color 2	;			/* */
  display cable  matching [bp][-1] dscale 1 color 4;		/* */
  //display node   matching [bp][-1] color 5 dscale 1;		/* */
  display comps matching [bp][-1] color 1;			/* */
 };
if (1) { 			/* display amacrine */
  display sphere matching [am][-1][-1] color 0 dscale 1;	/* */

  if (am_morph==0)	     //if real anatomy is used
  { for (i=1; i<amlines; i++)  //show distal zone in different color
    {
      n = amcabldata[i][NODE];
      r = amcabldata[i][REG];
      if (r==DEND_DIST)
    	display cable  matching [am][-1][n] color 4 dscale 1
      else if (r==DEND)
    	display cable matching [am][-1][n] color 1 dscale 1;
    };
  }
  else display cable  matching [am][-1][-1] color 0 dscale 4;	/* */
  //display cmap=1;
  display node   matching [am][-1][-1] color 0 dscale -3.035;	/* */
  display comps  matching [am][-1][-1] color 0 dscale 1;	/* */
 };
if (0) { 			/* display bp->gc synapses */
  display synapse matching [gc][-1][-1] color 5 dscale 1;     /* */
  display synapse matching [am][-1][-1] color 5 dscale 1;     /* */
 };

 //if (!addca) exit;		/* if no ca-chans, exit when done display */

};

/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

proc drawcolscale(camax,camin)

 /* Draw the scalebar for cacolor display */

{
    local ybar,xbar,colbarlen;
    local wid,numcols,dist;
    local width,linewidth;

 ybar=0.05;
 xbar=0.15;
 colbarlen=0.40;
 wid = 0.03;
 numcols = 16; 		//nr of colors used
 dist = colbarlen/numcols;
 linewidth=wid/30;

  gframe ("Col_bar");
  gorigin (xbar,ybar);
  for (width= -wid/2.0; width<wid/2.0; width+= linewidth) 
  {
     gmove (0, width);
     for (i=0; i<numcols; i++){
	gpen(i+16);			/*use 2nd set of 16 cols from col tabl */
	//gmove (i*dist+.001, width);
        gdraw ((i+1)*dist, width);
     };
  };
  gmove(-0.1,-0.002);
  gpen (15);
  gtext("MIN");
  gmove(-0.1,-0.03);
  sprintf (nbuf,"%.3g",camin);		//lowest [Ca]i
  gtext(nbuf);
  gmove(0.06,0.025);
  gtext ("[Ca]i at time t=%g s",cadisptime);
 
  gmove(colbarlen+0.05,-0.002);
  //gtext("MAX");
  gtext("MAX(@ dist rec-pnt)");
  gmove(colbarlen+0.05,-0.03);
  sprintf (nbuf,"%.3g M",camax);	//highest [Ca]i
  gtext(nbuf);
  
  gframe ("..");
  //grframe ("Col_bar");
};

/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

proc disp_ca(peakCaval)

/* At cadisptime, show starburst anatomy color-coded for [Ca] */
/* Set min and max [Ca]i as default for display. */

{
  local cellnr;

  if (addca) {
    if (notinit(camax)) camax= peakCaval; //peak [Ca]i at cadisptime from onplot()
    if (notinit(camin)) camin=0;

    display cable matching [am][cellnr] color=cacolor min camin max camax;
    //display stim at cadisptime dscale 5;	//show stimulus

    drawcolscale(camax,camin);	//add a scale bar
    exit;
  };
};

/*------------ plot -----------------------------------------*/

if (notinit (ndendrec))		// number of recording sites per dendrite
NDENDREC = 4
else NDENDREC = ndendrec;

NUMDEN=30;   			//number of dendrites, set to max number

dim am_dend_rec[NDENDREC] = {{0}};	// array to hold recording sites
dim am_dend_recR[NDENDREC] = {{-1}};	// array to hold recording sites for computeR
//print am_dend_rec;
//print am_dend_recR;

dim R [NUMDEN][NDENDREC];	/* array to hold all R-values computed */

DENFOUND  = 0;
RMIN      = 1;
RMAX      = 2;
MAXNOD    = 3;
NDENPARMS = 4;
dim denparms [NDENPARMS];	/* holds denfound,rmin,rmax,xdmaxnod  */
				/* (see func searchdend) */

NORANGE = 0;			// range of 0 means no range, proc must find one
temp_angle=0;			// global variable to hold the value of an angle
				// found by am_ifden_angle

if (notinit(rec_am_angle))  rec_am_angle  = 0;  // angle of dendrite to record

/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

func searchdend(ctype,c,anglrad,dt)
		/* dt (searchrange), anglrad both in RAD-units! */
{
   local xsoma,ysoma,denfound1;
   local rmax,rmin;
   local anglmax,anglmin,d1,d2,d3;

   xsoma = node [ctype][c][0] -> xloc;  /* xsoma is the x-loc of node 0 (soma) */
   ysoma = node [ctype][c][0] -> yloc;

   /* First look at nodes within most exact range of angles possible: */
   rmax = -1;
   rmin =  1e10;

   anglmax = anglrad + dt;	//in radians
   anglmin = anglrad - dt;

   foreach cable ?cbrnum node [ctype][c] ?cnod
   {
     xden  = node [ctype][c][cnod] -> xloc;
     yden  = node [ctype][c][cnod] -> yloc;
     dx = xden - xsoma; //x-dist between den-node and soma
     dy = yden - ysoma; //y-dist        ""
     dangl = atanx(dx,dy);

        /* atanx gives angle in RAD: dy/dx is tan(angle), */
	/* so atan(dy/dx) gives that angle */

     r = sqrt(dx*dx+dy*dy);
     d1=dangl-anglmax;
     d2=dangl-anglmin;

     if (inrange(anglmin,anglmax,dangl)) /* dendrite must be in angle range */
        {
         if (rmin > r) rmin = r; //if r is smaller than rmin, change rmin
         if (rmax < r)
	 	{
		 rmax = r;		//if r is bigger than rmax, change rmax
            	 xdmaxnod = cnod;	//that node then becomes the farthest node
        	};
        };
   };

  denfound1 = (rmax != -1);	//denfound=1 when a dendrite is found, 0 otherwise
  denparms[DENFOUND]=denfound1;
  denparms[RMIN]=rmin;
  denparms[RMAX]=rmax;
  denparms[MAXNOD]=xdmaxnod;
  return denfound1;
};

/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

func am_ifden_rec (c, angl, searchrange)

 /* Finds recording points on dendrites. If it finds a SBAC dendrite
    within a certain range of angles,
       1) Get first node within radius range,
       2) Try to get node that receives connection from bipolar
           (for bp synapse recording).
        3) Assumes soma is node 0, and that its primary dendrites
            start at node 1.
 */

{
   local i, n, q, ctype, rmax, rmin, count, nborders;
   local dim rbounds[NDENDREC*2];
   local dim nfound[NDENDREC]={{0}};		//if recsite x found, nfound[x]=1
   local xden, yden, xsoma, ysoma;
   local dx,dy,dangl,nelem;
   local cbrnum, cnod, nod1, nod2, nconn;
   local xdmaxnod;
   local anglrad,anglmax, anglmin,dtexact;
   local recsitewidth, nmidsites, interval, fraction;
   local denfound;

   nborders = NDENDREC*2;
   nmidsites = NDENDREC-2;		//# of sites excluding the extreme ones
   recsitewidth=.1;

   count = 0;
   ctype = am;

   anglrad = angl/DEG;
   dtexact = 2*PI/30;


   denfound=searchdend(ctype,c,anglrad,dtexact);

   if (!denfound)	//if no dendrite found in the exact search
   {
     if(searchrange == NORANGE)	//no searchrange entered, expand search to 2PI/10
     {
    	denfound=searchdend(ctype,c,anglrad,2*PI/10);
	if (!denfound) denfound=searchdend(ctype,c,anglrad,2*PI);
     }
     else		//searchrange is used to search only that range
     {
      dt = .5*searchrange;
      denfound=searchdend(ctype,d,anglrad,dt);
     };
   };

    /* If found, then follow through parent nodes to soma. */
    /* First initialise bounds for placing the recording sites, */
    /* but check that NDENDREC isn't too big */

   if (denfound)
   {

    if (NDENDREC >10) {
	printf ("#The number of recording sites NDENDREC may not exceed 10!!!");
	exit;
    };

    /* Interval defined as:  space between sites / num of intervals needed */

    interval=((1-2*recsitewidth)-(recsitewidth*nmidsites))/(nmidsites+1);
    rmin=denparms[RMIN];
    rmax=denparms[RMAX];
    xdmaxnod=denparms[MAXNOD];

    //this fills rbounds, to generate separate areas to look for rec-sites:
    if (NDENDREC==4)	//standard situation, sites are set "by hand"
    { rbounds[0] = (rmax-rmin) *  .15  + rmin;
      rbounds[1] = (rmax-rmin) *  .3  + rmin;
      rbounds[2] = (rmax-rmin) *  .5 + rmin;
      rbounds[3] = (rmax-rmin) *  .65  + rmin;
      rbounds[4] = (rmax-rmin) *  .9 + rmin;
      rbounds[5] = rmax;
    }
    else		//bounds are automatically generated
    {
      for (q=1;q<nborders;q++)
      {
	if (q==1)
	fraction=0			    //so that rbounds[0]=rmin
	else if ((q%2)!=1)
	fraction=fraction+recsitewidth	    //for odd q, add recsitewidth
	else
	fraction=fraction+interval;	    //for even q, add interval

	rbounds[q] = (rmax-rmin)*fraction + rmin;
      };
    };

    //find angle (in deg) of farthest node and remember it in global var
    xsoma = node [ctype][c][0] -> xloc;
    ysoma = node [ctype][c][0] -> yloc;
    xden  = node [ctype][c][xdmaxnod] -> xloc;
    yden  = node [ctype][c][xdmaxnod] -> yloc;
    dx = xden - xsoma;
    dy = yden - ysoma;
    temp_angle=atanx(dx,dy)*DEG;

   for (n=xdmaxnod; n != soma; n)
    {
     xden  = node [ctype][c][n] -> xloc;
     yden  = node [ctype][c][n] -> yloc;
     dx = xden - xsoma;
     dy = yden - ysoma;
     r = sqrt(dx*dx+dy*dy);

     am_dend_rec[0]=0;		//make soma first rec-point!
     nfound[0]=1;		//so first rec-point is always found
     for (q=1,i=0;q<NDENDREC;q++,i=i+2)
     {
     	if (!notinit(bpamsynsa[c][n]) && r > rbounds[i]  &&
			r <= rbounds[i+1] && !nfound[q]) {

	  if (searchrange==NORANGE) am_dend_rec[q] = n
	  else am_dend_recR[q] = n;
	  nfound[q] = 1;
	};
     };

     nconn = node [ctype][c][n] -> numconn;
     //fprintf (stderr,"B %g nconn %g\n",n,nconn);

     for (i=1; i<=nconn; i++)
     {  					/* Find path back to soma */
        nelem = node [ctype][c][n] -> i;
        //fprintf (stderr,"C %g %g %s\n",nelem,i,element nelem->type);
        if (element nelem->ntype != ntype(cable)) continue;
        if (info>2) printf ("tracing from node %g conn %g\n",n,i);
        nod1=element nelem->node1c;
        nod2=element nelem->node2c;
        //fprintf (stderr,"nod1 %g nod2 %g n %g r %g\n",nod1,nod2,n,r);
        if (nod2 == n) continue;        	/* descendent node */
        if (nod1 == n)
	{
	 n = nod2;        			/* follow parent node */
 	 break;
        };
     };  /* for (i;;) */
    }; /* for (n;;)   */
   }; /* if(denfound) */

   if(info >= 2)
   {
	for (q=NDENDREC-1;q<NDENDREC;q++)
	{  
	   if (searchrange==NORANGE)
	     {at [ctype][c][am_dend_rec[q]] electrode dia 10;
	      display electrode matching [am][c][am_dend_rec[q]] color 0 dscale 2;
	     }
	   else
	     {local rsite;
	        if ((rsite=am_dend_recR[q])!=-1)
	          {at [ctype][c][rsite] electrode dia 10;
	           display electrode matching [am][c][rsite] color 0 dscale 2;
	          };
	     };
	};
    	//if (disp) exit;
   };
   if (info >= 3)
   {
   	printf ("# am_dend %g recording nodes:\n",dend);
	for (q=0;q<NDENDREC;q++)
	printf ("%g; ", am_dend_rec[q]);
   };
   if (addca==2)	//add ca-channel at one node only
   {add_oneCachan();};

   return denfound;
};

/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

func findnode()

/* Finds node in array of recording points am_dend_rec,
   User can specify node using DSloc (0=soma,..),
   otherwise farthest node is found.
*/

{
    local recnod,cellnr;
    cellnr=1;

  if (notinit(DSloc))	{	/* unless node specified, get outermost node */
     for (recnod=NDENDREC-1;recnod>=0;recnod--)
        {  if (am_dend_rec[recnod]!=-1)  // take the outermost existing rec-node
   	   { if (addca)		   // only take node w/Ca-compartment
	       { if (node [am][cellnr][am_dend_rec[recnod]] -> cacomp)
                 break;
	       }
	     else
	       break;
	   };
        };
  }
  else if (addca) {	 // if addca, only accept DSloc node with Ca-compartment
    if (node [am][cellnr][am_dend_rec[DSloc]] -> cacomp)
       recnod=DSloc
     else {
	fprintf(stderr,
	   "# Func findnode error; for DSloc please select node with Ca-comp.");
        exit;
       };
  }
   else if (DSloc>=NDENDREC || DSloc<0 || am_dend_rec[DSloc]== -1)
       {
	fprintf (stderr,"# The node entered is not a valid rec-point.\n");
        fprintf (stderr,"# Please check func 'findnode()'.\n");
        fprintf (stderr,"# With DSloc enter range of 0 (=soma) - %g (distal)\n",
		NDENDREC-1);
	exit;
       }
    else
       recnod=DSloc;

    return recnod;
};

/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

proc add_oneCachan()
{
  local c,channod;
  c = 1;

  /* Find node to add channel at (default=outermost node; */
  /*  user can specify node with "--DSloc n") channod=findnode(); */

  /* add a Ca-chan at outermost node */

  at [am][c][am_dend_rec[channod]] chan Ca type=catyp offset=voff
	taua=ta taub=tb tauc=tc taud=td maxcond=numchan*caunitL
	capump vmax=.04e-5 km=5e-6;
};

/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

proc compute_R(dennum)

/* Calculate an array with R-values (assuming linearity),
   at dendritic sites selected by "am_ifden_rec()".
*/
{
  local cellnr,r,vc1,vc2,v1,v2,i1,i2,stimdur;

  cellnr = 1;
  vc1 = -0.030; 		//the first voltage used to clamp each node
  vc2 = -0.050; 		//the second voltage
  stimdur = 0.2; 	//duration of stimulus
  resettime = 0.1;	//how long to clamp to amvstart

  if (make_am) {
      for (r=0;r<NDENDREC;r++)
	  {
	     if (am_dend_recR[r]!=-1 && !notinit(am_dend_recR[r]))
	 	{
		 //if (r==0)
		 //{disp_am_vplot();
		 // disp_am_iplot();
		 //};
		 //time = 0;
		 stim node [am][cellnr][am_dend_recR[r]] vclamp vc1
						start=time dur=stimdur;
		  step stimdur-0.0001;
		  i1=I[am][cellnr][am_dend_recR[r]];
		  v1=V[am][cellnr][am_dend_recR[r]];

	 	 step 0.0001;
//print i1;
		 stim node [am][cellnr][am_dend_recR[r]] vclamp vc2
	 				start=time dur=stimdur;
	 	 step stimdur-0.0001;
	 	 i2=I[am][cellnr][am_dend_recR[r]];
		 v2=V[am][cellnr][am_dend_recR[r]];
		 step 0.0001;
//print i2;
		 stim node [am][cellnr][am_dend_recR[r]] vclamp amvstart
		 			start=time dur=resettime;
       		 step resettime;

		 di=i2-i1;
	 	 dv=v2-v1;
		 if (di==0) di=1e-20;

	 	 R[dennum][r]=dv/di;
	 	 //print am_dend_recR[r],r;
		 //i2,i1,di,v2,v1,dv,R[dennum][r];
		}
 	     else R[dennum][r]= -1;
	  };
    };

};

if (notinit(Rnod)) Rnod=-1;
//global variable Rnod, initialised from command line by giving node nr.
//default it is -1, R is not calculated for any single node

/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

func compute_R_nod(nodnum)

/* Calculates Rin (assuming linearity) for 1 node. */
/* If no rec-site, value is "-1". */

{
  local c,rval,v1,v2,i1,i2,stimdur;

  rval=-1;
  c = 1;
  v1 = -0.030; 		//the first voltage used to clamp each node
  v2 = -0.050; 		//the second voltage
  stimdur = 0.03; 	//duration of stimulus

  if (make_am) {
     time = 0;
     stim node [am][c][nodnum] vclamp v1
		 		start=time dur=stimdur;

     step stimdur-0.0001;
     i1 = I[am][c][nodnum];
     v1 = V[am][c][nodnum];
     step 0.0001;

     stim node [am][c][nodnum] vclamp v2
				start=time dur=stimdur;
     step stimdur-0.0001;
     i2 = I[am][c][nodnum];
     v2 = V[am][c][nodnum];
     step 0.0001;

     di = i2-i1;
     dv = v2-v1;
     if (di==0) di=1e-20;

     rval = dv/di;
     return rval;
  };
};

/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

NUMNODES=ndens_R*NDENDREC; 	//the number of recording nodes

dim dend_angles[NUMDEN];

/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

proc rec_all(c,res) 

/* res is number of angles cell c is divided into,  */
/* i.e. max # dendrites (default=ndens_R=1). */

/* A modified find_am_angle_rec to go along dendrites and record along */
/* a number of a cell's dendrites. */

{
	local angle,resstep,dennum,n;
	n=0;
	dennum=0;	/* keeps track of dend number, starting at 0 */
	if (res<=30) {
	   resstep=360/res;
	}
	else {
	  fprintf(stderr,"FOR ndens_R, Please enter a number in range 1-30.");
          exit;
	};

	for (angle=0;angle<360;angle+=resstep)
	{
	    if (am_ifden_rec (c,angle,resstep)) //if dend found, compute R
					//angle stored in global var temp_angle
	    {
	     dend_angles [dennum] = temp_angle; 
					//array stores the angles of found dens

	     compute_R(dennum++);	//R is computed, dend number is updated
	    };
	};
};

/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

proc showR()
{
	local i, n, r1add, rec, rval, rvalshort, rtot, nsites, avgdenR, dennum, p;
	local r1, denang, rvalue;
	local dim angle_short[NUMDEN];	//the rounded off angle-value
	local c;  	//which cell
	local dim add[NDENDREC]={{0}};
	local dim dennums[NDENDREC]={{1}};  //num of dendrites per rec-location
					    //init to ones to prevent div by 0
	local dim avgs[NDENDREC]={{0}};
	local dim SDs[NDENDREC];	    //the SD values per recsite
	local dim Rpersite[ndens_R];

	stim backgr bg_inten start 0;

	c=1; 				     /* starburst cell number */

	if (Rnod>=0)
	{
	   r1=compute_R_nod(Rnod);
	   printf ("#R (ohm) for for node %g: %g \n", Rnod, r1);
	}
	else
	{
	   rec_all(c,ndens_R);        //2nd arg = nr of dens to look for

	   //compute averages and SD's if necessary
	   for (n=0;n<ndens_R;n++) { //ndens_R is max# of dens where R is computed
	  	nsites=0;
		rtot=0;
		dennum=n+1;	//the dendrite number

		if (ndens_R>1) {
		  for (i=0;i<NDENDREC;i++) {
		    if (R[n][i]!=-1) {
		      add[i] = add[i] + R[n][i];
		      avgs[i] = add[i] /dennums[i];
		      dennums[i]++;
		    };
		  };
		};
		angle_short[n]=int((dend_angles[n]*10000+5)/10000);

		for (rec=0;rec<NDENDREC;rec++) {	//rec is recording site
		  rval = R[n][rec];
		   if (rval!=-1) { 	    //check if R value was found
		     rtot=rtot+rval;
		     nsites++;
	 	   };
		};

		if (nsites>0) avgdenR=rtot/nsites
		else
		printf ("#There were no recording sites, so no value for R!\n");
    	   };

	   if (ndens_R>1)
	   for (rec=0;rec<NDENDREC;rec++) {
	     for (n=0;n<dennum;n++) {
		rvalue=R[n][rec];
		if (!notinit(rvalue))
		  Rpersite[n]=rvalue;
             };
	     SDs[rec]=find_SD(Rpersite,avgs[rec]);
	   };

	   //display results
	   printf ("#Rec-site ");
	   for (i=0;i<dennum;i++) {
	     denang = (angle_short[i]/360) * 2 * PI; //dend-angl in rad
	     printf ("Dend %-5.3g ", denang);
	   };
	   printf ("Avg       SD\n");
	   for (rec=0;rec<NDENDREC;rec++) {
	     printf("%-10g",rec); 	    //print recpoint number
	     for (n=0;n<dennum;n++) {
	       if (R[n][rec]==-1)
	          R[n][rec] = 0;	    //set bad R values to 0 for display
	       printf("%-11.4g",R[n][rec]); //for every dend, print R values
	     };

	     if (ndens_R>1) { //show avg,SD only for more than one dendrite
	       printf("%-10.3g",avgs[rec]);
	       printf("%-10.3g",SDs[rec]);
	     };
	     printf("\n");
	   };
	};
}; /* showR */

/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

proc disp_bpam_rate(maxvesrate)
/* display bipolar cell vesicle release rate at 4 synapses */
{
  local plg, offtr, offb, c, q;

  plg   = maxvesrate;		/* gain of trace */
  offtr = .0;		/* position of trace within graph */
  offb  = 0;		/* trace offset base */

  c = 1;	/* amacrine cell to record from */
  done = 0;

  if (make_bpam) {
    for (q=0;q<NDENDREC;q++) {
      if (!notinit(bpamsynsa[c][am_dend_rec[q]]))
	if (done) {
	   plot FA9 bpamsynsa[c][am_dend_rec[q]] max (1-offtr)*plg+offb
			        min (0-offtr)*plg+offb
			        pen q+1 plnum 7  plsize .3;
        }
        else {
	  done=1;
          plot FA9 bpamsynsa[c][am_dend_rec[q]] max (1-offtr)*plg+offb
			        min (0-offtr)*plg+offb
			        pen q+1 plname "BpAm"  plnum 7  plsize .3;
        };
    };  /* for (q;;) */
  };  /* if (make_bpam) */
};

/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

proc disp_bpgc_rate()
/* display bipolar cell vesicle release rate at 2 synapses */
{
   local plg, offtr, offb;

  plg   = 500;		/* gain of trace */
  offtr = .0;		/* position of trace within graph */
  offb  = 0;		/* trace offset base */

/*
  if (make_bpgc) plot FA9 bpgcsyns[15] max (1-offtr)*plg+offb
				      min (0-offtr)*plg+offb
					  pen 5 plname "BpGc" plnum 7 plsize .3;

  if (make_bpgc) plot FA9 bpgcsyns[11] max (1-offtr)*plg+offb
				       min (0-offtr)*plg+offb
					  pen 1 plnum 7 plsize .3;
*/

};

/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

proc disp_am_vplot(vmin,vmax)
/* Display voltage at dendritic sites selected by "am_ifden_rec()" */
{
  local cellnr, q, plg, offtr, offb, done;

  done = 0; 	//just a var with value 0 or 1

    if (make_am) {
      if (expt == "sb_Rvalues")
        for (q=0;q<NDENDREC;q++) {
	   if (!notinit(am_dend_recR[q])&&am_dend_recR[q]!=-1)
 	   plot V[am][cellnr=1][am_dend_recR[q]] min vmin max vmax
					  pen q+1 plname "Vam" plnum 6;
	}
      else
        for (q=0;q<NDENDREC;q++) {
	  if (!notinit(am_dend_rec[q]))
 	  if (done)
	    plot V[am][cellnr=1][am_dend_rec[q]] min vmin max vmax
				pen q+1 plnum 6
	  else {
	    done =1;
	    plot V[am][cellnr=1][am_dend_rec[q]] min vmin max vmax
				pen q+1 plname "Vam" plnum 6;
	  };
	};  // q-loop
    };  // if (makeam)

  plg = 200;		/* gain of trace */
  offtr = .0;		/* position of trace within graph */
  offb  = 0;		/* trace offset base */
/*
  if (make_amgc) plot FA9 amgcsyns[c][8] max (1-offtr)*plg+offb
				         min (0-offtr)*plg+offb
					  pen 6 plname "AmGc"
					  plsize .5 plnum 4; /* */
};

/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

proc disp_am_caplot(maxCa) { /* display [Ca] inside cell at farthest node */

  local cellnr, recnod;

    if (make_am && addca) {
	/* find node with Ca-compart. (default=outermost node) */
	recnod=findnode();

	if (!disp) { 		/* Plot internal [Ca]: */
	  plot Ca(1)[am][cellnr=1][am_dend_rec[recnod]] min 0 max maxCa
				pen 4 plname "[Ca]i" plnum 8;
	  /* Plot currents from channel and pump: */
	  plot Ca(I)[am][cellnr=1][am_dend_rec[recnod]] min -2e-14 max 2e-14
				pen 5 plname "ICa" plnum 9;
	  plot Ca(IP)[am][cellnr=1][am_dend_rec[recnod]] min -2e-14 max 2e-14
				pen 6 plname "IP" plnum 9;
        };
     };
};

/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

proc disp_am_iplot(imin,imax)
/* Display current at dendritic sites selected by "am_ifden_rec" */
{
  local c, plg, offtr, offb, q;

  c = 1;

  plg   =  imax-imin; 			/* gain of trace */
  offb  =  imin; 			/* trace offset base */
  offtr = 0;				/* position of trace within graph */
  if (make_am) {
    if (expt == "sb_Rvalues")
      for (q=0;q<NDENDREC;q++) {
	 if (!notinit(am_dend_recR[q])&&am_dend_recR[q]!=-1)
	 plot I[am][c][am_dend_recR[q]] max (1-offtr)*plg+offb
		                       min (0-offtr)*plg+offb
		   			pen q+1 plname "Iam" plnum 5;
      }
    else
      for (q=0;q<NDENDREC;q++) {
	 if (!notinit(am_dend_rec[q]))
	 plot I[am][c][am_dend_rec[q]] max (1-offtr)*plg+offb
		                       min (0-offtr)*plg+offb
		   			pen q+1 plname "Iam" plnum 5;
      };
  };

  plg = 200;		/* gain of trace */
  offtr = .0;		/* position of trace within graph */
  offb  = 0;		/* trace offset base */

/*
  if (make_amgc) plot FA9 amgcsyns[c][8] max (1-offtr)*plg+offb
				         min (0-offtr)*plg+offb
					  pen 6 plname "AmGc"
					  plsize .5 plnum 4; /* */
};

/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

proc disp_gc_vplot()
{
  local cellnr, plg, offtr, offb;

  plg = .1;		/* gain of trace */
  offtr = .3;		/* position of trace within graph */
  offb  = -.05;		/* trace offset base */

  cellnr = 0;
  plot V[gc][cellnr][soma] max (1-offtr)*plg+offb
	 	      min (0-offtr)*plg+offb
			pen 2 plname "Vgc" plnum 3;

  //plot V[gc][cellnr][2] min -0.08 max 0.01 plname "Vdend"; /*dendr syn input */
};

/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

proc disp_gc_caplot()
{
   local cellnr, plg, offtr, offb;

  plg = 2e-6;		/* gain of trace */
  offtr = 0;		/* position of trace within graph */
  offb  = 0;		/* trace offset base */

  cellnr = 0;
  plot Ca(1) [gc][cellnr][soma] max (1-offtr)*plg+offb
	  	           min (0-offtr)*plg+offb
			   pen 4 plname "Cai" plnum 2 plsize .2;
};

/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

proc disp_gc_iplot()
{
   local cellnr,plg, offtr, offb;

  plg   =  300e-12;			/* gain of trace */
  offb  =  0e-12;			/* trace offset base */
  offtr = .8;				/* position of trace within graph */

  cellnr = 0;
  plot I[gc][cellnr][soma] max (1-offtr)*plg+offb
		      min (0-offtr)*plg+offb
		      pen 2 plname "Igc" plnum 1;
};

/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

proc defaultplots(vmin, vmax, maxvesrate, maxCa)
/* Sets the standard plots for most experiments */
{
  if (script==0 && !disp) {	//don't plot if running higher level script or -d
     disp_am_vplot(vmin,vmax);
     if (!notinit(somaclamp)) disp_am_iplot();
     if (addca) disp_am_caplot(maxCa)
     else disp_bpam_rate(maxvesrate);
  };
};

/*-------------------------------------------------------------------*/

PET = 0;	/* Stimulus directions */
FUG = 1;
BOTH = 2;

/* Global variables to hold values found in onplot(). */

BIGNEGVAL = -1e10;
BIGPOSVAL = 1e4;

peakV		= BIGNEGVAL;	// peak V response
peakCa 		= BIGNEGVAL;	// [Ca] peak
peakV_soma 	= BIGNEGVAL;	// peak V response at soma

peakV_sin      	= BIGNEGVAL;	// peak V for sine stimuli, [ diff in onplot() ]
peakV_sin_soma 	= BIGNEGVAL;
peakCa_sin     	= BIGNEGVAL;
dipV_sin       	= BIGPOSVAL;	// lowest V in response to sine stim
dipV_sin_soma  	= BIGPOSVAL;
dipCa_sin      	= BIGPOSVAL;	//lowest [Ca]
peaki_sin      	= BIGNEGVAL;
peaki_sinsoma  	= BIGNEGVAL;
dipi_sin       	= BIGPOSVAL;
dipi_sinsoma   	= BIGPOSVAL;

/* link numbers to varnames for use in func "getextr()": */
VOLT=1;
CALC=2;
CURR=3;
BPAMSYN=4;
PEAK=0;
DIP=1;

dim zerovals[NDENDREC]={{BIGPOSVAL}};		// V value at time=0;

dim    Vpeaks[NDENDREC] = {{BIGNEGVAL}};	// peaks for all rec points
dim     Vdips[NDENDREC] = {{BIGPOSVAL}};	// dips
dim   capeaks[NDENDREC] = {{BIGNEGVAL}};	// peaks in [Ca] for all rec pnts
dim    cadips[NDENDREC] = {{BIGPOSVAL}};
dim    ipeaks[NDENDREC] = {{BIGNEGVAL}};	// peaks and dips in current I
dim     idips[NDENDREC] = {{BIGPOSVAL}};
dim bpampeaks[NDENDREC] = {{BIGNEGVAL}};	//peaks in synaptic input from bp to am

dim peakVtimes[NDENDREC] = {{BIGNEGVAL}};	// time at peak voltage
dim peakbpamtimes[NDENDREC] = {{BIGNEGVAL}};	// time at peak bpam synaptic input

dim peakVtimesCFCP[2][NDENDREC] = {{BIGNEGVAL}};
dim peakbpamtimesCFCP[2][NDENDREC] = {{BIGNEGVAL}};

dim  Vresponses[NDENDREC] = {{BIGNEGVAL}};	// max V response for one stim
dim Caresponses[NDENDREC] = {{BIGNEGVAL}};      // max Ca responses
dim  iresponses[NDENDREC] = {{BIGPOSVAL}};	// max current responses

dim  Vmaxresp[2][NDENDREC] = {{BIGNEGVAL}};	// max V resps for 2 directions
dim camaxresp[2][NDENDREC] = {{BIGNEGVAL}};     // max Ca responses
dim  imaxresp[2][NDENDREC] = {{BIGPOSVAL}};	// max current responses


if (notinit(cadisptime)) cadisptime=0;		//time for [Ca]i display
if (notinit(disptime)) disptime=0.0001;		//time for display stimulus

/*-------------------------------------------------------------------*/

proc getextr(Type,t1,t2,maxormin)
/* find max or min V or [Ca] between two times at a node */
{
   local n,cellnr;
   local dim farval[NDENDREC]={{BIGNEGVAL}};
   local dim farcaval[NDENDREC]={{0}};
   local dim farival[NDENDREC]={{BIGNEGVAL}};
   local dim farbpamval[NDENDREC]={{BIGNEGVAL}};
   cellnr=1;

   if (time<=0)	{	//(re)set all values before an experiment begins
     for (n=0; n<NDENDREC; n++) {
       capeaks[n] = BIGNEGVAL;
       cadips[n] = BIGPOSVAL;
       Vpeaks[n] = BIGNEGVAL;
       Vdips[n]  = BIGPOSVAL;
       ipeaks[n] = BIGNEGVAL;
       idips[n]  = BIGPOSVAL;
       bpampeaks[n] = BIGNEGVAL;
       peakVtimes[n] = BIGNEGVAL;
       peakbpamtimes[n] = BIGNEGVAL;
     };
   };

   if (time>0 && time<=0.0001) {     /* store V at time=0, for every rec node */
     for (n=0; n<NDENDREC; n++) {
       if (am_dend_rec[n]>=0)
 	 zerovals[n]=V[am][cellnr][am_dend_rec[n]];
     };
   };

   if (time>t1 && time<t2) {
     for (n=0; n<NDENDREC; n++)	{ /* get voltage extrema for all recording points */
	if (Type==VOLT)	{	  /* assign which plot farval looks at: */
	   farval[n] = V[am][cellnr][am_dend_rec[n]];

	   if (maxormin==PEAK) {  /*  find either voltage peak or dip: */
	     if (farval[n] > Vpeaks[n]) {
		   Vpeaks[n] = farval[n];
                 peakVtimes[n] = time;
	     };
	   }
	   else if (maxormin==DIP) {
	     if (farval[n] < Vdips[n]) Vdips[n] = farval[n];
	   }
	   else
	     fprintf (stderr,"#4th arg of func getextr must be PEAK or DIP\n");
	}
	else if (Type==CALC) {
	   if (node[am][cellnr][am_dend_rec[n]] -> cacomp) { /* check for ca compart. */
             farcaval[n] = Ca(1) [am][cellnr][am_dend_rec[n]];

	     if (maxormin==PEAK)	   /*  find either [Ca] peak or dip: */
	  	{if (farcaval[n]>capeaks[n]) capeaks[n]=farcaval[n];}
	     else if (maxormin==DIP)
	  	{if (farcaval[n]<cadips[n]) cadips[n]=farcaval[n];}
	     else
	  	fprintf (stderr,"#4th arg of func getextr must be PEAK or DIP\n");
	   };
	}
	else if (Type==CURR) {		/* get extrema for currents */
	    farival[n] = I[am][cellnr][am_dend_rec[n]];
	    //find either voltage peak or dip:
	    if (maxormin==PEAK)
	   	{ if (farival[n] > ipeaks[n]) ipeaks[n] = farival[n];}
	    else if (maxormin==DIP)
	   	{ if (farival[n] < idips[n]) idips[n] = farival[n]; }
	    else
	   	fprintf (stderr,"#4th arg of func getextr must be PEAK or DIP\n");
	};

	if (Type==BPAMSYN) {		/* get extrema for synaptic inputs */
	   if (!notinit(bpamsynsa[cellnr][am_dend_rec[n]])) {

	     farbpamval[n] = FA9 bpamsynsa[cellnr][am_dend_rec[n]];

	     if (maxormin==PEAK){
	       if (farbpamval[n] > bpampeaks[n]) {
		     bpampeaks[n] = farbpamval[n];
                     peakbpamtimes[n] = time;
	       };
	     };
	   }; /* if (!notinit bpamsynsa) */
	}; /* Type BPAMSYN */
      }; /* forloop all recpoints */
   }; /* if within time window */
}; /* proc getextr */

/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

if (notinit(stfreq)) stfreq = -1; /* stim temp freq is global var for onplot() */

proc onplot() {
  local recnod, n, cellnr, t1, t2, peakCaval,resetdur;

  peakCaval = BIGNEGVAL;	//[Ca] peak at certain time (cadisptime);

  if (expt != "sb_Rvalues") {	// for sb_Rvalues don't use onplot()

    if (addca && disp && time >  cadisptime-0.0001 &&
			 time <= cadisptime)
    {
      //recnod=findnode();
      /* get [Ca] at cadisptime */
      peakCaval=5e-7;  //Ca(1)[am][cellnr=1][am_dend_rec[recnod]];
      //disp_ca(peakCaval);	/* show anatomy with [Ca]i colored */
    };

    /* times in in which to look at plot: */
    t1 = .015; 			//start looking a bit after start of simulation
    t2 = endexp;

    /* for sine stims, find min and max responses */
    if (expt=="sb_cc_sine"||expt=="sb_cc_sineann"||expt=="sb_cc_sine_simp") {

      t1 = endexp - 1/stfreq;    //set t1 to look at last cycle only

      getextr(VOLT,t1,t2,PEAK);
      getextr(VOLT,t1,t2,DIP);

      if (expt=="sb_cc_sine_simp")
        getextr(BPAMSYN,t1,t2,PEAK);

      if (!notinit(somaclamp)) {
        getextr(CURR,t1,t2,PEAK);
	getextr(CURR,t1,t2,DIP);
      };

      if (addca) {
        getextr(CALC,t1,t2,PEAK);
        getextr(CALC,t1,t2,DIP);
      };
    }
    else /* for all other stims, find only peak responses */
      getextr(VOLT,t1,t2,PEAK);

    /*find peak Ca level*/
    if (addca)
        getextr(CALC,t1,t2,PEAK);
  };
};

/* =========== Experiment Functions =================================*/

if (notinit(showstim)) showstim = FUG;          /* when to disp stim */

/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

func movebar(starttime,x1,x2,bdia)

/* Move bar from one X position to another across the neural circuit */

/*  Returns the time for the end of the stimulus --  */
/*  Useful for setting the time coordinate on the plot ("endexp"). */

/* Dependent on "velocity", and "sinten" */

/* Note that "t" as defined in this proc is not the simulation time -- */
/*  it is merely a local variable used to set the starting time  */
/*  for the stimulus. */

{
         local x, t, xstep, sstep, bardur;

  xstep = 5;			/* move stimulus in increments of 5 um */

  timestep = xstep / velocity;

  if (x1 < x2)
  {
    for (t=starttime,x=x1; x<=x2; x+= xstep, t+=timestep)
    {
        stim bar bdia loc(x) blur=sblur inten=sinten start=t dur=timestep;

	if (showstim==FUG && disp) {  //default showstim=FUG
          display stim at t dscale 5;
          exit;
	};
	 /* show stim at time of [Ca] display */
	//display stim at cadisptime dscale 5;
    };
  }
  else
  {
    for (t=starttime,x=x1; x >= x2; x-= xstep, t+=timestep)
    {
        stim bar bdia loc(x) blur=sblur inten=sinten start=t dur=timestep;

	/* show stim in PET or FUG according to showstim var */
	if (showstim==PET && disp) {  //default showstim=FUG
          display stim at t dscale 5;
          exit;
	};
    };
  };
  if (disp==1) exit;
  return t;
};

/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

func stepspot(starttime,x1,x2,y,bdia)
/* Make 2 spots separated in time moving from one X position to another across
   the neural circuit */

/*  Returns the time for the end of the stimulus --  */
/*  Useful for setting the time coordinate on the plot ("endexp"). */

/* Dependent on "velocity", and "sinten" */

/* Note that "t" as defined in this proc is not the simulation time -- */
/*  it is merely a local variable used to set the starting time  */
/*  for the stimulus. */
{
  local x, xstep, sstep, start2, start1;

  xstep = abs (x1-x2);
  wait = xstep / velocity;
  spotdur = bdia /velocity;

  start1=starttime;
  stim spot bdia loc(x1,y) blur=sblur inten=sinten start=start1 dur=spotdur;
  start2=starttime+wait;

  stim spot bdia loc(x2,y) blur=sblur inten=sinten start=start2 dur=spotdur;
  if (disp) {  //default showstim=FUG
    display stim at start2 dscale 5;
    exit;
  };

  return starttime+2*spotdur+wait;
};

/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

func moveannulus(starttime,x1,x2,anndia)
/* Move annulus from one radius to another across the neural circuit */

/*  Returns the time for the end of the stimulus --  */
/*  Useful for setting the time coordinate on the plot ("endexp"). */

/* Dependent on "velocity", and "sinten" */

/* Note that "t" as defined in this proc is not the simulation time -- */
/*  it is merely a local variable used to set the starting time  */
/*  for the stimulus. */
{
  local x, t, xstep, sstep;
  local odia, idia, awidth, sx, sy;

  xstep = 5;			/* move stimulus in increments of 5 um */

  sstep = xstep / velocity;

  sx = node[am][cellnr=1][soma] -> xloc;
  sy = node[am][cellnr=1][soma] -> yloc;

  awidth = anndia;		/* annulus width */

  if (x1 < x2) {
    for (t=starttime,x=x1; x<=x2; x+= xstep, t+=sstep) {
     	 odia = x*2;
         idia = odia - awidth*2;
         if (idia < 0) idia = 0;
         stim spot odia loc(sx,sy) blur=sblur inten= sinten start=t dur=sstep;
         stim spot idia loc(sx,sy) blur=sblur inten=-sinten start=t dur=sstep;
    	 if (showstim==FUG && disp) { //default showstim=FUG
            display stim at starttime+0.001 dscale 5;
            exit;
	 };
    };
  }
  else {  
    for (t=starttime,x=x1; x >= x2; x-= xstep, t+=sstep) {
      odia = x*2;
      idia = odia - awidth*2;
      if (idia < 0) idia = 0;

      stim spot odia loc(sx,sy) blur=sblur inten= sinten start=t dur=sstep;
      stim spot idia loc(sx,sy) blur=sblur inten=-sinten start=t dur=sstep;

      if (showstim==PET & disp) {
       	display stim at t dscale 5;
        exit;
      };
    };
  };
  return t;
};

/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

proc movesineann (direction,ann_gaussenv,centdia,phase,speriod,
		  stfreq,sinten,scontr,starttime,sdur)

/* Presents annulus with a moving sine wave grating */
/*  Returns the time for the end of the stimulus --  */

{
  local cellnr, xsoma, ysoma;

  xsoma = node[am][cellnr=1][soma] -> xloc;	//make cell soma center of annulus
  ysoma = node[am][cellnr=1][soma] -> yloc;

  if (direction==FUG) sdrift=1
  else if (direction==PET) sdrift = -1
  else if (direction==0) sdrift = 0
  else {
    fprintf(stderr,"# Func movesineann error: direction not valid.\n");
    fprintf(stderr,"# Please enter direction of 0 or 1.\n");
     exit;
  };


  if (!notinit(somaclamp)) {	//user can specify V to clamp soma
    stim node[am][cellnr=1][soma] vclamp somaclamp
		 		start=starttime dur=sdur;
  };

  /* Make a central gray area with diameter "centdia" */
  if (centdia>0)
    stim spot centdia loc (xsoma,ysoma) inten=sinten mask=1
				   start=starttime dur=sdur;

  /* sineann stimulus with x envelope determined by ann_gaussenv */

  stim sineann speriod loc (xsoma,ysoma)	//outer ring
		xenv=ann_gaussenv sphase=phase tfreq=stfreq
		inten=sinten blur=sblur
		drift=sdrift contrast=scontr
		start=starttime dur=sdur;  /* */
};

/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

proc getresponses(fugorpet)
{
  local n,cellnr,recnod;

  for (n=0;n<NDENDREC;n++) {
    recnod=am_dend_rec[n];
    if (recnod>=0) {
      if (expt=="sb_cc_sine" || expt=="sb_cc_sineann"||expt=="sb_cc_sine_simp") {
	  if (notinit(somaclamp))
	    Vresponses[n] = Vpeaks[n] - Vdips[n]
          else
	    iresponses[n] = ipeaks[n] - idips[n];
      }
      else
	Vresponses[n] = Vpeaks[n]-zerovals[n];

      if (addca && (node[am][cellnr=1][recnod]->cacomp)) {
        if (expt=="sb_cc_sine" || expt=="sb_cc_sineann"|| expt=="sb_cc_sine_simp")
	   Caresponses[n] = capeaks[n]-cadips[n]
        else
            Caresponses[n] = capeaks[n] - dtcai;
      }
      else
        Caresponses[n] = -1;

      Vmaxresp[fugorpet][n] = Vresponses[n];
      peakVtimesCFCP[fugorpet][n] = peakVtimes[n];
      peakbpamtimesCFCP[fugorpet][n] = peakbpamtimes[n];
      camaxresp[fugorpet][n] = Caresponses[n];
      imaxresp[fugorpet][n] = iresponses[n];
    };
  };
};

/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

proc reset(voltage,resetdur)

/* clamp all nodes to given voltage for certain time resetdur */

{
	local cellnr,n;

	for (n=NDENDREC-1;n>=0;n--) {
	  if (am_dend_rec[n]!=-1)
	    stim node [am][cellnr=1][am_dend_rec[n]] vclamp voltage
				start=time dur=resetdur;
	};
};

/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

proc savecones()

/* save all cone voltages for later */

{
  if (make_photorec){
    for(i=0;i<conecount;i++) {
      modify conenames[i] cone () save;
    };
  };
};

/*  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  */

proc restorcones()

/* restore all cone voltages */

{
  if (make_photorec)
    for(i=0;i<conecount;i++) {
     modify conenames[i] cone () restore;
    };
};

/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

include libdir+"printDS.n"; /* Procedure for printing DS values to the screen */

/*========================== EXPERIMENTS ============================*/

if (expt == "am_surf_area") {	/* calculate surface area */
 totsa 	= 0;
 foreach cable ?d node [am][-1][-1] {
		totsa += PI*element d->dia*element d->length;};
 printf ("# Surface area of dendrites   = %g um2\n",totsa);
 foreach sphere ?d node [am][-1][-1] {local r;  r = element d->dia/2;
 		totsa += 4*PI*r*r; };
 printf ("# Surface area including soma = %g um2\n",totsa);
 printf ("# Rin estimated from surface area = %-8.3g\n",amrm/totsa*1e8);
}
else if (expt == "sb_cc_tofro") {	// record voltage from sb soma, dend

	local starttime, stimdur;
	local amcellnr;

	//stim file "ds_tofro.t";

	// find sbac dend locs to record from, store in global array am_dend_rec
	am_ifden_rec(amcellnr=1, rec_am_angle,NORANGE);

	resetdur=.05;			// time for V to reach desired level

	if (!make_photorec){
	   defaultplots(Vmin=-0.06, Vmax=-0.04, vesratemax=400, caconcmax=5e-7);
           if(notinit(sinten)) sinten = 0.01;
           bg_inten = v_bp_dark;
	   predur = 0;
	   predur2=resetdur;		// V must be reset, take time (= resetdur)
	}
	else {
 	   if(notinit(Vmin)) Vmin=-0.060;
	   if (notinit(Vmax)) Vmax=-0.035;
	   if (notinit(vesratemax))vesratemax=50;
	   if (notinit(caconcmax)) caconcmax=1e-6;
	//plot G(0)conenames[254] min 0 max 1.5 plname "Gcone" plnum 2;
	//disp_bpam_rate(50);
	//plot V[con][254] plname "Vcon" min -0.06 max -0.02 plnum 5;
	//plot V[bp][254] plname "Vbp" plnum 5;
	//plot V[am][1][46] plname "Vam" min -.06 max -.02 plnum 1;
	//plot L[con][254] min 0 max 200000 plname "photons/s" plnum 2;
	   defaultplots(Vmin, Vmax, vesratemax, caconcmax);
	};

	if (notinit(stimdia)) stimdia = 30;
        if (notinit(velocity)) velocity = 1000;
	if (notinit(sinten)) sinten = 10000;
	if (notinit(predur)) predur=.35;
	if (notinit(predur2)) predur2 = .2;
	if (notinit(endwait)) endwait = .1;

	if (stimhalf==1) xnear=soma
	else xnear = xmin - 40;
	xfar  = xmax + 40;

	setxmin=0;

	time=0-predur;
	stim backgr bg_inten start 0-predur;

	/* Centrifugal motion over recording points */
	stimdur = movebar(starttime=0, xnear, xfar, stimdia);
	endexp=stimdur+endwait;
	step predur;
	savecones();			/* save photorec biophys values */
	step stimdur+endwait;
	getresponses(FUG);		//compute max responses for all recpoints

	/* restore photorec biophys values or starting V */
	time=0-predur2;
	if (make_photorec)
	   restorcones()
	else
	   reset(amvstart,resetdur);
	step predur2;

	/* Centripetal motion over recording points */
	stimdur = movebar (starttime=0, xfar, xnear, stimdia);
 	endexp=stimdur+endwait;
	step stimdur+endwait;
	getresponses(PET);		//compute max responses for all recpoints
	printDS();
}
else if (expt == "sb_cc_stepspot") {	/* record voltage from sb soma, dend */

	local stimdia,starttime,durtotal,stimdur;
	local amcellnr;

	//stim file "ds_stepspot.t";

	/* rec_am_angle is global, default 0 */
	am_ifden_rec(amcellnr=1, rec_am_angle,NORANGE);

	resetdur=.05;			// time for V to reach desired level

	if (!make_photorec){
	   defaultplots(Vmin=-0.06, Vmax=-0.04, vesratemax=400, caconcmax=5e-6);
           if(notinit(sinten)) sinten=0.01;
           bg_inten=v_bp_dark;
	   predur = 0;
	   predur2=resetdur;		// V must be reset, take time (= resetdur)
	}
	else {
	  if(notinit(Vmin)) Vmin=-0.044;
	  if (notinit(Vmax)) Vmax=-0.038;
	  if (notinit(vesratemax))vesratemax=150;
	  if (notinit(caconcmax)) caconcmax=5e-6;
	  defaultplots(Vmin, Vmax, vesratemax, caconcmax);
	};

	if (notinit(stimdia)) stimdia = 30;
	if (notinit(velocity)) velocity = 1000;
	if (notinit(sinten)) sinten = 10000;
	if (notinit(stiminterval)) stiminterval = 0;	//space between spots
	if (notinit(stimloc)) stimloc = xmax-stiminterval-1.6*stimdia; //make spots fit on den
	if (notinit(stim_y)) stim_y = node[am][cellnr=1][soma] -> yloc;
        if (notinit(predur)) predur=.3;
        if (notinit(predur2)) predur2 = .2;
	if (notinit(endwait)) endwait=.1;

	setxmin=0;

	time=0-predur;
	stim backgr bg_inten start 0-predur;

	/* Centrifugal motion over recording points */
	stimdur = stepspot (starttime=0,stimloc,stimloc+stiminterval+stimdia,stim_y,stimdia);
	endexp=stimdur+endwait;
	step predur;
	savecones();			/* save photorec biophys values */
	step stimdur+endwait;
	getresponses(FUG);		//compute max responses for all recpoints

	/* restore photorec biophys values or starting V */
	time=0-predur2;
	if (make_photorec)
	   restorcones()
	else
	   reset(amvstart,resetdur);
	step predur2;

	/* Centripetal motion of spots */
	stimdur =stepspot (starttime=0,stimloc+stiminterval+stimdia,
					stimloc,stim_y,stimdia);
	step stimdur+endwait;
	getresponses(PET);		//compute max responses for all recpoints

	//compute and print out DS index (also for Ca if chans present)
	printDS();
}
else if (expt == "sb_cc_annulus") {	/* record voltage from sb soma, dend */

	local stimdia, starttime, stimdur, durtotal;
	local amcellnr;
 	//stim file "ds_exshr.t";

	/* find sbac dend locs to record from*/
	am_ifden_rec(amcellnr=1, rec_am_angle,NORANGE);

	resetdur=.05;			// time for V to reach desired level

	if (!make_photorec){
	   defaultplots(Vmin=-0.06, Vmax=-0.04, vesratemax=400, caconcmax=5e-6);
           if(notinit(sinten)) sinten=0.01;
           bg_inten=v_bp_dark;
	   predur = 0;
	   predur2=resetdur;		// V must be reset, take time (= resetdur)
	}
	else {
	  if(notinit(Vmin)) Vmin=-0.06;
	  if (notinit(Vmax)) Vmax=-0.035;
	  if (notinit(vesratemax))vesratemax=100;
	  if (notinit(caconcmax)) caconcmax=5e-6;
	  defaultplots(Vmin, Vmax, vesratemax, caconcmax);
	};

	if (notinit(stimdia)) stimdia = 30;
	if (notinit(velocity)) velocity = 1000;
	if (notinit(sinten)) sinten = 10000;
	if (notinit(predur)) predur=.3;
	if (notinit(predur2)) predur2 = .2;
	if (notinit(endwait)) endwait = .1;

	xnear = sb_maxden * .20;
	xfar  = sb_maxden * 1.2;

	setxmin=0-predur;

	time=0-predur;
	stim backgr bg_inten start 0-predur;

	// Expand annulus
	stimdur = moveannulus (starttime=0, xnear, xfar, stimdia);

	endexp=stimdur+endwait;
	step predur;
	savecones();			/* save photorec biophys values */
	step stimdur+endwait;
	getresponses(FUG);		//compute max responses for all recpoints

	/* restore photorec biophys values or starting V */
	time=0-predur2;
	if (make_photorec)
	   restorcones()
	else
	   reset(amvstart,resetdur);
	step predur2;

	/* Centripetal motion over recording points */
	stimdur = moveannulus (starttime=0, xfar, xnear,stimdia);
	step stimdur+endwait;
	getresponses(PET);		//compute max responses for all recpoints

	//compute and print out DS index (also for Ca if chans present)
	printDS();
}
else if (expt == "sb_cc_sineann")
{
	local stimname, starttime, durtotal;
	local amcellnr;

	//sprintf(stimname,"stim_sineannCyc%gv%g_%s.t", cycperrad, velocity,amacfile);
	//stim file stimname;

	/* find sbac dend locs to record from*/
	am_ifden_rec(amcellnr=1, rec_am_angle,NORANGE);

        if (!make_photorec) {
	   defaultplots(Vmin=-0.055, Vmax=-0.045, vesratemax=20, caconcmax=1e-6);
           if(notinit(sinten)) sinten=0.002;
           if(notinit(predur)) predur=.3;
	   if (notinit(velocity)) velocity = 1000;
	}
	else {
	   if (notinit(Vmin)) Vmin=-0.04;
	   if (notinit(Vmax)) Vmax=-0.03;
	   if (notinit(vesratemax))vesratemax=50;
	   if (notinit(caconcmax)) caconcmax=1e-6;
	   defaultplots(Vmin, Vmax, vesratemax, caconcmax);
	};

	/* Stimulus parameters */
	/* default params as used by Euler et al (2002) */
	if (notinit(sinten)) sinten = 10000;		// not from Euler...
	if (notinit(scontr)) scontr = 0.8;
	if (notinit(cycperrad)) cycperrad=1.5;		// nr of cycles per radius
	if (notinit (speriod)) speriod = sb_maxden/cycperrad;
	if (stfreq==-1) {				// =-1 -> not set by user
	  if (notinit(velocity)) velocity = (stfreq=4)*speriod
	  else stfreq = velocity/speriod;		// set freq according to velocity
	};
	if (notinit(masksize)) centdia = 0  		// no center mask
	  else centdia = 2*(sb_maxden * masksize);     	// mask=frac of dend rad (eg .3)
	//make size of annulus (=Gauss. env.) large -> same light intensities over cell
	if (notinit(ann_gaussenv)) ann_gaussenv = sb_maxden * 4;
	if (notinit(stimdur)) stimdur = (ncycles=4)/stfreq; 	// run for n cycles
	if (notinit(predur)) predur = .6;   		// equilibration time
	if (notinit(endwait)) endwait = .2;

	setxmin = 0-predur;
	endexp = stimdur;

	if (!make_photorec) {
	  stim backgr v_bp_dark start starttime; //turn background on at starttime
	};

	if(notinit(petonly)) petonly=0;
	if(notinit(fugonly)) fugonly=0;
	if (fugonly!=0 && petonly!=0)
	  fprintf(stdout,"#You cannot choose both petonly and fugonly! Doing centrifugal stim only");

	if(petonly==0) {
 	 /* expand annulus (centrifugal motion) ------------------------------- */
	 time = 0 - predur;  //start time before showing plot (set time negative)
	 starttime = 0 - predur;	 //start stimulus before 0 to get DC level up
 	 durtotal = predur+stimdur;
	 movesineann(FUG,ann_gaussenv,centdia,phase=0,speriod,stfreq,
				sinten,scontr,starttime,durtotal);
 	 if (showstim==FUG && disp)  {  	//default showstim=FUG
	  display stim at disptime dscale 5;
	  //exit;
	 };

	 step predur;
         savecones();			/* save photorec biophys values */
	 step stimdur+.0001;		/* step one extra timestep */
	 getresponses(FUG);		//compute max responses for all recpoints
	 if(fugonly) exit;		//if asked to only do centrifugal stim, exit now
	};

 	/* Contract annulus (centripetal motion) ----------------------------- */
	if (petonly)	//if only running one direction, use predur
	  predur2=predur
	else		//otherwise use a shorter time
	  predur2 = 0.4;
 	time = 0 - predur2;
	starttime = 0-predur2;
	durtotal = predur2+stimdur;

	if (petonly==0)
		restorcones();   /* restore photorec biophys values */
	movesineann(PET,ann_gaussenv,centdia,phase=0,speriod,stfreq,
				sinten,scontr,starttime,durtotal);
  	if (showstim==PET && disp) { 	//default showstim=FUG
  	   display stim at disptime dscale 5;
  	   exit;
	};
	step durtotal+.0001;		/* step one extra timestep */
	getresponses(PET);		//compute max responses for all recpoints
	if(petonly) exit;		//if asked to only do centripetal stim, exit now

	//COMPUTE AND PRINT OUT DS INDEX (if ca-channels also print out DSCa index)
	printDS();
}
else if (expt == "sb_cc_sine"){		//sine wave stimulus

	local stimname,ncycles,svert,shor,durtotal,starttime;
	local amcellnr;
	local stimx,stimy,n,xpos,xdist,signalvel, traveltime;

	//sprintf(stimname,"stim_sineCyc%gv%g_%s.t", cycperrad, velocity,amacfile);
	//stim file stimname;

	/* find sbac dend locs to record from*/

	am_ifden_rec(amcellnr=1, rec_am_angle,NORANGE);

	/* set up plot and intensity according to whether photorec are present */

	if (!make_photorec) {
           defaultplots(Vmin=-0.06, Vmax=-0.05, vesratemax=400, caconcmax=5e-6);
           if(notinit(sinten)) sinten=0.002;
	}
	else {
	   if (addca){
	     fprintf(stdout,"Choosing both Ca-chans and photorecs not yet possible.");
	     exit;
	   };
	   if(notinit(Vmin)) Vmin=-0.05;
	   if (notinit(Vmax)) Vmax=-0.04;
	   if (notinit(vesratemax))vesratemax=100;
	   if (notinit(caconcmax)) caconcmax=5e-6;
	   defaultplots(Vmin, Vmax, vesratemax, caconcmax);
	};

	//stimulus parameters
	if (notinit(velocity)) velocity = 1000;
	if (notinit(sinten)) sinten = 10000;
	if (notinit(scontr)) scontr = 0.8;
	if (notinit(cycperrad)) cycperrad=1.5;		//nr of cycles per radius
	if (notinit(speriod)) speriod = sb_maxden/cycperrad;  // cyc per rad
	if (notinit(angle)) angle = 0; 	//angle (deg) of motion with respect to x-axis

	if (stfreq==-1) stfreq = velocity/speriod; // temp freq==-1 if notinit

	if (currvel==1)	{	//if you want to measure current velocity
	  shor = 12;	//use very small stim at soma (maybe even smaller, 4?)
	  svert = 12;
	  if (notinit(predur)) predur = .55;
	}
	else {
	  svert = ysize+sblur;	//vertical extent of stim from center
	  shor =  xsize+sblur;	//hor. extent of stim from center
	  if (notinit(predur)) predur = .5;	// equilibration time
	};

	/* run for at least 'ncycles' */
	if (notinit(stimdur)) stimdur = (ncycles=4)/stfreq;

	time = 0 - predur;	//start stim before showing plot (set time neg)
	setxmin = 0;		//start plotting from time=0;
	starttime = 0 - predur;
	endexp = stimdur;

	/* turn background on at starttime */
	if (!make_photorec) stim backgr v_bp_dark start starttime;

        if(notinit(tipstim))	//tipstim can be used to center stim on dend tip
	   {stimx = node[am][c=1][soma]-> xloc;	//default, center stim on soma
	    stimy = node[am][c=1][soma]-> yloc;}
	else
           {stimx = node[am][c=1][am_dend_rec[3]]-> xloc;
	    stimy = node[am][c=1][am_dend_rec[3]]-> yloc;
	   };

	//user can choose to show only one direction:
	if(notinit(petonly)) petonly=0;
	if(notinit(fugonly)) fugonly=0;
	if (fugonly!=0 && petonly!=0)
	  fprintf(stdout,"#You cannot choose both petonly and fugonly! Doing centrifugal stim only");

	/* CENTRIFUGAL MOTION */
        if (petonly==0) {	//do this if not asked to only do centripetal stim
	 durtotal = predur + stimdur;
	 stim sine speriod loc (stimx,stimy) blur=sblur inten=sinten start=starttime
		dur=durtotal tfreq=stfreq contrast=scontr orient=angle drift=1
		xenv=shor yenv=svert;
	 if (disp) {display stim at disptime dscale 5; exit;};

	 step predur;
         savecones();			/* save photorec biophys values */

	 step stimdur+.0001;		/* step one extra timestep */

	 getresponses(FUG);		//compute max responses for all recpoints
	 if (fugonly) exit;		//if asked to only do centrifugal stim, exit now

	 if (currvel==1){
	  //To calculate phase shift and ampl-attenuation, print out peak V and time
	  if (notinit(tipstim)){
	    for (n=1;n<NDENDREC;n++){
              xpos = node[am][c=1][am_dend_rec[n]]-> xloc;
	      xdist = xpos - node[am][c=1][am_dend_rec[0]]-> xloc;
	      traveltime = peakVtimes[n]-peakVtimes[0];
	      signalvel = xpos/traveltime;
	      fprintf (stdout,"# Recpoint %g: Xdist = %g um; Time = %g s; V = %g V; v = %g um/s\n",
	                    n, xdist, traveltime, Vpeaks[n], signalvel);
            };
	   }
	   else {
	    for (n=0;n<NDENDREC-1;n++){
              xpos = node[am][c=1][am_dend_rec[n]]-> xloc;
	      xdist = node[am][c=1][am_dend_rec[3]]-> xloc - xpos;
	      traveltime = peakVtimes[n]-peakVtimes[3];
	      signalvel = xdist/traveltime;
	      fprintf (stdout,"# Recpoint %g: Xdist = %g um; Time = %g s; V = %g V; v = %g um/s\n",
	                    n, xdist, traveltime, Vpeaks[n], signalvel);
            };
	   };
	   //print node[am][c=1][am_dend_rec[3]]-> yloc;
	   exit;	// run only one direction
	 };
	};	//if petonly==0

	/* CENTRIPETAL MOTION */
	time=0-predur;
	if (petonly==0)
	  restorcones();		/* restore photorec biophys values */
	durtotal = predur + stimdur;

	stim sine speriod loc (stimx,stimy) blur=sblur inten=sinten start=time
		dur=durtotal tfreq=stfreq contrast=scontr orient=angle drift=-1
		xenv=shor yenv=svert;

	step durtotal+.0001;		/* step one extra timestep */
	getresponses(PET);		//compute max responses for all recpoints
	if(petonly) exit;		//if asked to only do centripetal stim, exit now

	//COMPUTE AND PRINT OUT DS INDEX (+ DSCa index if Ca channels present)
	printDS();
}
else if (expt == "sb_cc_sine_simp")
{
	local amcellnr, ncycles, svert, shor, durtotal, starttime, driftdir;
	local shor_som, svert_som, shor_tip, svert_tip;
	local stimx_som, stimy_som, stimx_tip, stimy_tip;
	local phaserel, ttime, soma_a1, soma_a2, tip_a1, tip_a2, soma_diffampl, tip_diffampl;

	//stim file "ds_sinewave.t";

	/* find sbac dend locs to record from*/
	am_ifden_rec(amcellnr=1, rec_am_angle,NORANGE);

	/* set up plot and intensity according to whether photorec are present */
	if (!make_photorec) {
	  defaultplots(Vmin=-0.06, Vmax=-0.05, vesratemax=400, caconcmax=5e-6);
          if(notinit(sinten)) sinten=0.002;
	}
	else {
	  if (addca) {
	    fprintf(stdout,"Choosing both Ca-chans and photorecs not yet possible.");
	    exit;
	  };
	  if(notinit(Vmin)) Vmin=-0.0425;
	  if (notinit(Vmax)) Vmax=-0.0422;
	  if (notinit(vesratemax))vesratemax=30;
	  if (notinit(caconcmax)) caconcmax=5e-6;
	  defaultplots(Vmin, Vmax, vesratemax, caconcmax);
	};

	/* STIMULUS PARAMETERS */
	if (notinit(velocity)) velocity = 1000;
	if (notinit(sinten)) sinten = 10000;
	if (notinit(scontr)) scontr = 0.8;
	if (notinit(cycperrad)) cycperrad = 1.5;	      //nr of cycles per radius
	if (notinit(speriod)) speriod = sb_maxden/cycperrad;  //spatial period depends on cycperrad
	if (stfreq==-1) stfreq = velocity/speriod;	      // temp freq==-1 if notinit

	//default stims at soma and tip have same freq
	if (notinit(stfreq_som)) stfreq_som = stfreq;
	if (notinit(stfreq_tip)) stfreq_tip = stfreq;

	/* Number of stimuli; default 1 sine grating centered on soma */
	if (notinit(simp)) simp=0;	//if user specifies simp=1,2, use nonmoving sines

	if((notinit(somstim) && notinit(tipstim)) || simp==2) {
	  //default: 1 stimulus, on soma; simp=2 means soma first, then tip
	  somstim=1;
	  tipstim=0;
	}
	else if(!notinit(somstim) && !notinit(tipstim)) {
	  somstim=1;	   //if both initialized by user, make both 1
	  tipstim=1;
	}
	else if(!notinit(somstim))  //if user specifies 1 stimulus, make only 1
	  tipstim=0
	else if(!notinit(tipstim))
	  somstim=0;

	/* Size of stimuli; default large enough to cover entire cell*/
	if (simp==1 || simp==2) {
	  if (notinit(stimdia)) stimdia = 10;	//small stimuli
	}
	else {
	  if (notinit(stimdia)) stimdia = xmax+20;  //default situation
	};

	if(notinit(shor_som)) shor_som = stimdia;
	if(notinit(svert_som)) svert_som = stimdia;
 	if(notinit(shor_tip)) shor_tip = stimdia;
	if(notinit(svert_tip)) svert_tip = stimdia;

	/* Location of stimuli; on soma or on dend tip */
	stimx_som = node[am][c=1][soma]-> xloc;
	stimy_som = node[am][c=1][soma]-> yloc;
	stimx_tip = node[am][c=1][am_dend_rec[3]]-> xloc;
	stimy_tip = node[am][c=1][am_dend_rec[3]]-> yloc;

	/* SIMULATIONS */
	/* run for at least 'ncycles' */
	if (notinit(stimdur)) stimdur = (ncycles=4)/stfreq;
	if (notinit(predur)) predur = .55;	// equilibration time

	time = 0 - predur;	//start stim before showing plot (set time neg)
	setxmin = 0-predur;		//start plotting from time=0;
	starttime = 0 - predur;
	if (notinit(tstart_som)) tstart_som = starttime;
	if (notinit(tstart_tip)) tstart_tip = starttime;

	/* turn background on at starttime */
	if (!make_photorec) stim backgr v_bp_dark start starttime;

	/* CENTRIFUGAL MOTION */
	durtotal = predur + stimdur;
	if (simp==1 || simp==2)
	   driftdir = 0		//no drift
	else
	   driftdir = 1;	//centrifugal drift
	//2 stimuli, one at soma, one at den tip
	if (somstim) {
	  stim sine speriod loc (stimx_som,stimy_som) blur=sblur inten=sinten start=tstart_som
	  dur=durtotal tfreq=stfreq_som drift=driftdir contrast=scontr sphase=0
	  xenv=shor_som yenv=svert_som;
	};
	if (tipstim) {
	  stim sine speriod loc (stimx_tip,stimy_tip) blur=sblur inten=sinten start=tstart_tip
	  dur=durtotal tfreq=stfreq_tip drift=driftdir contrast=scontr sphase=0
    	  xenv=shor_tip yenv=svert_tip;
	};
	if (disp) {display stim at .2+.001 dscale 5; exit;};
	endexp = stimdur;

	step predur;
        //savecones();			// save photorec biophys values
	step stimdur+.0001;		// step one extra timestep
	getresponses(FUG);		//compute max responses for all recpoints

	/* calculate and print out delays and phase */
	if (simp==1 || simp==2) {
 	  if (somstim)
	    printdelays(soma,FUG);
	  if (tipstim)
	    printdelays(NDENDREC-1,FUG);
	};

	/* run another stim if user specifies simp=2 */
	if (simp==2) {	//after somstim now do tipstim:
	  time = 0 - predur;	//reset time

	  stim sine speriod loc (stimx_tip,stimy_tip) blur=sblur inten=sinten start=tstart_tip
	  dur=durtotal tfreq=stfreq_tip drift=driftdir contrast=scontr sphase=0
    	  xenv=shor_tip yenv=svert_tip;

	  endexp = stimdur;
	  step predur;
	  step stimdur+.0001;		// step one extra timestep
	  getresponses(FUG);		//compute max responses for all recpoints

	  printdelays(NDENDREC-1, FUG);

	  //print "";
	  //fprintf(stdout,"Vtip_somstim : Vtip_tipstim = %g : %g = %g\n",
	  //Vtipvals[0], Vtipvals[1], Vtipvals[0]/Vtipvals[1]);
	  //fprintf(stdout,"Vsom_tipstim : Vsom_somstim = %g : %g = %g\n",
	  //Vsomvals[1], Vsomvals[0], Vsomvals[1]/Vsomvals[0]);
	  //print "";

	  //soma_sumampl = sinewaves(phase_somvals[0],phase_somvals[1],Vsomvals[0],Vsomvals[1]);
   	  //tip_sumampl = sinewaves(phase_tipvals[0],phase_tipvals[1],Vtipvals[0],Vtipvals[1]);
	  //print "The ampl at the dend tip sums to ", tip_sumampl;
	  //print "The ampl at the soma sums to ", soma_sumampl;

	  /* Add a phase shift to mimic motion */
	  if (notinit(addphaseshift)) {
	     ttime = sb_maxden/velocity;	//traveltime of stim from soma to tip
	     addphaseshift = comp_phase(stfreq,ttime);
             print "# V",velocity,";dend-rad",sb_maxden,";tip->soma time",ttime,
	     ";tempfreq",stfreq,";phaseshift added:",addphaseshift;
          };
	  //check the effect of phaseshift on the ampl of signal at the soma
	  //soma_a1=sinewaves(phase_somvals[0]+addphaseshift,phase_somvals[1],Vsomvals[0],Vsomvals[1]);
	  //soma_a2=sinewaves(phase_somvals[0],phase_somvals[1]+addphaseshift,Vsomvals[0],Vsomvals[1]);
	  //soma_diffampl = (soma_a2-soma_a1)/(soma_a1+soma_a2);

	  //NOTE: for arrays, [0] means somastim, [1] means tipstim
	  //check the effect of phaseshift on the ampl of signal at dend tip
	  tip_a1=sinewaves(phase_tipvals[0]+addphaseshift,phase_tipvals[1],Vtipvals[0],Vtipvals[1]);
	  tip_a2=sinewaves(phase_tipvals[0],phase_tipvals[1]+addphaseshift,Vtipvals[0],Vtipvals[1]);
	  tip_diffampl = (tip_a2-tip_a1)/(tip_a1+tip_a2);
	  phase_rel = phase_tipvals[0]-phase_tipvals[1];  //relative phase of 2 signals

	  fprintf(stdout, "##Results measured at dend tip (phi=phase in deg):\n");
	  fprintf(stdout, "#v(um/s) cpr phi_tipstim Vtipstim phi_somstim Vsomstim delta_phi phi_v phi_tot DS \n");
	  fprintf(stdout, "%-9.4g%-4.3g%-12.3g%-9.2g%-12.3g%-9.2g%-10.3g%-6.3g%-8.3g%-8.3g \n",
	  	  velocity,cycperrad,phase_tipvals[1], Vtipvals[1], phase_tipvals[0], Vtipvals[0],
		  phase_rel,addphaseshift,addphaseshift+phase_rel,tip_diffampl);
	  fprintf (stdout,"#");

	  //fprintf(stdout, "# With an added phase shift of %g (v=%g um/s) the \"DS\" is: \n",
	  //        addphaseshift, velocity);
          //fprintf(stdout, "%g at the soma (soma_a1=%g ; soma_a2=%g)\n",
	  //        soma_diffampl, soma_a1, soma_a2);
          //fprintf(stdout, "%g at the tip (tip_a1=%g ; tip_a2=%g)\n",
	  //        tip_diffampl, tip_a1, tip_a2);

	exit;
	};

	/* CENTRIPETAL MOTION */
	driftdir=-1;
	time=0-predur;
        //restorcones();			/* restore photorec biophys values */
	durtotal = predur + stimdur;

	//present 2 stimuli, one at soma, one at den tip
	if (somstim) {
	  stim sine speriod loc (stimx_som,stimy_som) blur=sblur inten=sinten start=time
	  dur=durtotal tfreq=stfreq drift=driftdir contrast=scontr
	  xenv=shor_som yenv=svert_som;
	};
	if (tipstim) {
	  stim sine speriod loc (stimx_tip,stimy_tip) blur=sblur inten=sinten start=time
	  dur=durtotal tfreq=stfreq drift=driftdir contrast=scontr
	  xenv=shor_tip yenv=svert_tip;
	};
	step durtotal+.0001;		/* step one extra timestep */
	getresponses(PET);		//compute max responses for all recpoints

	/* calculate and print out delays and phase */
        printdelays(NDENDREC-1, PET);

	//COMPUTE AND PRINT OUT DS INDEX (if ca-channels also print out DSCa index)
	if (simp==0) printDS();

}
else if (expt == "sb_Rvalues")
{
	showR();
};
