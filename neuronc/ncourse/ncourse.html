<html>
<title>NeuronC Beginner's Course</title>
<body bgcolor="#e0b289">

<h2><a name ="D">NeuronC Beginner's Course</a></h2>

<h2>Exercises</h2>


<h3><a href="#1">Section 1) How to run simulations</a></h3>
<ul>

<li><a href="#2">Logging in, using the editor</a>
	
<li><a href="#3">Compiling nc</a>

<li><a href="#4">Using the editor</a>

<li><a href="#5">Running simulations</a>

<li><a href="#6">Nodes, neural elements</a>

<li><a href="#7">Predefined variables, Units</a>

<li><a href="#8">Constructing neural circuits</a>
</ul>


<h3><a href="#10">Section 2) Lessons</a></h3>
<ul>

<li><a href="#11">Lesson 1) Synapse onto cable</a>

<li><a href="#12">Lesson 2) Electrotonic decay in cable</a>

<li><a href="#13">Lesson 3) Cable with spines</a>

<li><a href="#14">Lesson 4) Horizontal cell spines</a>

<li><a href="#15">Lesson 5) Photoreceptor network</a>

<li><a href="#16">Lesson 6) Amacrine varicosities</a>
</ul>


<h3><a href="#20">Section 3)</a></h3>

<ul>
<li><a href="#21">Design Philosophy</a>
</ul>

<br>
<br>

</br>
<hr>


<h3><a name="1">Section 1)</a></h3>

This beginner's manual is for the short course located
in the Neuron-C distribution under "nc/ncourse".

<h3><a name="2">Logging in</a></h3>

Turn on the computer, wait for the "login:" prompt, 
and login with your assigned login 
name.  Once you have logged in, the computer prints a 
"%" at the beginning of every command line as a prompt 
to you that it has finished your previous command and 
is waiting for the next.  Some simple (UNIX) commands 
are:

<pre>
   %
   % ls <RET>                  ( directory listing )
   % cp file1 file2 <RET>      ( copy file1 to make file2 ) 
   % logout <RET>              ( logs you off the computer )
</pre>

     The "<RET>" after these commands means that you 
enter the command into the computer by pressing the 
"return" or "enter" key.

<h3><a name="3">Compiling nc</a></h3>

To compile "nc", run the "tar" command to retrieve
the source code files:

<pre>
    tar xvzf nc.tgz
</pre>

This creates the folder "nc" and several subfolders.
Go into the nc folder and run "make":

<pre>
    cd nc
    make
</pre>
This makes the simulator and several other useful programs.
You must place them into a folder, such as ~/bin, your personal
binary folder, or other bin folders that you have in your
shell's path:

<pre>
     cd bin
     cp nc stim plotmod vid ~/bin
 or e.g:
     su root
     cp nc stim plotmod vid neurc /usr/bin
</pre>
Or else add the "nc/bin" folder to your path:

<pre>
    vi ~/.cshrc
    add "~/nc/bin" to the path
</pre>

Note that there are some useful programs in "nc/bin":

<pre>
  bins.c      makes histogram
  column      cuts 1 column from an output file.r 
  ncd         runs nc to display morphology ("nc -d 1")
  ndv         runs nc to display morphology ("nc -d 1")
  ncv         runs nc with vid
  ncplot      displays file.r on vid ("plotmod $argv | xvid")
  replace     replaces string in files ("replace str1 str2 files")
  xvid        makes a larger window than vid
  etc.
</pre>

<h3><a name="4">Using the editor</a></h3>

There are many editors (vi, emacs, joe) 
you can use to make a NeuronC program file.  If you don't know how 
to use any of these editors, ask for help.  Run the 
editor by typing its name (e.g. "joe") 
and a file name (the "%" is the computer's prompt):

<pre>
For example, from the command-line prompt:

   % joe circuit1
</pre>

Or, you can rely on a GUI editor like
"soffice", "openoffice", or "kate".
Run the editor by clicking on its icon,
then click on "File" and then "New" to make
a new file.
<p>

<h3>How to use editors</h3>

<h4>Vi</h4>

<p>
There are two modes, visual mode and command mode.
In visual mode (where you initally get to) typing "i"
gets you into insert mode.  Any keys you
type at this point will go into the file.  To get out
of insert mode, hit the <ESC> key; this gets you back
into visual mode.  You can use the arrow keys on the
keypad to move around.  A colon ":" gets you into
command mode.

<pre>
   arrow keys      move around
   :wq             save and exit.
   i               insert text
   a               insert after char
   &lt;Esc&gt;     stop inserting text
</pre>

<li><a href="usevi.html">more vi commands</a>

<h4>Emacs</h4>

Enter text by typing normally. You can move using
the arrow keys. Other "Ctrl" key sequences 
allow you to delete and cut and paste.

       Mouse button         Function
       left                 Set point.
       middle               Paste text.
       right                Cut text into X cut buffer.
       Shift-middle         Cut text into X cut buffer.
       Shift-right          Paste text.
       Ctrl-middle          Cut text into X cut buffer and delete it.
       Ctrl-right           Select window, then split into two. 
<p>


<h3><a name="5">Running Simulations</a></h3>

<p>
   After you type in your NeuronC program, you run the 
program by typing one of the following commands:
</p>

<pre>
  neurc file.n                      Displays graph on screen.
  nc -t file.n                      Displays only numbers on output    .
                                    Used for "debugging" a model.
  nc file.n > file.r                Saves numbers in file. 
                                       Used for running long simulations.
  nc -v file.n | vid                (equivalent to "neurc file.n")
  plotmod file.r | vid              Displays graph on screen from file.
  plotmod file.r | vid -c >file.ps  Creates PostScript file 
  ps2pdf file.ps                    Creates .pdf file for emailing
</pre>


<h4>How the simulator works</h4>

<p>
   NeuronC is a language and simulator program for 
simulating complete physiology experiments on neural 
circuits.  With the NeuronC language, you can describe 
and simulate a neural circuit as well as a complete 
stimulus and recording paradigm.  Stimuli in NeuronC 
can be voltage or current clamps at single locations in 
the neural circuit or may be 2-dimensional patterns of 
light which cause simulated photoreceptors to transduce 
visual signals.  Thus, NeuronC is especially designed 
for simulating visual neural circuits.
</p>

<h4>Construction mode</h4>

<p>
  NeuronC has 2 distinct modes of operation, 
"construction" and "run".  In the "construction" mode, 
NeuronC builds a neural circuit from programmed 
instructions, along with stimuli and recordings.
<p>

   In the "construction" mode, you can perform simple 
calculations, program loops, procedures and subroutines 
to define neural elements.  You may organize these 
procedures to create a neuron or circuits of many 
neurons.  You may also include stimuli and records in 
loops and procedures.  "Construction" mode is familiar 
to computer programmers because it is similar to a 
language like "C" in which procedures are used to 
accomplish tasks.  
<p>

<pre>
A simple calculation:

     print 54/7;                  // (prints simple calculations)

A print statement within a loop:

     for (i=0; i&lt;10; i++)
            print i, sqrt(i);     // (prints square roots)
</pre>

<h4>Run mode</h4>

   NeuronC's "run" mode stops "construction" mode and 
translates the neural circuit already defined into 
difference equations that are numerically integrated at 
high speed.  During "run" mode, NeuronC numerically 
integrates voltage, runs optical and elecrode stimuli, 
and plots parameters.  Further "construction" must wait 
until the run is completed.  
<p>

<pre>
     statement 1;   (these statements construct neural circuit)
     statement 2;
     statement 3;
     .
     .
     .
     step .05;      (stops circuit construction, runs 50 msec)
</pre>
 

<h3><a name="6">Nodes, neural elements</a></h3>

   NeuronC describes circuits as a set of neural 
elements ("cable, "sphere", "synapse", etc.) connected 
to each other at nodes.  A node is a common point at 
which neural elements connect electrically to each 
other.  A node is not a neural element; it only defines 
connections between neural elements.
<p>
   NeuronC has several types of neural elements.  These 
connect to either 1 or 2 nodes, and the nodes must be 
given when the element is defined.  The types are:
</p>
<pre>

   neural element      part of a neuron (see list below)
   node                point to place neural element, can have (x,y,z) location

   Element    Nodes    Description

   cable       2       defines multiple compartments.
   sphere      1       defines one compartment.
   synapse     2       defines connection between 2 nodes.
   gap junc    2       defines resistive connection between 2 nodes.
   photorecep  1       light transducer connected to node.
   load        1       resistor to ground.
   resistor    2       defines resistive conn. between 2 nodes (same as g.j.)
   cap         2       series capacitor between 2 nodes.
   gndcap      1       capacitor to ground; adds capacitance to node.
   batt        2       series battery between 2 nodes.
   gndbatt     1       battery to ground.
   chan        1       active set of channels in membrane.
</pre>

   For neural elements that have 1 node connection, use 
the word "at" followed by the node number:

<pre>
     at 20 sphere dia 5

     (at node 20, construct a sphere with diameter 5 microns)
</pre>

   For neural elements that have 2 node connections, 
use the word "conn" followed by the first node number,
followed by "to" and the second node number:
<pre>
     conn 20 to 30 cable length 100 dia 2;
     (between nodes 20 and 30, connect a cable ...)
</pre>

   Each neural element has a set of parameters which 
may be specified when the individual neural element is 
declared.  If a parameter is not defined when the 
neural element is defined, it has a default value 
specified by a predefined variable.  For instance the 
default value of membrane resistivity ("Rm") for 
passive dendrites is set by the "drm" variable.  This 
variable may be set with an assignment statment (e.g. 
"drm = 3000") like any other variable.
<p>

<h3><a name="7">Predefined variables</a></h3>

These variables are set to the following "reasonable" values, 
but you can change them with an assignment statement,
e.g. endexp = 0.1;

<pre>
name          default   unit    meaning of variable
----------------------------------------------------------------
timinc           1e-4    sec      time step for numeric integration (sec)
endexp           .05     sec      time for end of experiment
ploti            .001    sec      time step for plot increment (sec)

vk              -.08     V        potassium battery voltage  
vna              .04     V        sodium battery voltage  
vcl             -.07     V        chloride leakage battery voltage  

dcm                1    ufd/cm2   default membrane capacitance
dri              200    ohm cm        default axial resistance 
drg              5e6    ohm um2   default gap junction resistance 
drm            40000    ohm cm2   default membrane resistance ohm cm2

</pre>

<h3>Units</h3>
NeuronC assumes certain units for biophysical 
parameters, and cannot understand units if you type 
them in.  

<pre>
    diameters and lengths          microns
    membrane parameters            see units in above table.  
    time                           seconds, exception synaptic filters = msec
    voltages                       volts 
    current                        amperes
    resistance                     Ohms
    conductance                    Siemens
</pre>

<h3><a name="8">Constructing neural circuits</a></h3>

   NeuronC defines a neural circuit with a sequence of 
statements much like any programming language.  Each 
statement is either 1) a neural element statement, or 
2) a standard programming statement (as in "C") which 
controls how many neural elements will be created.  The 
analogy to a programming language is that NeuronC 
elements are like the printed output from a program; if 
a print statement is included inside a "for" loop, many 
printed lines will appear in the output.  To create 
many neural elements, include their definition in a 
"for" loop in NeuronC.
<p>
   To build a neural circuit, you need to include at 
least one neural element statement and some stimulus 
and plot or print statements:

<pre>
      conn 1 to 2 cable length 100 dia 1 rm 5000;   // constructs cable
      stim node 1 vclamp -.01 start .05 dur .01;    // adds stimulus
      plot V[1];                                    // adds plot
      plot V[2];
      step .1;                                      // runs experiment
</pre>

   This simple NeuronC program builds a cable and 
defines a stimulus of a voltage clamp to minus 10 mv, 
starting at 50 msec into the experiment and stopping 
after 60 msec.  The voltage at each end of the cable is 
plotted.  The plotting stops at 0.1 seconds.


<br>
<hr>
<br>

<h3><a name="10">Section 2)</a></h3>

<h3><a name="11"> Lesson 1) Synaptic input to neuron.</a></h3>

<h4>Background:</h4> 

<p>A neuron receives signals through synaptic 
connections from other neurons.  The synapse evokes a 
post-synaptic potential ("psp") by opening or closing 
channels in the post-synaptic membrane.

<h4>Model 1:</h4>  
<p>
Construct a presynaptic terminal, a synapse, 
and a segment of a neural dendrite.  Stimulate the 
presynaptic terminal with a voltage clamp, and record 
the post-synaptic potential.  Use the editor to make a 
file (or use existing "mod1.n"):
<p>
<pre>
(Enter the following lines in the editor:)

(c o d e:)                               ( c o m m e n t s: )

ploti=1e-4;

pre = 100;                              /* convenience definition */
at pre sphere dia 1;                    /* pre = node for presynaptic term. */

                                       /* make synapse */
conn pre to 1 loc (0,0) synapse expon 5 thresh -.05 maxcond 5e-9 vrev 0;

conn 1 to 2 loc (120,0) cable length 120 dia 1 rm 5000;   /* make cable */

stim node pre vclamp -.045 start .005 dur .01;       /* voltage clamp */

plot V[1] max 0 min -.07;               /* plot the voltage at node 1 */
plot V[pre] max 0 min -.07;

if (disp) {
  display center (0,0,0);
  display size (200);
  display matching [-1][-1][-1];
  exit;
};

endexp = .05;                           /* x axis length on output plot */
step .05;                               /* length of simulation in sec. */
</pre>

<p>
Next, run the program "mod1.n" by typing:
</p>
<pre>

     % neurc mod1
</pre>
<p>
   NeuronC runs a voltage-clamp stimulus to open 
synaptic channels at 5 msec, and closes the channels 10 
msec later.  NeuronC plots a graph showing voltage and 
current vs. time on the screen.  Each "plot" statement 
makes a different color line on the graph.
</p>

<h4>Notes:</h4>

<p>
1) The green line represents the presynaptic 
potential, or -45 mv in this model.  After the voltage 
clamp is turned off at 15 msec, the green line decays 
to resting potential (-70 mV).

<p>
2) The synapse is depolarizing.  The blue line 
represents the time-course of the post-synaptic 
potential ("psp"), which peaks at about 20 mV above 
resting potential.

<p>
3) The post-synaptic membrane potential does not 
reach the synaptic reversal potential (0 mv) because 
the membrane conductance (1/resistance) shunts current 
from the synaptic conductance.  The post-synaptic cable 
segment is quite long and has a large surface area, so 
its membrane conductance is relatively high.

<p>
4) The voltage decay of the post-synaptic membrane 
reflects membrane properties (tau), as well as synaptic 
properties (default synaptic delay dfta = dftb = 0.2 msec).

<pre>
     tau, the time constant = Rm   * Cm
                            = 5000 * 1e-6
                            = 5 msec
</pre>

<p>
5) It may be helpful and fun to try changing some 
of the parameters.  What happens if you change synaptic 
"thresh", or the "vclamp" value?  

<br>
<hr>
<br>
<h3><a name="12">Lesson 2) Electrotonic decay of voltage in cable</a></h3>

<p>
Background: Neurons in the retina have special shapes 
(morphology) tuned for their function.  The morphology 
of some neurons imparts a "weighting function" to 
synaptic inputs that originates in "electrotonic 
decay". 

<p>
     A long neural dendrite approximates an infinite 
cable which causes a voltage at one point to decay 
exponentially along the dendrite.  An important 
parameter for a neural cable is lambda, or "length 
constant", which is the distance along the cable that 
is required for the voltage to decay to 1/e or 37%.

<pre>
  Definitions:

  Rm = membrane resistivity (ohm*cm2)
  rm = membrane resistance  (ohm*cm)
  rm = Rm / 2 * PI * radius

  Ri = axial resistivity (ohm*cm)
  ri = axial resistance  (ohm/cm)
  ri = Ri / PI * radius2

  lambda = sqrt (rm/ri)
  tau = Rm * Cm  =  rm * cm
</pre>


<p>
Problem:  How far along a dendrite must a neural signal 
travel for its voltage to decay to 37% (1/e)?

<p>
Model 2:  Construct a cable long enough to observe 
exponential decay and stimulate it by injecting current 
with the synapse created in "mod1" at one end.  Record 
voltages in the cable at various locations.  Use the 
editor to make a file containing the following 
lines (or use "mod2t.n"):

   % vi mod2t

<pre>
( c o d e )                               ( c o m m e n t s)

ploti = 1e-4;
drm = 5000;                               /* default Rm = 5000 Ohm-cm2 */
pre = 100;                                /* pre-synaptic node = 100 */

at pre loc (0,10) sphere dia 1;
conn pre to 1 loc (0,0) synapse expon 5 thresh -.05 maxcond 5e-9 vrev 0;
                                   /* thresh 50 mv, max con 5e-9 S, etc. */

conn 1 to 2 loc (120,0) cable length 120 dia 1;       /* construct cable */ 
conn 2 to 3 loc (240,0) cable length 120 dia 1;
conn 3 to 4 loc (360,0) cable length 120 dia 1;
conn 4 to 5 loc (480,0) cable length 120 dia 1;
conn 5 to 6 loc (600,0) cable length 120 dia 1;

stim node pre vclamp -.01 start 0 dur .01;     /* voltage clamp */


plot V[1] max 0 min -.07;                 /* max and min define  */
plot V[2] max 0 min -.07;                 /*   the Y-axis of graph */
plot V[3] max 0 min -.07;
plot V[4] max 0 min -.07;
plot V[5] max 0 min -.07;
plot V[6] max 0 min -.07;

plot V[pre] max 0 min -.07;

if (disp) {
     display center (0,0,0);
     display size (1000);
     display matching [-1][-1][-1];
     exit;
   };

endexp = .015;                            /* defines length of X-axis */
step .015;                                /* run model for 15 msec */

</pre>

Run the program mod2t by typing:

<pre>
     % neurc mod2t
</pre>

   The model consists of a synapse and 5 cable 
segments, each 120 microns long, connected together 
between 5 nodes.  This makes a continuous cable 600 
microns long.  It is constructed from 5 segments 
to allow recording the voltage at several nodes.

<p>
Notes for mod2:
<p>

   1) Verify that the time constant (time to reach 63% of 
maximum voltage) is about 2-3 msec.
<p>

   2) Verify that the voltage on the red line (node 4), 
after it reaches an equilibrium value at 10 msec is 
near 37% of maximum on the blue line (node 1).  
Thus, lambda is about 360 microns (3 * 120) for the 
cable.  
<p>
 
   3) Note that the stimulus takes a few msec. to reach 
the distal end of the cable.  The conduction velocity 
may be calculated as:
<p>
<pre>
     velocity = tau/lambda
</pre>

   Next, run the same model with a "space plot" instead 
of a "time plot".  Copy "mod2t" into a new file and 
modify the new file:
<p>
<pre>
     % cp mod2t mod2s 

   drm = 5000;                               /* default rm = 5000 */
   pre = 100;                                /* pre-synaptic node = 100 */

   at pre loc (10,0) sphere dia 1;
   conn pre to 1 (0,0) synapse expon 5 thresh -.05 maxcond 5e-9 vrev 0;
				   /* thresh 50 mv, max con 5e-9 S, etc. */

   conn 1 to 2 loc (120,0) cable length 120 dia 1;       /* construct cable */
   conn 2 to 3 loc (240,0) cable length 120 dia 1;
   conn 3 to 4 loc (360,0) cable length 120 dia 1;
   conn 4 to 5 loc (480,0) cable length 120 dia 1;
   conn 5 to 6 loc (600,0) cable length 120 dia 1;

   if (disp) {
     display center (0,0,0);
     display size (1000);
     display matching [-1][-1][-1];
     exit;
   };

   stim node pre vclamp -.01 start 0 dur .01;

   step .01;                            /* run model for 10 msec */

   graph X max 600 min 0;               /* set X-axis scale */
   graph Y max 0 min -.07;              /* set Y-axis scale */ 
   graph init;                          /* draw X- and Y-axes */ 

   graph (0,  V[1]);                    /* graph volts vs. distance */
   graph (120,V[2]);
   graph (240,V[3]);
   graph (360,V[4]);
   graph (480,V[5]);
   graph (600,V[6]);

   gpen (7);                            /* make labels for graph */
   gmove (0.02,0.85);
   gtext ("Volts");
   gmove (0.45,0.01);
   gtext ("microns");
</pre>

Now, exit the editor.  Run the program mod2s by typing:
<pre>
     % neurc mod2s
</pre>

Notes for mod2s: 
<p>
  1) Remember that the signal is measured by 
subtracting the resting potential (-70 mV) from the 
voltage measured in the cable.  Verify from the plot 
that lambda (37% of the maximum signal) is about 350 
microns.  In this model, Rm=5000 ohm-cm2, Ri=100 Ohm-
cm, so lambda is calculated to be 354 microns for a 1 
micron diameter cable.
<p>
<pre>
          lambda  =  sqrt (rm/ri)  =  sqrt ((Rm / Ri) * (dia / 4)) 
</pre>

   2) In an infinite cable, electric current flows away 
from the source of current, attenuated by leakage 
through membrane conductances.  This produces 
exponential decay, which causes the voltage to decrease 
by a constant ratio over each segment of cable.  
<p>
   3)  Since the cable is not infinite, its decay is 
not exactly a simple exponential.  Verify that the 
voltage decay in "mod2s" is not exponential near the 
distal end (nodes 4-6).  At the distal end (away from the 
synapse), no current leaks through the end of the 
cable.  Therefore the voltage does not decay there, and 
the voltage vs. distance plot approaches a level slope.
<p>

<h4> Effect of cable diameter</h4>

   Next, shrink the cable diameter to diameter 0.1 
(micron) instead of 1.  To run a different model, you 
should copy "mod2s" into a new file and modify the new 
file:
<pre>
     % cp mod2s mod2ss 
</pre>

Run the simulation with the smaller diameter, and 
compare it with the original:

<pre>
   % neurc mod2ss mod2s
</pre>

Notes for mod2ss:
<p>
   1) Note that the post-synaptic potential is larger.  
This is because the cable's resistance (both rm 
and ri) is higher with a smaller diameter.  Now the 
voltage at node 1 approaches the reversal potential for 
the synapse (near 0 mV).
<p>
   2) Verify that decreasing diameter by a factor of 10 
decreases lambda by a factor of about 3 (square root of 
10).  Lambda (distance for decay to 37% of max) is now 
about 100 microns.
<p>
   3) Verify that the voltage decay is exponential 
between segments (voltage decreases by roughly a 
constant factor at each segment) for the smaller 0.1 
micron diameter cable.  Voltage decay is more 
exponential because the cable is several "lambdas" 
long, so the distal end does not affect the proximal 
end much.
<p>
   Next, change "drm" (default Rm) from 5000 to 50000 
and observe the corresponding changes.  Note that this 
increases lambda to near 350 um, but has little effect 
on the psp amplitude.  This is because the synaptic 
output is already near its "driving" potential, and the 
post-synaptic potential is said to be "saturated".
<p>

   Note: A change in either Rm or diameter causes an 
equivalent change in lambda.
<p>
<br>
<hr>
<br>
<h3><a name="13">Lesson 3) Electrotonic decay in dendrite with spines</a></h3>

Background:  Many neurons receive input at "spines" 
which are short dendritic branches with extremely fine 
necks (about 0.1 micron).  These spines restrict the 
flow of electric current because they are so narrow.  
The function of spines for retinal horizontal cells may 
be to shape their spatial responses.  
<p>

Problem: How does a spine affect a synaptic input signal? 
<p>
Model 3: Construct a shorter cable than in the previous 
model, and attach spines at the 2 ends.  Use the editor 
to create a new file (or use existing "mod3.n"): 

<pre>
   % vi mod3
</pre>

<pre>
  drm = 5000;

  pre = 100;                           /* convenient node definitions */
  spine1 = 10;
  spine2 = 20;

  numsegs = 4;                         /* number of segments */
  seglen = 60;                         /* length of segments */ 
  spinelen = 5;
  totlen = numsegs * seglen + 2 * spinelen;

  at pre sphere dia 1;
  conn pre to spine1 synapse expon 5 thresh -.05 maxcond 2e-9;

  conn spine1 to 1 cable length spinelen dia 0.1; /* spine at beg. of cable */

                                        /* "for" loop saves typing */
  for (i=1; i&lt;=numsegs; i++)           /* "for segments 1 to numsegs */
        conn i to i+1 cable length seglen dia 1;

  conn spine2 to 5 cable length spinelen dia 0.1; /* spine at end of cable */

   stim node pre vclamp -.01 start 0 dur .01;

   step .01;                                 /* run model for 10 msec */

   graph X max totlen min 0;                 /* commands to scale graph */
   graph Y max 0 min -.07;
   graph init;

   graph pen (12);
   graph (0, V[spine1]);                     /* post-synaptic potential */
   for (i=0; i&lt;=numsegs; i++) {
      if (i==1) graph pen (2);                 /* i==1 -> (double equals) */
      graph (i*seglen+spinelen, V[i+1]);     /* graph volts vs. distance */
   };
   graph pen (1);
   graph (totlen, V[spine2]);                /* output signal */    

   gpen (7);                                 /* labels for graph */
   gmove (0.02,0.85);
   gtext ("Volts");
   gmove (0.45,0.01);
   gtext ("microns");

</pre>

   Run the program mod3 by typing:

<pre>
     % neurc mod3.n
</pre>

   The model consists of a synapse connecting to the 
first spine that in turn connects to a cable of the 
same diameter as in "mod2".  In a retinal horizontal 
cell, each spine is also a site for the neuron's 
output.  In this model, the neuron's output is located 
at the tip of the second spine.  
<p>
Notes for mod3:  

<p>
   1) Verify that the voltage difference across the 
length of spine 1 (the red line) is about 20 mV, and 
that the decay along the larger dendrite (the green 
line) is about 5 mV. 

<p>
   2) The axial resistance "ri" in the spine neck is 
much greater than the axial resistance in the main 
dendrite.  Therfore, most of the voltage drop occurs in 
the spine neck.

<p>
   3) To understand this reasoning, imagine injecting 
water into a leaky garden hose with an hypodermic 
needle. 

<p>
   4) The value of the axial resistance "ri" is more 
affected by reduced cable diameter than rm, because ri 
is inversely proportional to the square of diameter:  

<pre>
          rm = Rm / 2 * PI * radius 
          ri = Ri / PI * radius2
</pre>

   When the synaptic input current passes through a 
spine to enter a neuron, the loss of current through 
the spine's membrane resistance is insignificant 
compared to the voltage drop across ri.  

<p>
   5) The output spine (spine 2 in "mod3", the blue 
line) does not cause a large voltage drop.  This is 
because its resistance is high and therefore only a 
small current enters it.  Thus, the voltage drop across 
ri is also small.  Imagine the minor loss of pressure 
when filling a hypodermic needle with a garden hose.


<br>
<hr>
<br>
<h3><a name="14"> Lesson 4) Model of Horizontal cell </a></h3>


   Background:  The retinal horizontal cell is roughly 
circularly symmetric, having 5 to 8 branched dendrites 
emanating from a large cell body (soma).  Input to 
horizontal cells comes from photoreceptor synapses 
distributed throughout the dendritic tree, and their 
output synapses are also distributed throughout the 
dendritic tree.  Morphology varies with type of 
horizontal cell (dendrite length/diameter/ branching 
pattern) but it is likely that all horizontal cells 
function in a similar way.

<p>
  The effect of a synaptic input on a neuron's signal 
can vary markedly, depending on the location of the 
cell's input and output.  A synapse has a relatively 
high resistance compared with the total resistance of 
the neuron.  If Rin (input resistance of the neuron) 
seen by the input synapse is high, the synapse drives 
the postsynaptic membrane easily but the membrane 
voltage may saturate, causing a non-linear signal 
transformation.  However, if Rin seen by an input 
synapse is low, the synapse cannot drive its post-
synaptic membrane well.  For this reason, the electric 
signal from a single synapse within a neuron does not 
transfer well from dendrites to the low-resistance 
soma, because the low resistance shunts the signal.  

<p>
   If a neuron's output is derived from this low 
resistance soma (e.g. as in a ganglion cell), then the 
output signal collected from an individual synaptic 
input is reduced by this low resistance.  However, the 
electric signal collected by the soma from many input 
synapses does reflect the average synaptic input (e.g. 
ganglion cell, horizontal cell).  This average signal 
transfers well to distal dendrites, if they are thick 
and have low axial resistance (e.g. horizontal cell), 
because dendrites usually have a higher input 
resistance than the soma.

<p>
   If an output synapse is located in a tapered distal 
dendrite with relatively low axial resistance (e.g. 
horizontal cell), the soma's signal can effectively 
drive the output synapse.  If, however, the output 
synapse is located near input synapses in a fine distal 
dendrite with high axial resistance (e.g. wide-field 
amacrine cells), its signal may reflect nearby input 
synapses rather than the soma's signal.

<p>
Thus, the effectiveness of synaptic transfer from input 
to output reflects both dendritic morphology and 
relative position of the synaptic inputs and outputs.

<p>
Problem: How does anatomy and membrane biophysics of 
horizontal cell affect voltage response at different 
parts of cell?
<p>
<br>

<p>
Model 4) Add a soma to model 3 and test the effect of 
varying soma location with respect to the input and 
output spines.  Copy the previous modeling file 
("mod3.n") to make another file:
<p>
<pre>
   % cp mod3.n mod4.n
</pre>

Edit the file ("mod4.n"): 

<pre>
   % vi mod4.n
</pre>

(Modify "mod4" in the editor to look like this:)
<pre>
(Soma added!)
( c o d e )                             ( c o m m e n t s ) 

   drm = 5000;

   pre = 100;                           /* convenient node definitions */
   spine1 = 10;
   spine2 = 20;

   numsegs = 4;                         /* number of segments */
   seglen = 60;                         /* lengths of segments */ 
   spinelen = 5;
   totlen = numsegs * seglen + 2 * spinelen;
   soma = 5;                            /* soma is connected to node 5 */ 

   at pre sphere dia 1;
   conn pre to spine1 synapse expon 5 thresh -.05 maxcond 2e-9;

   conn spine1 to 1 cable length spinelen dia 0.1;
   conn spine2 to 5 cable length spinelen dia 0.1;

   for (i=1; i&lt;=numsegs; i++)
        conn i to i+1 cable length seglen dia 1;

   at soma sphere dia 30;

   stim node pre vclamp -.01 start 0 dur .01;

   step .01;                                 /* run model for 10 msec */

   graph X max totlen min 0;                 /* commands to scale graph */
   graph Y max 0 min -.07;
   graph init;

   graph pen (12);
   graph (0, V[spine1]);                     /* post-synaptic potential */
   for (i=0; i&lt;=numsegs; i++) {
      if (i==1) graph pen (2);
      graph (i*seglen+spinelen, V[i+1]);     /* graph volts vs. distance */
   };
   graph pen (1);
   graph (totlen, V[spine2]);                /* output signal at spine 2*/    

   gpen (7);                                 /* labels for graph */
   gmove (0.02,0.85);
   gtext ("Volts");
   gmove (0.45,0.01);
   gtext ("microns");
</pre>

   Run the program mod4 by typing:

<pre>
     % neurc mod4
</pre>

   Run the simulation:
<pre>
     % neurc mod4
</pre>

Notes for mod4:
<p>
     1) Verify that the soma increases voltage drop 
along spine 1 (red line) and the main dendrite, but 
does not affect voltage drop in spine 2 (blue line).

<p>
     2) Verify that voltage decay is now greater than 
exponential, that is, voltage decay is now relatively 
linear in each segment, not constant in ratio.


<p>
Move soma to proximal location:

<p>
   Next, copy "mod4" and make a new version "mod4a" in 
which the soma is located at the branchpoint for the 
input spine (node 1).  This time, run the 2 versions 
together so you can compare them:

<pre>
          neurc mod4 mod4a
</pre>

<p>
Note that the effect of locating the soma directly at 
the input spine is to increase voltage drop across the 
spine neck.  However, now there is a slightly larger 
signal at the soma, because the signal is not reduced 
by voltage drop due to the axial resistance (ri) along 
the main dendrite.  But for the signal at spine 2, the 
soma location doesn't matter much.

<p>
Move soma halfway:

<p>
   Make another version of "mod4", say "mod4b". Modify 
"mod4b" to locate the soma halfway between spine 1 and 
spine 2 (node 3), and run the model again.  Run the 3 
versions of mod4 together:

<pre>
     neurc mod4 mod4a mod4b
</pre>

     Note that the effect of placing the soma halfway 
along the main dendrite is to reduce the length of the 
dendrite and slightly increase signal at the soma.  The 
signal arriving at spine 2 is only slightly reduced by 
traversing the distal part of the main dendrite 
(between soma and spine 2).
<p>
   The effect of additional horizontal cell branches on 
the signal from one synapse can be simulated by 
the soma.  The soma's effect is to shunt electric 
current and therefore to increase voltage drop along 
the axial resistance of the dendrites and spines.
<p>


<br>
<hr>
<br>
<h3><a name="15">Lesson 5) Model of photoreceptor network </a></h3>

   Background: Photoreceptors in all vertebrates are 
coupled by gap junctions, which spread electrical 
signals laterally.  Gap junctions therefore couple 
photoreceptors into a large 2-dimensional syncytium 
(coupled neural array).  In effect, this coupling 
"blurs" visual signals after they are transduced by 
photoreceptor outer segments.  This blur is an 
essential part of retinal signal processing.  Its 
function is to filter out spatial high-frequency 
signals before they traverse the first chemical 
synapse. 
<p>
Problem: What is the effect of electrical coupling in a 
small array of cones on the signal from one cone?
<p>
Model 5) Create a small array of cones (modeled here as 
single compartments) and couple them into a 2-
dimensional array with gap junctions.  Also create an 
isolated cone for comparison.  Stimulate the array with 
a small spot over the central cone, and record the 
responses of a line of cones. With the editor, create 
a new file (or use existing "mod5t.n"): 
<p>

<pre>
   % vi mod5t.n
</pre>

Enter the following lines:

<pre>
(c o d e)                                 /* c o m m e n t s */

endexp = .15;                             /* x axis length for plot */
drm = 5000;

for (row=0; row&lt;35; row+=5)               /* create cone array */
      for (col=0; col&lt;35; col+=5) {       /* nested "for" loops */
          at [row][col] cone (row,col) maxcond 1e-9; 
          at [row][col] sphere dia 10;
      };


drg = 1;                                /* calibration for gsiz in Siemens */ 
gsiz = 1e-8;                           /* 1 connexon = 100 pS */

for (row=0; row&lt;30; row+=5)                      /* connect gj's between rows */
      for (col=0; col&lt;35;  col+=5) {
          conn [row][col] to [row+5][col] gj gsiz;
      };

for (row=0; row&lt;35; row+=5)                      /* connect gj's between columns*/
      for (col=0; col&lt;30; col+=5) {
          conn [row][col] to [row][col+5] gj gsiz;
      };

cent = 15;

stim spot 1 loc (cent,cent) inten 1e7 start .01 dur 1e-3;
  /* spot 1 um diam;        inten 1e7 phot/um2/sec; dur 1 msec */

plot V[0][0]     max -.031 min -.035;         /* plot corner response */
for (dist=0; dist&lt;35; dist+= 5) {            /* plot line though center */
   plot V[cent][dist] max -.031 min -.035;
};

plot L[cent][cent]   max 5e7  min 0;         /* plot light flash */

step .15;
</pre>

Run the simulation:

<pre>
     % neurc mod5t
</pre>

Notes:

     1) Note that mod5t gives a plot of the cones' 
response voltage versus time.  The cones take about 10 
msec. to initially reach an equilibrium potential.  
Compare the response of the central cone with the 
others in the array.  The central cone's response is 
considerably reduced because of lateral current flow 
through the gap junctions. 
<p>
     2) Note that the response of cones near the edge 
of the array is lower in amplitude and delayed in time, 
compared with the central cone's response. 

<p>
     Next, modify "mod5t.n" for a spatial plot. Copy mod5t.n
into a new file "mod5s.n" and modify it to look like 
this:

<p>
(mod5s should look like this:)

<pre>
drm = 5000;

for (row=0; row&lt;35; row+=5)                  /* create cone array */
      for (col=0; col&lt;35; col+=5) {
          at [row][col] cone (row,col) maxcond 1e-9; 
          at [row][col] sphere dia 10;
      };

drg = 1;                               /* calibration for gsiz in Siemens */ 
gsiz = 1e-8;

for (row=0; row&lt;30; row+=5)                      /* connect gj's between rows */
      for (col=0; col&lt;35;  col+=5) {
          conn [row][col] to [row+5][col] gj gsiz;
      };

for (row=0; row&lt;35; row+=5)                      /* connect gj's between columns*/
      for (col=0; col&lt;30; col+=5) {
          conn [row][col] to [row][col+5] gj gsiz;
      };

cent = 15;
stim spot 1 loc (cent,cent) inten 1e7 start .01 dur 1e-3;

step .07;

graph X max 30 min 0;                   /* commands to scale graph */
graph Y max -.031 min -.035;
graph init;

graph pen (12);
graph (0, V[0][0]);                     /* corner cone */
for (dist=0; dist&lt;35; dist += 5) {      /* plot line though center */
      graph (dist, V[cent][dist]);      /* graph volts vs. distance */
};

gpen (7);                               /* labels for graph */
gmove (0.02,0.85);
gtext ("Volts");
gmove (0.45,0.01);
gtext ("microns");

</pre>

   Remember that mod5s takes about 30 seconds to run. 
Be patient while the cone responses are recorded at 
their maximum.
<p>
     By recording from a line of cones, "mod5s" gives a 
spatial plot similar to a receptive field map of a 
single cone.  Note that the spatial response of the 
cone array looks somewhat exponential (actually a 
modified Bessel function).  The space constant for the 
array's response is approximately 2 cones or 10 um 
distance.  

<p>
     The space constant can be varied by changing the 
gap junction conductance.  Try increasing and 
decreasing the conductance by factors of 2, and then 
try increasing by a factor of 1000 to simulate closed 
gap junctions.

<p>
     In real experiments, a stimulus always has some 
optical blur.  To see the effect of optical blur, 
try increasing  the size of the stimulus light spot to 
15 microns in diameter.  This causes a larger response 
by stimulating several cone photoreceptors, and changes 
the shape of the cone receptive field.

<p>
   To see the effect of totally isolating the cones, you 
can try copying "mod5t" to make "mod5ti", and add the 
following lines to "mod5ti":

<pre>
row = 100;
col = 100;
cent = 10;

at [row][col] cone (cent,cent);              /* make single isolated cone */
at [row][col] sphere dia 5;

plot V[row][col] max -.02 min -.07;          /* plot the isolated cone */

</pre>

   But perhaps an easier way to look at "isolated" 
cones in this type of model is to stimulate all of them 
with a spot large enough to "cover" all of them.  Try 
increasing the size of the spot to 100 microns.  In 
this case, there is no lateral coupling because each 
cone has an identical response.  This approach requires 
more computation, though!  
<p>

<br>
<hr>
<br>
<h3><a name="16">Lesson 6) Model of wide-field amacrine cell. </a></h3>

Background: Many amacrine cells have a distinctive 
morphology consisting of extremely long, fine dendritic 
processes emanating from the soma.  The dendritic 
processes enlarge to form small beads or "varicosities" 
every 5 to 10 um.  Each varicosity typically contains 
one input and one output synapse.  It is likely that 
the space constant of the fine dendritic processes is 
relatively short (i.e. less than 50 um); therefore the 
function of this type of amacrine cell is probably 
local processing.
<p>

Problem:  What is the space constant of a fine 
dendritic process that contains varicosities and 
synaptic inputs?
<p>
Model:  Construct a fine (0.1 um diameter) dendritic 
cable with varicosities (4 um diameter) spaced every 10 
um.  Locate a synaptic input at one varicosity.  
Stimulate the synapse, and record voltage in the local 
varicosity as well as in other distal varicosities.
With the editor, create a new file ("mod6t.n"): 
<p>

<pre>
   % vi mod6t.n
</pre>

Enter the following lines:

<pre>
/* amacrine dendrite with varicosities */
/*  temporal plot */

drm = 5000;
endexp = .02;

nsegs = 10;
seglen = 10;
totlen = seglen * nsegs;
varicos = 4;
synap = 100;

for (i=1; i&lt;=nsegs; i++) {
  at   [i][synap] sphere dia 3;                 /* presynaptic terminal */
  conn [i][synap] to [i] synapse expon 5 maxcond 5e-9 thresh -.04 vrev -.01;
  at i sphere dia varicos;                      /* the varicosity */
  conn i to i+1 cable length seglen dia 0.1;    /* the fine cable */
  if (i==5) stim node [i][synap] vclamp -.025 start 0 dur .01
/*else      stim node [i][synap] vclamp -.030 start 0 dur .05; */
};
at i sphere dia 5;

for (i=1; i&lt;=nsegs; i++) {
  plot V[i] max -.01 min -.07;
};
step .02;

</pre>

Now, exit the editor.  Run the simulation:

<pre>
     % neurc mod6t
</pre>

Notes
<p>
   This model consists of 10 varicosities and fine 
cable segments connected as beads on a string, 
connected on one end to a small soma.  A synapse is 
located at varicosity 5, which is near the center of 
the cable.  Verify that the voltage at this node is 
greater than other nodes, and that it reaches an 
equilibrium potential near 10 msec, when the stimulus 
gets turned off.

<p>
   Now, try the space plot.  Make another file "mod6s" 
by copying "mod6t".  Erase the "plot" lines and put in 
the "graph" lines:

<pre>
/* amacrine dendrite with varicosities */
/*  spatial plot */

drm = 5000;

nsegs = 10;
seglen = 10;
totlen = seglen * nsegs;
varicos = 4;
synap = 100;

for (i=1; i&lt;=nsegs; i++) {
  at   [i][synap] sphere dia 3;                 /* presynaptic terminal */
  conn [i][synap] to [i] synapse expon 5 maxcond 5e-9 thresh -.04 vrev -.01;
  at i sphere dia varicos;                      /* the varicosity */
  conn i to i+1 cable length seglen dia 0.1;    /* the fine cable */
  if (i==5) stim node [i][synap] vclamp -.025 start 0 dur .01;
/*  else    stim node [i][synap] vclamp -.030 start 0 dur .05; */
};
at i sphere dia 5;

graph X max totlen min 0;
graph Y max -.01 min -.07;
graph init;
gpen (7);                                 /* labels for graph */
gmove (0.02,0.85);
gtext ("Volts");
gmove (0.45,0.01);
gtext ("microns");

graph pen (2);
stepsiz=.001;
for (t=0; t&lt;.02; t+=stepsiz) {
   step stepsiz;
   graph restart;
   if (t&gt;=.01) graph pen (4);
   if (t==.01) stim node [i][synap] vclamp -.045 start .01 dur .02;
   for (i=0; i&lt;=nsegs; i++) {
      graph (i*seglen, V[i+1]);           /* graph volts vs. distance */
   };
};
</pre>

Now, exit the editor.  Run the simulation:
<pre>
     % neurc mod6s
</pre>

Notes:
<p>
   1) Note that the dynamic range of the signal is 
about 55 mV.  This results because the synapse is 
turned completely on and then off.
<p>
   2) Verify that lambda is about 3 cable segments long 
(30 microns).  The green graph lines represent the 
voltage along the dendrite during rising stimulus, and 
the red lines represent the falling stimulus.  This is 
longer than lambda for a 0.1 micron dendrite (see Model 
2)  which is near 100 microns.  The effect of the 
varicosities is to act as "radiators" for the electric 
current.  The effect of the varicosities is to decrease 
membrane resistance for the fine dendrite.
<p>
   To investigate the effect of synaptic conductance at 
all the varicosities, locate synaptic inputs at all 
varicosities.  This time, stimulate the original 
synapse as before, but stimulate the others as well.  

<p>
   Construct additional extra synapses by removing the 
comments around the second "stim" statment in "mod6s".  
Also remove the semicolon at the end of the first stim 
statement.  The two stim statments should look like 
this:

<pre>
     if (i==5) stim node [i][synap] vclamp -.025 start 0 dur .01
     else      stim node [i][synap] vclamp -.030 start 0 dur .05;
</pre>

  Also, modify the Y min value for the graph:

<pre>
     graph Y max -.01 min -.04;
</pre>

  Then run the model:

<pre>
     neurc mod6s
</pre>


Notes:
<p>
   1) The extra synapses are activated throughout the 
duration of the model and therefore do not directly add 
to the signal.  However, the effect of the extra 
synapses is much like a varicosity: an activated 
synapse can reduce membrane resistance and therefore 
passively reduce signal spread. 

<p>
   2) Verify that the dynamic range (from activated on 
to inactivated) of the signal is only about 8 mV now.  
This occurs because the decreased membrane resistance 
shunts electric current laterally.

<p>
   3) Note that after the stimulus is turned off, the 
red line shows an "inverted V" which is the result of 
turning off the signal synapse at varicosity 5 while 
the other synapses remain activated. 

<p>
   4) Verify that lambda is now about 10 microns.  This 
much reduced lambda implies that under certain 
conditions a) synaptic connections can control lambda 
in fine dendritic trees, and b) the signal in each 
varicosity can be effectively controlled by its input 
synapse, irrespective of signals in neighboring 
varicosities.


<br>
<hr>
<br>
<h3><a name="20">Section 3)</a></h3>

Design philosophy:   "keep it simple!"
<p>
   Often when setting up a neural circuit model it is 
helpful to remember that a simple model is easier to 
understand and possibly more believable than a more 
complex one.  This is generally true because the 
utility of a computational model is often that it 
quantitatively assists (stretches) our imagination.   
If a model is so complex that we don't understand it, 
then it does not help us.  If a model uses many 
parameters for which numerical values are not known, 
then it may be a focus for disbelief.

<p>
"Do it in stages"

<p>
   It is best to first make a simple model to verify 
the operation of the model's components.  Then enlarge 
the model after it gives a threshold of confidence.  
For instance, to model a large circuit with many 
neurons involved in negative synaptic feedback, it is 
best to start with one cell and get its anatomy and 
membrane properties worked out.  Next set up 2 cells 
and their synaptic feedback and verify that the 
feedback is working properly using appropriate stimulus 
and recording sites.

<p>
   After the anatomy and basic synaptic model is all 
working properly, you should expand the model to 
include more cells and complexity.  The advantage of 
this technique is that any problems that occur can 
usually be localized to the addition of a few neural 
circuit elements, because everything was developed and 
verified in successive stages.


<br>
<hr>
<br>
<pre>
               Copyright (C) 2014

                 Robert G. Smith
             Department of Neuroscience
          Univ. of PA Medical School
            Phila., PA   19104-6058
                      USA

              All Rights Reserved
</pre>

</html>
