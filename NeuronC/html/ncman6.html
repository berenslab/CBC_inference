
<html>
<title>Retsim: a retinal simulator</title>
<body bgcolor="#eec499">

<h2><a name = "A">Retsim: a retinal simulator</a></h2>

<table width="675">
 <tr>
  <td>
<IMG SRC="gcmodel.bot.png" height="400" align="right" hspace="12">

<ul><li><a href = "#1">1. Introduction</a></ul>
<ul><li><a href = "#1.2">1.2 Beginning example of how to run a retsim experiment</a></ul>
<ul><li><a href = "#1.4">1.4 Running retsim in a virtualbox window</a></ul>
<ul><li><a href = "#1.6">1.6 Displaying the model</a></ul>
<ul><li><a href = "#2.0">2. How to define an experiment</a></ul>
<ul><li><a href = "#2.5">2.5 How to develop a model in retsim</a></ul>
<ul><li><a href = "#3">3. Generating cell morphologies</a></ul>
<ul><li><a href = "#4.0">4. Array topology from connection algorithm</a></ul>
<ul><li><a href = "#4.2">4.2 Defining extent of neural arrays</a></ul>
<ul><li><a href = "#4.3">4.3 Specifying exact locations for cells</a></ul>
<ul><li><a href = "#4.4">4.4 Specifying rotation for 2nd cell in stereo pair</a></ul>
<ul><li><a href = "#4.5">4.4 Specifying exact locations for cells vs. an automatic array</a></ul>
<ul><li><a href = "#4.6">4.5 Trimming the arrays</a></ul>
<ul><li><a href = "#5">5. Connecting the neurons</a></ul>
<ul><li><a href = "#6">6. Neural and synaptic parameters: the "nval.n" file</a></ul>
<ul><li><a href = "#6.2">6.2 Setting synaptic connection parameters</a></ul>
<ul><li><a href = "#6.3">6.3 Setting and overriding values in nval.n</a></ul>
<ul><li><a href = "#6.4">6.4 Speeding construction of large models with many synapses</a></ul>
<ul><li><a href = "#6.5">6.5 Channel density file "dens.n"</a></ul>
<ul><li><a href = "#7">7. Stimulus types</a></ul>
<ul><li><a href = "#8">8. Record types</a></ul>
<ul><li><a href = "#9">9. Onplot procedure</a></ul>
<ul><li><a href = "#10">10. Making movies</a></ul>
<ul><li><a href = "#11">11. Compiling and linking</a></ul>
<ul><li><a href = "#12">12. Coding: parameter initialization</a></ul>
<ul><li><a href = "#12.2">12.2 Running a voltage clamp protocol</a></ul>
<ul><li><a href = "#13">13. Examples of how to run retsim</a></ul>
<ul><li><a href = "#14">14. Useful retsim functions</a></ul>
<ul><li><a href = "#15">15. Experiment files</a></ul>
<ul><li><a href = "#16">16. Running retsim from a batch file</a></ul>
</ul>

  </td>
 </tr>
</table>

<hr>
<h3><a name = "1">1. Introduction</a></h3>

<p>
"Retsim" is a set of scripts that construct a biophysically-realistic model of
a neuron and its presynaptic circuit. Typically, a light stimulus is transduced
by an array of photoreceptors (rods and/or cones or transducers), and the
resulting signals are synaptically transmitted to an array of bipolar cells,
which in turn transmit their signals to one or more ganglion cells.  The arrays
of different neuron types are generated as semi-random arrays, given a cell
density and a regularity (mean/s.d) or by array size or number.  Synaptic
contacts are automatically set based on a connection algorithm specified in a
paramater table.  Experiments are defined by constructing a neural circuit,
defining an experimental protocol (e.g. voltage-clamp or current-clamp), and
defining stimuli and output plots.

<p>
The main script is "retsim.cc" (previously "retsim.n") which defines a set of
parameters that control the construction of the stimulus and calls construction
subroutines to make the different cell arrays and connect them, defines a
procedure to display the model, and defines an experiment to run on it. The
"makcel" script constructs the neurons, and the "synfuncs" script makes the
connections. 

<p>
To help you get started setting up and running retsim, an example below spells
out all the steps. It shows one example of a neural circuit defined by an
experiment file "expt_gc_cbp_flash.cc". Once you see how to run this example,
you can look at the other expt*.cc files and compare them.

<p>
The ".n" versions of these scripts were originally developed to run with the
"nc" interpreter, but have not been maintained. Please use the ".cc" versions.

<h4> Source code files in nc/models/retsim:</h4>

<pre>
Script                 Function

retsim.cc              main script, oversees construction, connection, display, and run.
retsim_var.cc          variable definitions, set pointers for command-line values.
makcel.cc              makes arrays of neurons, either realistic or artificial.
synfuncs.cc            connects arrays and individual neurons with synapses based on algorithm.
celseg.cc              makes spheres and cables with biophysical properties.
celfuncs.cc            functions to help make cells.
morphfuncs.cc          helper functions to measure morphology params
maknval.cc             script to create table of parameters "nval.n".   
modelfit.cc            Levenberg-Marquardt least-squares fitting usimg simulator as fit function (see "Curve fitting with NeuronC" manual)
namedparams.cc         functions for accessing column and row by name (used for "chanparams" file)
nval_var.cc            parameters for nval, automatically generated by "maknval".
nval_var_set.cc        sets parameters for nval, automatically generated by "maknval".
rectask.cc             functions for recording
stimfuncs.cc           stimulus functions.
plot_funcs.cc          plotting functions.
sb_makfuncs.cc         starburst cell make functions.
sb_recfuncs.cc         starburst cell recording functions.
setexpt.cc             reads, links dynamically loaded experiment files
spike_plot.cc          functions to calculate spike rate
stimfuncs.cc           functions to generate stimuli
synfuncs.cc            functions to generate synaptic connections

onplot_movie.cc        movie frame functions
onplot_dsgc_movie.cc   DS ganglion cell movie functions (includes "onplot_movie")

expt_gc_cbp_flash.cc   experiment file: defines and sets parameters, sets up and runs experiment.
runconf/nval.n         parameter table, defines cell parameters and synaptic connections
runconf/dens.n         channel density table  (subdir runconf is configurable)
runconf/chanparams     channel param table (voffset, tau)
runconf/morph_file     morphology file

nc library in nc/src:

libnc.a                library of functions required by retsim, generated by compiling nc in nc/src
</pre>


<br>

<h3><a name = "1.2">1.2 Beginning example of how to run a retsim experiment</a></h3>

You can run retsim by compiling the Neuron-C package on your Linux or Mac system. Or you can download "VirtualBox" and run a linux OS inside of a window on Windows or Mac systems. A VirtualBox image of Slackware Linux is available with retsim already installed (see "Running retsim in a virtualbox window" below).<p>

To run retsim natively under Linux or Mac, you must first compile "nc" "vid", and "retsim": <p>

1. Start a console window (in KDE, "konsole", in Mac, "terminal"). Use this window to run the following commands:<p>
2. Untar the distribution. "tar xvzf nc.tgz&ltEnter&gt". If you have downloaded nc.tgz to another folder, place that folder name ahead of nc.tgz, e.g. "tar xvzf "Downloads/nc.tgz"<p>
3. Go to the nc directory (folder), "cd nc&ltEnter&gt". Make nc with: "make"; This will compile and link all the files for nc and link them into "nc" and "libnc.a". It will also make plotmod and vid. To make nc on a Mac, see the paragraph below "Compiling and linking nc and retsim". Note that to make nc you must install the C and C++ compilers, along with the X-Windows development package<p>
4. Go to nc/models/retsim. "cd models/retsim (cd ~/nc/models/retsim)"<p>
5. Make retsim with: "make". This will make retsim and all the experiment scripts in the makefile. If you are compiling retsim on a Mac, see "Compiling retsim on Mac OSX" below.<p>

6. Edit your shell startup file to include "~/nc/bin" in your PATH. You can use a programming text editor such as kwrite, kate, gvim, gedit, vim, or joe:<p> 
7. If you're using the "bash" shell (the usual default), edit your ~/.profile or ~/.bashrc file(s) to include "~/nc/bin" in the PATH.<p>
8. Or if you're using "csh" or "tcsh", add "~/nc/bin" to your .cshrc file (already set in the virtualbox image). You can find an example file at nc/.cshrc.<p>
9. Then, tell the shell to read the .profile, .bashrc (or .cshrc) file:
    "source .profile" (or "source .bashrc", or for csh, "source .cshrc"). This is done automatically at every login, so you only have to do it once here.<p>
10. Check to see if your path is set correctly, run "cd ~; nc -h; plotmod -h" should run nc and plotmod. Note that some Linux versions come with a command "nc" in the standard distribution. If you place the ~/nc/bin entry in PATH before the other entries, the "nc" in Neuron-C should run instead.<p>
11. To get proper dynamic linking of your expt*.so files in nc/models/retsim, edit your shell startup file and add "LD_LIBRARY_PATH ." (see Compiling and linking below):<p>
<pre>
(if using tcsh)  setenv LD_LIBRARY_PATH .            [ add to your ~/.cshrc file ]
(if using bash)  export LD_LIBRARY_PATH="."          [ add in your ~/.profile file ]
</pre>
<br>
<hr>
<br>
12. Run a typical experiment, "gc_cbp_flash" like this (enter manually or copy-and-paste):<p>

<pre>
cd ~/nc/models/retsim
retsim --expt gc_cbp_flash --ninfo 2 -d 1 -v | vid
</pre>

Retsim displays the model on the "vid" window, and prints this text on the screen:
<p>

<pre>
# Retina simulation
#
#   retsim version:    1.7.57     
#   nc version:        6.2.18     
#   date:              Sat May  9 22:21:20 EDT 2015     
#   machine:           dyad     
#   experiment:        gc_cbp_flash     
#   confdir:           runconf
#   nvalfile:          nval_gc_cbp_flash.n
#   cone  morph:       artif 1
#   dbp1  morph:       artif 1
#   gca   morph:       morph_beta8b,   densities: dens_gca.n
#   chanparams file:   chanparams
#
#
# gcas:
# ganglion cells done.
# xarrsiz = 288; yarrsiz=271; arrcentx=0; arrcenty=0
#
# cones:
# cone spacing: 6.32 um
#
# cones:
# Number of cones: 2074
# photoreceptors done, arrsiz=290.938
#
# dbp1s:
# bipolar cells done.
# Done making neurons.
#
# total cones = 2074
# total dbp1s = 508
# total gcas  = 1
#
# connecting cones to dbp1s
# ........................................................................................
..........................................................................................
........................................................................................  
...  
...  
[i.e. one dot per cone, up to 2074 cones].

# connecting dbp1s to gcas
# ........................................................................................
..........................................................................................
........................................................................................
...
[i.e. one dot per cone bipolar]

# cell type  cone,  2074 cells: div to dbp1 = 1.83
# cell type  dbp1,   508 cells: conv from cone = 7.47, div to gca = 0.524
# cell type   gca,     1 cell: conv from dbp1 = 266
# 
#
# Removing neurons that don't connect.
#
# dbp1s  erased 242
# cones erased 890
# total cones = 1184
# total dbp1s = 266
# total gcas  = 1
#
# Done connecting neurons.
#
# cell type  cone,  1184 cells: div to dbp1 = 1.7
# cell type  dbp1,   266 cells: conv from cone = 7.56, div to gca = 1
# cell type   gca,     1 cell: conv from dbp1 = 266
# 

</pre>

Notes:<p>

a. This command line "retsim ... | vid" runs two commands, "retsim" and "vid".
The "|" (vertical bar) symbol is a "pipe" that redirects the "standard output"
(stdout, defaults to screen) stream from retsim to the "standard input" (stdin,
defaults to keyboard) of vid. This is a graphics stream and looks like garbage
if printed onto the screen (e.g. try "retsim ...  -v" without the "| vid"
appended).  To stop the display, click on the original terminal window and
enter ^C (control-C).<p>

b. The printout of cell and connection information is specified by "--ninfo 2".
You can see more details with "--ninfo 3" or "--ninfo 4" in the command line.
The display of information on the screen by "--ninfo" is from the "standard error"
(stderr) stream of retsim. This separate from "stdout" and is not redirected by
the "|" pipe symbol so it is displayed by default on the screen.  <p>

c. The printout shows what experiment is being run, and what files were used to
construct the model.<p>

d. To get this to run, you must have compiled nc, vid, and retsim, added the ~/nc/bin
to your path, and you must have "nval_gc_cbp_flash.n", morph_beta8b, dens_gca.n, and
chanparm in the directory nc/models/retsim/runconf.  These files are included in the
nc.tgz distribution, in nc/models/retsim/runconf, the default directory for these
files.<p>

e. The experiment file name is the experiment with "expt_" appended onto the
beginning and ".cc" at the end. To run an experiment file, put "--expt" then
the experiment name, i.e. "expt_gc_cbp_flash.cc" defines the experiment
gc_cbp_flash that you run with "retsim --expt gc_cbp_flash ...".

f. Find the other experiment files with "ls -l expt*.cc"<p>

g. The morphology file "morph_beta8b" and the density file "dens_gca.n" are located
by default in nc/models/retsim/runconf.<p>

h. To rotate the model, run:<p>
<pre>
    retsim --expt gc_cbp_flash --ninfo 2 --mxrot -90 -d 1 -v | vid
</pre>
To flip the morphology left-right, run:<p>
<pre>
    retsim --expt gc_cbp_flash --ninfo 2 --flip 1 -d 1 -v | vid
</pre>

i. To run the experiment and generate plots, run the same command line, except remove the "-d 1":<p>
<pre>
   retsim --expt gc_cbp_flash --ninfo 2 -v | vid
</pre>

j. To capture the output of the experiment in a file, run the same command line, except add ">& file.r":<p>
<pre>
   retsim --expt gc_cbp_flash --ninfo 2 -d 1 >& file.r  (display model, send the stdout and stderr to a text file)
   plotmod file.r | vid                                 (display the model file as graphics)
   retsim --expt gc_cbp_flash --ninfo 2 >& file.r       (run expt, send plots into a text file)
   plotmod file.r | vid                                 (display the plots in text file as graphics)
</pre>
To run the experiment in the background do:
<pre>
   retsim --expt gc_cbp_flash --ninfo 2 >& file.r &              (run expt in background)
same as:
   retsim --expt gc_cbp_flash --ninfo 2 >& file.r; ^Z bg &ltEnter&gt (run expt in background)
</pre>
The ^Z (control-Z) stops the current process, and the "bg" command runs it in
the background as if you had run it originally with an "&" (ampersand) after
the command. When you run a command in the background, you can run other
commands simultaneously.<p>

k. To make a smaller neuron array that runs faster:<p>
<pre>
   retsim --expt gc_cbp_flash --ninfo 2 --arrsiz 100 -d 1 -v | vid
   retsim --expt gc_cbp_flash --ninfo 2 --arrsiz 100      -v | vid
</pre>

l. Note that retsim currently lacks interactive display of the model, i.e. you can't
redisplay a view with a different rotation or magnification without rerunning the
model construction mode.  Although on first thought this capability may seem
important for developing intuition about the cell model, or to determine where to
place a recording electrode, in practice it is not necessary.  To set an electrode
location, one can specify node numbers in a cell, or one can specify absolute
coordinates or by coordinates relative to the cell soma by nearest node position. A
set of functions can find recording points specified in this way by absolute or
relative location (see "celfuncs.cc"). <p>

m. You can find more examples of how to run retsim in "Examples of how to run retsim" below.<p>

<br>

<h3><a name = "1.4">1.4 Running retsim in a virtualbox window</a></h3>

To run retsim within a virtualbox window on a Windows or Mac computer, you can
download VirtualBox and a linux virtual disk image for VirtualBox that contains
retsim already installed.  To do this, you first download VirtualBox from
virtualbox.org, Then you download "linux.vdi.141.zip" from
ftp://retina.anatomy.upenn.edu/pub/rob", and unzip this to make "linux.vdi.141", then
rename to "linux.vdi" ("mv linux.vdi.141 linux.vdi").  Then in VirtualBox, create a
new virtual machine called "linux", and when prompted load the "linux.vdi" image
into the VirtualBox machine. You can login as "guest", then go to step 12 above to
run a retsim experiment. The guest login is set to use the "tcsh" shell, and the PATH
variables are already set in the ~/.cshrc file.  To have the
latest improvements to retsim, you should always download and
"make clean", then "make" the latest Neuron-C distribution (nc.tgz).<p>

<h4>Accessing the external OS from virtualbox</h4>

You can access the file system outside virtualbox by 
setting up a shared folder, or using network tools such as "rsync" or "scp". <p>

<pre>
scp file.r extmachine:/home/myfolder
or
rsync -azr -e ssh --progress file.r extmachine:/home/myfolder
 (same as: rsyncc file.r extmachine:/home/myfolder)
</pre>

A command called "rsyncc" runs "rsync" with the appropriate command line
switches. This rsyncc command is installed in the virtualbox image:<p>
<pre>
rsyncc file.r extmachine:/home/myfolder
</pre>

<h4>Other useful applications in the virtualbox image</h4>

The virtualbox image available with retsim already installed also contains several
other useful commands:

<pre>
povray             ray tracer useful for 3D rendering the output of "retsim -R" into .png files 
ffmpeg             movie-maker useful for making movies from output of "vid" (see "Making movies" below)
mpeg_encode        movie-maker useful for making movies from output of "vid"
libreoffice        full-featured office lookalike "soffice"
xmgrace            full-featured graphing, fitting, and analysis program.
octave             full-featured matlab almost-lookalike, run from terminal or console window.
vncviewer          virtual console and server, useful for running remote desktop
</pre>

<br>
<h3><a name = "1.6">1.6 Displaying the model</a></h3>

<h4>Displaying information about the model and connections</h4>

You can use the predefined "ninfo" variable to tell retsim to display information
about the model it constructs. 

<pre>
ninfo = 0   // don't display any information
ninfo = 1   // display basic info on number of cells 
ninfo = 2   // display info on cells and connections
ninfo = 3   // display basic debugging info
ninfo = 4   // display debugging info about connections
ninfo = 5   // display debugging info about cell morphology and connections
</pre>
For example, to see basic cell connection info:
<pre>
retsim --expt ... --ninfo 2 ... -v | vid 
or
retsim --expt ... --ninfo 2 ... >file.r
</pre>
The information is printed on the computer screen (using the "stderr" stream).


</pre>

For most runs it is helpful to set ninfo = 2, which prints out the convergence
and divergence for each cell type. You can set ninfo in the
experiment file or in the command line.

<h4>Displaying the model as an image</h4>

To display the morphology, use the "-d 1" command-line switch.  This will
display all the cells but not the node numbers or the compartments.  To display
nodes, use the "-d 9" switch, which displays the node numbers superimposed on
the morphology.  This is also described in the help table printout from "retsim
-h", which shows all of the possible display features.  To display the
compartments, use the "-d 6" or "-d 15" switch (i.e. -d 6 is "6=2+4",
compartments+connections). <p>

<h4>Retsim command-line options</h4>

You can find these command-line switches with: <p>

<pre>
retsim -h
</pre>
This prints out:
<pre>
## retsim: nc version 6.2.18
nc -v      video mode to stdout (makes graphics).
   --var n  set variable from command line.
   -c      run from inside script with first line = #! nc -c
   -d 1    display 'neural elements' with 'display' statement.
   -d 2            'compartments'   
   -d 4            'connections'
   -d 8            'nodes'
   -d 16           'stimulus'
   -d 32           'movie (vcolor,cacolor)'
   -p 1    print out compartments as conductances.
   -p 2    print out compartments as spheres, chan densities.
   -q      quiet, don't print extra info (eqiv to "--info 0").
   -E n -e n override xmax, xmin on plots
   -M n -m n override ymax, ymin on plots
   -l n    set 'lamcrit' variable (0=no condensation).
   -f      no file name on graph.
   -F      no labels on graph.
   -I      run as interpreter only.
   -K      print out all predefined symbols.
   -n      no node numbers on graph.
   -r n    random number seed. Negative = different each time.
   -s n    set precision of output numbers. def=6.
   -C      run input file through CPP preprocessor .
   -R      output symbolic display for "povray" ray-tracer.
   -L n    set line width for display statement.
   -w n    set vid window size for "ncv" or "ndv".
   -W n    tic label char with in terms of screen size.
   -y n    debug level.
   -z n    debug category.
   -1 fn   redirect stdout to file "fn"
   -2 fn   redirect stderr to file "fn"
</pre>

When running "retsim -h" (or any other linux command) in a small window, you can page
its output like this:

<pre>
retsim -h | more    # page down with spacebar
retsim -h | less    # page down with spacebar or page down key, and go down and up with arrow keys

Exit from "more" with ^C or page to the end.
Exit from "less" with "q".
</pre>

Note that to display several "-d" features at once, you add the numbers, i.e. to display the neural elements (the cell) and nodes, use "-d 1" and "-d 8", i.e. use "-d 9".<p>

<h3>Displaying nodes</h3>

To determine where to record or stimulate from a neuron it is often helpful to
display its node numbers. This allows you to accurately select a position in the
neuron.  To display the node numbers in the model, you can set which of the
node numbers to display using a template value for the "node_scale" parameter. The
template sets the node display format, i.e. which of the node numbers to display, and
the font size. For this template, 2 => the cell number, and 3 => the nodes within the
cell. When displaying the nodes from just one cell, it is helpful to display only the
nodes within the cell. However, when the model consists of many neurons, it is
helpful to display the cell number and the node within the cell.  
<p> 

You can also set the font size for the node number by taking a size in the range 0.1
- 5, dividing by 10, and adding this to the node number, then multiply by -1. For
example, for a display of the nodes in a cell with a small font, you can set the node
display cell_nscale to -3.05.  For a display of the cell number in an array of cells,
you can use -2.2. For a display of the cell number and node number for each node (2
numbers per node), use -6.05, and for a display of the cell type, cell number, and
node number (3 numbers per node), use -7.05. To not display nodes
on a cell type, use -9, either for node_scale or cell_nscale.  <p>

To set the node number and font size display for a cell type, set the variable
"cell_nscale" (cell = cell name, i.e. gca_nscale) with the display template number as
described above.  You can set this variable on the command line, or in the experiment
file in the "setparams()" procedure. To set the node displays for all the cell types,
use the variable "node_scale". If set, the "cell_nscale" variable overrides the
"node_scale" variable.  <p>


<p>
<h4>Displaying nodes in one type or cell</h4>

Often one wants to see the node numbers for only one type of cell, for example,
the cell number in an array of cells, or the nodes within one specific cell. To
do this, you can set "disp_ct" and "disp_cn".  If you set "disp_ct" the
simulator will only display cells that contain nodes of that cell type.  If you
also set "disp_cn" the simulator will display only the cell with that cell
number. Then you can set the overall node display, and also individually for each
cell type a separate node display:

<pre>
  retsim --expt gc_cbp_flash --node_scale -2.1 -d 9 -v | vid
  retsim --expt gc_cbp_flash --node_scale -2.1 --gcb_nscale -3.05 -d 9 -v | vid
</pre>

<h4>Displaying part of a cell set by Z distance</h4>

To display part of a cell distinguished by its Z distance, use the "disp_zmax" and "disp_zmin"
variables.  This displays only the parts of the cell between the values of these variables.

<pre>
retsim ... --disp_zmax -28 --disp_zmin -60
</pre>

To exclude part of a cell, reverse the values, i.e. make disp_zmax smaller than disp_zmin.

<pre>
retsim ... --disp_zmax -60 --disp_zmin -28
</pre>

Since disp_zmax and disp_zmin function for several cell types, it is useful to
have analogous variables for zmax and zmin for each cell type.  The dsgc is
bistratified so often just one of its dendritic arborizations is displayed. For
this specific purpose, use "disp_dsgc_zmax" and "disp_dsgc_zmin":

<pre>
retsim ... --disp_dsgc_zmax -28 --disp_dsgc_zmin -60
</pre>

<h4>Displaying part of a model set by Z distance</h4>

To limit the display of all the cells in a model to a range of Z distances, use the
"display_z()" procedure:

<pre>
display_z (max, min);
</pre>

<h4>Setting up an efficient programming environment</h4>

When running simulations it is helpful to open a "terminal" or "console" window
(say, on the left of the computer screen), and a programming (plain text)
editor window such as "vim", "gvim", "kwrite", or "gedit" (say, on the
right of the computer screen).  To run invididual simulations, you compose a
command line in the text editor, and then copy-and-paste it into the terminal
window, followed by &ltEnter&gt which runs the command.  This method makes it easy
to save all the command lines that you have run, along with comments that you
may want to save along with each command line. To make new command lines, you
can copy previous ones and change the parameter values for the new simulation.
Note that the editors listed above (vim, kwrite, gedit) keep a long line
formatted as one line so it can be copied and pasted into a terminal window.

<p>
Once you start running simulations, you will also need to view or edit the
nval_xxx.n, dens_xxx.n, and possibly the chanparams files in
nc/models/retsim/runconf. An excellent editor for opening multiple files is "kate"
(however it's not the best one to copy-and-paste). The nval.n file is large and you
may need to use a small font to readily see all the columns in the file (cell types). <p>

<br>

<h3><a name = "2.0">2. How to define an experiment</a></h3>
<p>
The retsim script is controlled by a set of variables that tell it which
neurons to create and how to connect them. The variables are read from the
default neuron parameter table, "nval.n", but are also set by an "experiment
file", and from the command line.

<p>
An experiment file (e.g. expt_gc_cbp_flash.cc) defines the experiment, with
statements to tell retsim which cells to include in the simulation, what
stimuli to run, and what plots to generate at runtime, and how to run the
experiment -- e.g. a series of voltage clamps. Retsim can then determine (from
nval.n) what synaptic connections and biophysical properties (from dens.n) the
cells should have. Then the retsim script automatically constructs the neural
circuit model, and returns control back to the experiment file, which runs the
experiment. The retsim script is designed to be run with many possible
different types of experiment. Many experiment files can be created to define
different neural circuits or different experiment protocols. 

<p>
In addition to defining the experiment, the experiment file often defines parameters
that allow the user to modify the details of the simulation, i.e. the biophysical
details of the neurons, their spacing, or synaptic connections, and the size,
frequency, or timing of a stimulus, or the exact form of the output plots. Although
it would be possible to make a new experiment file for each variation of parameters,
it is usually preferable to create one experiment file and vary it by selecting
appropriate values for its parameters.

<p>
An experiment file is written in the nc script language (see the Neuron-C
manual), and should contain the "defparams()", "setparams()", and "runexpt()"
procedures, as explained below.  The defparams() procedure defines parameters
whose values you will want to change on the command line. The setparams()
procedure sets the values of parameters, for example to control how the circuit
is constructed, or values to override those in the nval file.  The "runexpt()"
procedure sets up stimuli and plots, and runs the experiment using a "step" or
"run" statement. A good way to start would be to take an existing experiment,
e.g. "expt_gc_cbp_flash" or "expt_cbp_vclamp", and modify it to make a
different circuit and/or experiment.  

<p>
Neuron-C has both interpreted and compiled versions.  The original interpreter
"nc" is excellent for simple models that you may want to set up quickly, for
example, a simulation of one neuron or an array of one neuron type (see
"nc/models").  For multiple neurons of several types, the compiled version of
"retsim" is best. It allows you to quickly set up a neural circuit with
biophysical properties and synaptic connections and define an experiment to
run.

<p>
A compiled experiment file is written as a standard .cc file using a set of C
functions. It is then compiled and linked as a dynamically-linked library (in
linux, "file.so"). This allows the retsim script to select an experiment file
at runtime instead of requiring that retsim be linked separately with each
experiment file. A good way to set a new experiment file for compiling is to
look in the "makefile" and modify an existing entry for compiling and linking
an experment file. If you want to make a new experiment file, a good way is to
copy an existing experiment file and add the name of the new one to the
makefile, which will then allow "make" to compile it automatically. </p>

The compiled experiment file contains several user-defined procedures. Retsim
runs these procedures automatically at runtime: 

<p>
<pre>
defparams()   Add the definitions here for experimental parameters that will be set on the command line.
	      This is called before the nval.n parameter file is read,
              so you can set a different nval file name here, or on
	      the command line. Also called before the "setvar()" 
              procedure sets variables from the command line. 

[Retsim sets the variables from the command line, then reads in the nval.n file]

setparams()   Sets variables controlling construction of the circuit
              after the neuron parameter (nval) file has been read.
	      Called after defparams(), but before the density files
	      are read, and before construction of the neural circuit.

[Retsim reads in the dens.n files, one (or maybe 2) for each cell type]

setdens()     Sets neuron parameters and variables that modify the 
	      channel densities after they have been read from the 
	      density files. Called after densities have been read in, 
              but before construction of the neurons and the circuit.
              Optional.

[Retsim makes the cells and constructs the circuit.]

addcells()    Allows the user to add cells not defined in the nval file. Optional.

[Retsim makes the connections between the cells, and removes cells not connected]

addlabels()   Allows the user to define node labels using "label()" for display.
	      See ncfuncs.cc,h. Optional.

[Retsim displays the model if requested (with -d xx)]

runexpt()     Runs the experiment. Make final changes to the model, sets stimuli and plots,
              and defines and runs the experimental protocol.
              Called after circuit is constructed.

[Names of these user-defined procedures are set in "setexpt.cc. These procedures are called
in retsim.cc.]

</pre>

<br>

The defparams procedure defines user-changeable parameters needed by the experiment.
It is run before "setvar()" (which defines the parameters from the command line). <p>

<pre>
void defparams(void)
{
  setptr("temp_freq", &temp_freq);
  setptr("ntrials",   &ntrials);
  setptr("dstim",     &dstim);
  setptr("sdia",      &sdia);
  setptr("stimtime",  &stimtime);
  setptr("minten",    &minten);
  setptr("scontrast", &scontrast);
}
</pre>

<br>

The setparams procedure sets parameters needed for construction of the circuit.
It also allows setting parameters for the density file.<p>

<pre>
void setparams(void)
{
  make_rods = 0;
  make_cones= 1;        /* make cones, cbp, gc */
  make_ha   = 0;
  make_hb   = 0;
  make_cbp  = 1;
  make_gc   = 1;
  DEND      = R_2;      /* set DEND region for density file to be region 2 */
  if (notinit(bg_inten)) bg_inten = 2.0e4;      /* background light intensity */
}
</pre>

<br>

The setdens procedure allows the user to modify channel densities read from the 
density files before the neurons are constructed. <p>

<pre>
void setdens(void)
{
  if (!notinit(cone_cond)) setval(xcone,SCOND5,cone_cond);		// override synaptic val
  if (!notinit(ca_cond)) celdens[cone][_CA][R_AXON] bg_inten = ca_cond; // override Ca density, S/m2

  // In some cases, it's helpful to have 2 density files for one cell type.
  // This allows one cell to have biophysical parameters such as channels,
  //   and the other cell to have a different combination of densities, for example, none.
  // This is useful when subtracting the voltage-clamp currents to 
  //   remove the effect of capacitance.
  // The ndens[][] array sets which density file to use for each cell.

  ndens[dbp1][cn=1] = 0;              // set cn 1 to use dbp1_densfile
  ndens[dbp1][cn=2] = 1;              // set cn 2 to use dbp1_densfile2
}
</pre>

The addcells() procedure allows the user to add cells that are not defined in the nval file,
before the experiment is run.<p>

<pre>
void addcells(void)
{
  if (set_amx) make_amx();		// make a new amacrine cell type 
}
</pre>

<br>

The runexpt() procedure sets up the experiment stimuli and plots, and runs the
experiment using "step()" or "run()". It is run after the neural circuit is
constructed. However one can add neurons or transduction elements before the
first "step()" statement. <p>

The "runexpt()" procedure can include a "for" statement to run an experiment
iteratively (see the Neuron-C manual, and "Running a voltage clamp protocol"
below).  Typically, a stimulus is generated, and the "step()" procedure is
called to run the simulation forward in time. Then inside the loop, the
stimulus is run again, possibly with a small variation, e.g. a different clamp
voltage for a voltage clamp, and the step procedure is run again.  Alternately,
all the stimuli can be defined before the experiment runs.  <p>

<pre>
void runexpt(void)
{
    double temp_freq, dtrial;
    double Vmin, Vmax;

  if (notinit(ntrials))     ntrials = 1;       /* stimulus repeats */
  if (notinit(stimtime))   stimtime = .10;       /* stimulus time */
  if (notinit(minten))       minten = bg_inten;  /* background intensity (for make cone)*/
  if (notinit(scontrast)) scontrast = .5;        /* intensity increment */
  if (notinit(temp_freq)) temp_freq = 2;

  dtrial = 1 / temp_freq;
  exptdur = dtrial * ntrials;

  plot_v_nod(ct=xcone,cn=midcone,n=soma,Vmin=-.037,Vmax =-.027,colr=cyan,"", -1, -1); /* plot Vcones*/
  stim_spot(sdia, 0, 0, minten*scontrast, start=t+stimtime,dur=dstim);
  step(dtrial);
}
</pre>

<h3><a name = "2.5">2.5 How to develop a model in retsim</a></h3>

It's an interactive, iterative process.  Start by going to the section in the
Neuron-C manual "Constructing neural circuits", then read the subsection "Model
design philosophy". Start with the simplest model -- this will run the fastest.
Add only the amount of complexity that you can relate to the real data you are
trying to match.  It's good to limit the number of "free" parameters so you
don't get lost in parameter space.  <p>

<h4> Scientific questions </h4>

An important consideration when constructing models of electrophysiology or
imaging of real neurons is the scientific question.  This will direct the
interaction between theory and experiment. In one paradigm, you can attempt to
match the model to the original electrophysiological data and make predictions
about the circuit's function. The model can plot out parameters that are not
available in the real data. These predictions are hypotheses about how the real
circuit would work if it contained all the elements of the model. These
hypotheses can then be tested in further rounds of electrophyiological
experiments, and may suggest different recording methods, protocols, or
hypotheses. In this paradigm, the model cannot prove a hypothesis, because the
model may not contain all the mechanisms in the real circuit. <p>

However, another modeling paradigm tests an existing hypothesis suggested by
real recordings. If the model fails or cannot approximate the real data even
with revisions, this suggests that the hypothesis, to the extent it is
incorporated in the model, is false. To elminate a hypothesis when testing
several is helpful in modifying or creating new hypotheses.   <p>

In a typical biophysically-based model using retsim, you start with the
morphology and basic synaptic connectivity along with a stimulus. From there,
you can go several directions, depending on your scientific question. If your
question is very specific, for example "What is the dendritic (or axonal)
interaction between different currents (e.g.  excitation and inhibition, etc)?"
you may want to get estimates for the biophysical parameters Ri, Rm, Cm (and
maybe a diameter factor). This will allow you to determine the interactions
between currents in the peripheral dendrites that are not visible in somatic
voltage clamp.  <p>

For higher level scientific questions, such as "How does the circuit work, i.e.
how does it do what we know it does?", you first need to work on getting it
approximately calibrated to give correct responses to the relevant stimuli.  You
can chose light stimuli, or go with electrodes that maintain voltage or current
clamps.  If you will want to match real data, you'll have to start by matching
the stimuli that evoked the real responses. You'll also need to set up plots of
relevant parameters in the model circuit, for example, the voltage at different
points within a cell's dendritic arbor, currents from voltage clamps, or
neurotransmitter released by a neuron's synapses. Then you modify the circuit,
e.g. the synaptic or voltage-gated membrane conductances, and maybe the synaptic
placement, and see how this affects the output signals.  This will give
intuition about how the specific microcircuit properties accomplish its signal
processing.  <p>

For "What does the circuit do given a specific type of stimulus?" or "What
stimulus gives the best signal?" you calibrate the model, then apply different
stimuli to see which responses have the maximum SNR.  If you want to know
which stimulus is best, you can apply the output of the model to an "ideal
observer", which compares the responses to 2 stimuli and determines the minimum
discriminable change in the stimulus. This defines the SNR of the system. Then
change the model and see how this changes which stimulus has the best SNR. You
can measure SNR of a real cell(s) or a model with an ideal observer
("discriminator") program (see Smith and Dhingra, 2009).  <p>


<h4>Calibrating the model </h4>

In order to calibrate ("tune") the model, you need to match the model's output
to some real data. You can calibrate for a good match by least-squares fitting
(see "Curve Fitting with NeuronC"), or by manually bracketing several parameters
to give intuition. In the absence of responses evoked by light, a widely used
data type is somatic voltage clamp currents. Light responses usually require a
more complex model to correctly simulate contrast sensitivity and temporal
properties of photoreceptors.  To avoid using photoreceptors, you can use
"transducers" which voltage clamp a neuron to the voltage implied by the light
intensity.<p>

The output signal of the real cell may not be directly related to the real data
you attempt to match, because real data is often taken by an electrode or by
imaging calcium. These real data are very helpful, and can be targeted for
matching by the model -- but are not necessarily the signal transmitted to the
next neuron in the pathway. However, then the model can tell you what the real
output of the cell would be (i.e. if you could measure it). Imaging glutamate
is closer to the real output of the cell but has other issues, such as, how
many cells does the glutamate come from, or what portion of the glutamate does
the postsynaptic cell respond to?
<p>

<h4> Membrane parameters </h4>

Often one sets Ri and Rm simply by bracketing them and looking at the results
given a stimulus that decays electrotonically along the cell dendrites (or
axon).  This can give an approximate set of values.  Start with Ri = 50-200,
and Rm = 10,000 - 50,000. (nc default: Ri=200, Rm=40e3, Cm=1e-6 F/cm2).<p>

In the Stincic et al (2016) paper on the starburst amacrine, the real data were
obtained from voltage-clamp at the soma, leading to space-clamp issues in the
peripheral dendrites. Given the currents from the voltage clamp, least-squares
fitting models were run to determine for each specific cell morphology the best
fitting values for Ri, Rm, Cm, dend dia, and Rs (electrode resistance). These
models were run without a light stimulus, only using a voltage clamp protocol (5
mV step, fitting the charging current curve). After that, the light responses
were fitted, which allowed determining the synaptic conductances.  The fits were
done with the "lmfit" procedures (nc/src/lm_*.cc), called from the "modelfit.cc"
program, run by different perl scripts. <p>

When fitting a model to real data, it helps to have only a few free parameters,
for example 4 to 6. Although more parameters can be well-fit using least-squares
methods, in a biophysically-based model such as retsim, the parameters are
often correlated (e.g. Rm, Cm, and dendrite diameter), so that an increase in one
parameter can be compensated for by a decrease in another.  This causes the fit
to be non-unique, i.e. many combinations of parameters appear to fit the data
equally well. To prevent this type of ambiguity, it helps to have constraints
on your free parameters, so that their values are limited to a fairly narrow
range.  <p>

Voltage clamp is widely used to determine dendritic conductances (see Taylor and
Vaney, 2002), but when the dendrites or axon are long, the space clamp issue
limits the accuracy. The model in the Stincic (2016) paper side-steps that
problem because the it contains the biophysical parameters that generate the
electrotonic decay that cause the space-clamp problem. Once calibrated (Ri, Rm,
Cm, dend dia, Rs, etc), and the model currents measured at the soma are fitted to
the real data, the model's synaptic currents and conductances can be readily
plotted. <p>

<h4> Synapses </h4>

A retinal synapse normally has between 5 and 20 channels, each with a
conductance of ~20-100 pS.  A good starting conductance value is 100-400 pS per
synapse (i.e. when maximally activated).  The timing can be fast or very slow --
this can be set with the second or third temporal filter in the nc synapse. The
locations of synapses are often found using electron microscopy that shows the
presynaptic and postsynaptic densities (mechanisms). <p>

Although nc can implement generic postsynaptic channels, often one wants to
use the Markov state-machine channels (AMPA, AMPA5, NMDA, GABA, etc). These have
more realistic temporal and noise properties.  Start calibrating the model
without vesicle or channel noise, then add noise to see how it affects the
operation of the circuit, and to check the signal-to-noise ratio (SNR) of the
output. <p>

For the most realistic synapse, use Ca channels in the presynaptic compartment.
For this to work, the node where the presynaptic part of the synapse is located
must contain Ca channels and the SENSCA parameter in the nval*.n file must be
set to 1 (see description of the "nval.n" below). 
<p>

If you don't need the complexity of a rise in [Ca]i driving release, leave out
Ca channels and don't use SENSCA. Then the synapses can be driven by the
presynaptic voltage drive release. <p>

When Ca sensitivity is not set, the release of vesicles is modeled by either a
linear or an exponential function. The exponential function is more realistic,
and doesn't have a sharp cutoff at more hyperpolarized voltages.  The slope of
the exponential function is set in units of mv/e-fold change, normally set
between 1 and 4.  This is fairly well described in the nc manual under "Synapse
Statement".  In "retsim" the exponential gain is "SGAIN", but when you set
"SENSCA", the exponential gain is not used, since the [Ca]i is set by calcium
channels. <p>

If you know what type of synapses to include in the model, it's usually fairly
easy to set them up. If you don't know precisely what type of synapses, you can
start out with basic excitatory (AMPA) or inhibitory (GABA) postsynaptic
receptors.  But then the question is, where are they located?  If you know the
precise position, you can then start bracketing the conductance of the synapses
to give the responses that you want. If you don't know exactly where to put
them, try different locations and see how these affect the function and output
of the model. You may then want to go back to modify the temporal filters in
the synapses to set fast or slow rise and fall times. <p>

To get 2 cells to be connected by more than one synapse, there is a way to set
the synaptic spacing on the presynaptic cell, and then the synapse can connect
to the postsynaptic cell given the pre-post distance is within a criterion (in
the retsim/runconf/nval*.n file).  <p>

To adjust the amount of neurotransmitter released, in a generic synapse you can
change the gain (in nvalxxx.n, SGAIN) or threshold (STHRESH) for synaptic
release. In a synapse driven by calcium from a calcium channel, you can change
the calcium channel density, its conductance, or you can shift its voltage
activation curve (in chanparams, see below). To scale the synaptic output,
you can change the postsynaptic conductance.<p>

<h4>Voltage gated channels</h4>

Voltage-gated channels are a bit more challenging, as it's usually more
difficult to localize them -- that usually requires a specific antibody for
the channel (which is quite often available).  If you don't know where the
channels are (the usual case) you have to guess and try to limit the
conductance range and the region where they're located (specified in
retsim/runconf/dens*.n). <p>

For example, in Puthussery et al (2013), modeling a primate bipolar cell, we
knew approximately where the Na and Ca channels were, but not the K channels.
At first, we placed the K channels near the Na channels in the axon terminal,
but found that given the K conductance measured at the soma, the axial
resistance of the axon limited the conductance too much -- it was impossible
to get the K currents large enough.  So we had to move the K channels closer to
the soma.  That helped the model work much better. Then to get the model to
duplicate the Na spikes seen in voltage clamp, it was just a matter of finding
the Na conductance density and axonal Ri -- which we did by bracketing. We
omitted feedback inhibition from amacrine cells to the bipolar cell axon. <p>

There are some generally accepted densities for membrane channels -- see our
paper Van Rossum et al (2003).  For ganglion cells the spike generator can be
set up in the soma with a medium density of Na channels (80-150 mS/cm2) or in
the thin segment of the axon with a very high density (300-1000 mS/cm2).  The
real cell has Na channels in the soma, but spikes start in the thin segment.
The Kdr channel density is usually 10% - 25% of the Na channel density. KA, KCa,
and Ca channels are usually present in the spike generator at a much lower
density (0.01 - 5 mS/cm2). Other types of neurons such as amarine cells, also
generate spikes but may have lower Na and K densities. Some types of bipolar
cell also contain sodium channels and can generate spikes, though they are
generally electrotonically compact enough not to need spikes for signal
transmission.<p>

In a bipolar cell, each synapse must have Ca channels to activate release.
This can be simulated using the "SENSCA" parameter in nval*.n. The Ca channel
density in the presynaptic terminal is often set at first to ~ 0.5 - 2 mS/cm2.
The [Ca]i (internal Ca level) should rest at 20-100 nM, and during synaptic
vesicle release should transiently rise to 5-30 uM, with a Ca pump that brings
[Ca] down within 50-200 ms. <p>

<h4>Including Noise</h4>

An important part of a neural circuit's signal processing is the effect of
noise, either generated externally (as in photon noise) or internally by the
neural circuit. In most cases noise is detrimental to the signal processing
performed by a circuit, but in some cases it is helpful. A major reason for the
existence of the vertebrate retina is due to the presence of biolgically
generated noise, for without noise the photoreceptors could directly generate
the signals sent through the optic nerve to the brain. The retina's three
complex layers are necessary to separate and amplify different types of signals
so that when they invariably get mixed with noise in downstream circuitry, the
filtered and amplified signal still has an adequate SNR that will allow the
brain to make use of it. <p>

Although a retsim model can include several sources of noise, it's usually best
to start developing a retsim model without including any noise sources, because
this simplifies understanding the signal processing it performs. Physiologists
often average several recordings of a response to lessen the noise, but in
modeling work, it is easy to start without any noise. The most important noise
source in a neural circuit is usually synaptic noise, i.e.  fluctuation in the
timing of quantal vesicle release (in nvalxxx.n, set by SVNOISE). Several other
noise sources are provided by the simulator, including fluctuation in vesicle
size, thermal Johnson noise, stochastic gating of postsynaptic channels (in
nvalxxx.n, set by SCNOISE), and stochastic activation / inactivation of
voltage-gated channels. A synapse usually has just a few postsynaptic channels
(often not more than 20-50 per synapse), so the binding of neurotransmitter to
open (or close) a channel is relatively noisy. However, since one vesicle can
gate many channels, vesicle release noise is usually greater than postsynaptic
channe noise (see van Rossum et al., 2003).  <p>

When you add noise to an existing retsim model, the noise will most likely
change the function of the model, in some cases, by a large amount. Synaptic
vesicle noise will saturate at the postsynaptic receptor differently than
non-noisy transmitter release. Voltage-gated channels are gated differently by
a fast-changing noisy membrane potential than a slow-changing membrane
potential, because their gating is transient like a high-pass filter.  Noise
can also help to linearize a circuit with a nonlinear threshold (e.g. nonlinear
synaptic release or channel activation), because even when the average signal
is below the threshold, noise peaks will rise above threshold and activate the
output.  Noise in ganglion cells can prevent their spike trains when summed in
a cortical cell from generating aliased signals (i.e. beats between close
frequencies) <p>

To increase the SNR of a synapse with vesicle release noise, you can increase
the release rate, possibly reducing the vesicle size (in nvalxxx.n, SVSIZ). In
fact, if you reduce the vesicle size, the synapse will automatically increase
the vesicle release rate to keep the amount of neurotransmitter constant. You
can also vary the transmitter concentration at the postsynaptic receptor (in
nvalxxx.n, STRCONC) to maintain the same average neurotransmitter concentration
with different average rates of release. You can vary the randomness of
vesicle release with the "vcov" parameter (default=1 in retsim), which sets the
release by a gamma distribution instead of a Poisson distribution (see Synapses
in nc manual). You can also vary the randomness of release with the "refr"
paramter which sets a refractory period between vesicles released at a release
site. It is widely assumed, however, that vesicle release is Poisson (random),
modulated by voltage through calcium.
<p>

Noise is essential in a retsim circuit that you will use to determine SNR and
discrimination thresholds. Although photon noise is widely used in "ideal
observer" models, and is the largest source of noise at twilight and night, in
daylight photon noise is much less, because the photon count is much greater.
The noise is proportional to the square root of the mean intensity (or mean
release rate). In most cases, photon or other external sensory noise is mixed
with biologically generated noise (usually synaptic noise) so the SNR of a
signal is the result of a complex mixture of noise sources.  Therefore it's
essential to set up synapses with realistic release rates, often between 10/s -
100/s in retinal circuits. In brain circuits the release rate may be much
lower, activated by presynaptic spikes.
<p>

You can plot the vesicle release rate of a synapse by plotting the FA9
parameter (the output of the first temporal filter), and to see the vesicles
and their waveshape, you can plot the FB4 parameter (the output of the second
temporal filter). You an generate these plots with the "plot_synrate()"
procedure (in "plot_funcs.cc").
<p>

The number of calcium channels that can drive release at a synapse is usually
quite small, in the range of 5-20, so in a synapse that you set up to be driven
by calcium, the noise from the small number of channels can have a large effect on
the timing of vesicle release.

<p>

<h4>Setting up an experiment</h4>

It's important not to get too many versions of an experiment or the parameter
files (nval*.n, dens*.n, chanparams, see descriptions below). If you make
changes in these files you may lose track of what models ran with which
changes. To make it easier to keep track, you can make copies of the files and
change their name, but once you get 5 or more files, that are similar and
typically differ by only a few minor changes, it becomes very difficult to keep
track of all the file names.  You should save all the command lines you use in
a text file so you can refer to or re-run them if necessary. <p>

To avoid the problem of many file names, try to make one version of each file
that best fits what you're doing. (You can save old versions by including a
date in the file name, but avoid using these old versions except to compare with
"diff"). Then try to include in the experiment file definitions for all the
parameters you'll need to modify. You can then run the same experiment file
with different parameter sets from a script (batch) file using different
command lines. <p>

In setting up an experiment in retsim, think carefully about which parameters
you will need to change from the command line.  Add the parameter definitions
at the top of the file, then add the initialization of the symbol table in the
"defparams()" procedure. You can see how this is done in the
nc/models/retsim/expt*.cc files. <p>

There are 2 ways to set individual parameters read in from an nval file
(described in "the nval.n" file below). You can override the nval parameters by
overriding their values in memory in the "setparams()" procedure using the
"setn()" procedure.  The nval file is read in after defparams() but before
setparams() (take a look at retsim.cc to understand how this works). A second
way is to replace the numeric value in the nval file with a variable name. This
variable can then be defined and set in the experiment file -- in defparams(),
before the nval file is read in.   <p>

You can then arrange to have the values overriding the nval file (with either
method above) set on the command line, so that you can readily run the model
with different parameter values.  This will inevitably require changing the
experiment file when you need to add new parameters that you didn't plan on --
so save the old one with a date in the file name, and move on to the new one
that has additional parameters that you can change from the command line. <p>

If you end up with an experiment file that's too complicated, i.e. there are
too many parameters (e.g. different stimuli, several experimental paradigms,
alternate plots, etc.) you may want to split it into 2 or more separate
experiment files -- as long as the experiments are identifiably different and
easy to remember. <p>

<h4>Adding new parameters, default values </h4>

It's helpful to think ahead and try to define any parameters that you will need
to modify in the development of your model. For example, a sine-wave grating
will need contrast, spatial period, drift frequency, etc., even though you might
not need to vary these at first. You may need to add a current clamp or voltage
clamp to an existing model, but have it default to the original model without
these additions. In a typical model, you may need to add dozens of unanticipated
parameters.  <p>

The rule for adding parameters is, feel free to add new parameters as long as
they don't change the models and command lines that you have already run. That
way, you can always go back and check your work by running the previous command
lines, then varying the new parameters to see if everything is working
correctly.  This is very important, because a model is only as good as your
understanding of it, and you will need to check your model to understand whether
it is correct. <p>

To add new parameters to an existing experiment, you define the new parameters
in the experiment file, initialize them in "defparams()", and set their values
to appropriate defaults that keep the model functioning as it did previously
before the parameter was added.  You can set default values in several ways: you
can set the parameter/variable to the default value before the command line is
read in, i.e. you set the parameter in "defparms()".  Or you can test whether
the parameter has been initialized (with "notinit()", and if it hasn't you can
set its default value, anywhere in "setparams()", "setdens()", or "runexpt()".
When a parameter is set ("initialized") either on the command line, elsewhere in
the experiment file or in retsim, the "notinit()" function returns 0, but when
the parameter hasn't been initialized, "notinit()" returns a 1, allowing an "if"
statement to set the default value. This allows you to add a new parameter that
is ignored until activated by changing its value. <p>


<h4>Perl, awk, nc scripts</h4>

When running retsim models with different sets of parameters, it is often useful
to use a high level script language (e.g. perl, python, awk, or even "nc").  A
script with 2-4 nested "for" loops is an easy way to bracket parameter values.
The high level script can read in parameter values from the command line, and
then generate a command line for retsim.  This is very helpful when running many
models in parallel (using "&amp;" after the command).  "Mosix", a parallel job
system, can help to run 50-100 models in parallel on several multi-core
machines.  When running many models from a high level script, it's important to
keep their file names different.  One way to do this is to generate a file name
in the script that includes the model's parameter values. <p>

You can use Neuron-C to write a script similar to a perl script. For example,
the neuroman2nc script that converts Neuromantic format to Neuron-C format (see
below) is available in perl, awk, and nc versions. By comparing these scripts
you can learn how to use these script languages.
<p>

<h3><a name = "3">3. Generating cell morphologies</a></h3>

To construct a cell with realistic morphology, you can define it with a morphology file:
<p>
1) A cell can be digitized from a photograph or an aligned stack of images. The
information is placed into a text file, organized by points, called "nodes", that
describe the locations of soma, axon, and dendrites and their branch-points. Each
node connects with a cable to its "parent" node, and this information is listed in
the file, along with the cable diameter, (x,y,z) location, and the "region", used for
supplying biophysical properties:

<pre>
-----------------------start of morphology file---------------------
#
#  beta cell morphology file,  2006 Oct 4
#
#    node     parent   dia     xbio     ybio    zbio   region      dendr
#
       0        0      21      0        0       -25  SOMA        0
       1        0      2.17    21      -2.47    -8   DEND_PROX   1
       2        1      0.833   22.8     0.0287  -5   DEND_DIST   1
       3        2      1.33    23.3     0.776    0   DEND_DIST   1
       4        0      0.5     13.9    -6.32     0   DEND_DIST   2
       5        0      1.5    -3.25    -33.6   -30   HILLOCK     0
       6        5      0.5    -6.81    -37.6   -30   AXON_THIN   0
       7        6      0.5    -25.5    -66.4   -30   AXON_THIN   0
       8        7      0.5    -121.2   -160.2  -30   AXON_PROX   0
</pre>
Note that the soma has itself as its parent.
<p>

The variables "SOMA", "DEND_PROX", "DEND_DIST", etc. are labels for the regions
within the cell.  These labels are variables defined in retsim_var.cc.  You may
change the values of these variables, and you may add your own additional ones
in the morphology file. You may also use another set of labels, "R1", "R2",
"R3", etc.  that are predefined in retsim_var.cc. These regions, defined by
either set of labels, are for use in the "dens_xxx.n" file (see below), where
each column defines the density of channels and other values such as Rm, Ri,
complam, and color for that cell region.<p>

The "dendr" column defines dendrite numbers to be utilized for selectively
constructing dendrites. If any of the command-line variables "sbac_dend1,sbac_dend2
... sbac_dend5" are set, the dendrites with these numbers will be constructed from
the morphology file, and other dendrites will not be constructed. If in addition the
"sbac_dend_cplam" variable is set, the other dendrites (not set in sbac_dend1-5) that
would have not been constructed are now constructed with compartment size set by
sbac_dend_cplam. This arrangement is useful for constructing a model with just one or
a few dendrites included with small compartments for high resolution, and all the
other with large compartments, to minimize the number of total compartments. Other
variables gc_dend1-5 and aii_dend1-5 are also defined for use with these cell types.
<p>

<h4>Using labels in the morphology file</h4>

The "dendr" column can also contain labels that are shared with different cells
in different morphology files. To find a specific node corresponding to the label,
you can call the "dendn_node(int ct, int label)" function which returns the node number from the row
in the morphology file corresponding to the label.
<p>

<h4>Orientation of digized neurons</h4>

The standard orientation of a morphology file is looking at a radial view, i.e.
photoreceptors have a more positive Z axis location, and ganglion cells have a more
negative Z axis location.  If you are reconstructing from a stack of images taken from
a radial section, you may need to swap the Y and Z axes. This can be readily
accomplished in the conversion process to a retsim morphology file.

<h4>Digizing neurons with Neuromantic</h4>

An easy way to convert neural morphologies from a confocal stack is to use the
Neuromantic program, which is available free to download from the web. To learn how
to use Neuromantic, you can download training videos from the web site. You can
then convert from Neuromantic format (.swc) to a retsim morphology file using
"neuroman2nc", which is a script in perl for Linux. You can find this
script in "nc/models/retsim/runconf". A related command "set_morph_file_reg" sets the
regions in the morphology by the distance from the soma. This can be useful for
setting regions of a dendritic or axonal arbor from their radial distance from the
soma.<p>

Depending on the orientation of the stack, you may need to swap the ybio and zbio
columns. You can readily do this by editing the neuroman2nc command.<p>

The scale factors for the "neuroman2nc" command are set by default to 1. However,
usually the number of microns per pixel differs from 1, so you can set the scale
factors from the command line:

<pre>
neuroman2nc cell_file.swc > morph_cell_file
neuroman2nc --xyscale 0.0495 --zscale 0.05 cell_file.swc > morph_cell_file
</pre>

<h4>Digizing neurons with Xfig</h4>

You can digitize manually using a photograph or drawing imported into
"xfig" (illustrator program in Linux). You digitize a cell's
morphology to label its nodes with numbers 
(see <a href="ncman3.html#5"> Constructing Neural Circuits->Digitizing cell morphologies"</a>).
You manually enter the labels for each node. Xfig will then
remember their (x,y) positions. Save the .fig file, convert
to retsim format (above) using "fig2nc", then use a text editor
to set the correct parent nodes and add the diameters.  You can find
fig2nc in "nc/models/retsim/runconf".

<p>
<h4>Digizing neurons with IJ-MorphDig</h4>

IJ-MorphDig is a Java plugin for ImageJ, an image-processor
program. You can import a stack of confocal images, then place
node points, along with their diameters measured with a "caliper
tool". MorphDig outputs the data in the Neuron-C standard
morphology format (above). You can find the IJ-MorphDig package
in "nc/models/retsim/runconf".

<p>

<h4>Digizing neurons with NeuroLucida</h4>

You can convert neural morphologies from NeuroLucida format using
"dsconv2", which is a script in bash/gawk for Linux.  You can
find this script in "nc/models/ds/ds3".


<h4>Artificial morphology from parameters</h4>

You can generate an artificial morphology by algorithm (in
"retsim/makcel.cc"), based on the number of primary dendrites,
dendritic field extent, and branching pattern.  Quite realistic
morphologies can be generated for horizontal cells and some types of
amacrine and ganglion cells.

<p>

<h4>Artificial morphology from connection algorithm</h4>

An artificial morphology can be generated by the connection
algorithm. A "skeleton" of the cell consisting of the soma and
proximal dendrites is created at the appropriate location (see
"Making arrays of neurons" above) and the dendrites or axon
(where applicable) are extended to the closest branch of the
nearest neuron of the other type. For example, photoreceptors
connect to horizontal cells by extending the horizontal cell
dendrites.  This algorithm is performed sequentially over all the
photoreceptors, at random using a Gaussian probability profile,
so that relatively random branches are generated for the first
several photoreceptors, which generates a relatively realistic
branching pattern.

<h4>Changing scale of a morphology file</h4>

Often a cell morphology is generated from a bitmapped image with a scale in pixels.
Once you know the scale factor (um per pixel) you can re-scale the morphology file
using the command "scale_morph_file" in the folder "nc/models/retsim/runconf". You
can re-scale the diameter, xbio, ybio, and zbio columns with "diascale", "xscale",
"yscale", "zscale", or using "xyzscale" (sets x,y,z scales), or "xyscale" (sets x,y
scales). This scale_morph_file command multiplies the scale factors you set in the
command line by the original numbers and outputs the result:

<pre>
scale_morph_file --xscale 12.5 --yscale 12.5             morph_xxx > morph_xxx_scaled
scale_morph_file --xscale 12.5 --yscale 12.5 --zscale 10 morph_xxx > morph_xxx_scaled
scale_morph_file --xyscale 12.5                          morph_xxx > morph_xxx_scaled  # sets x,yscale, leaves zscale
scale_morph_file --xyzscale 12.5                         morph_xxx > morph_xxx_scaled  # sets x,y,zscale
</pre>

<h4>Setting the regions in a morphology file</h4>

The morphology file defines the regions of the cell so they can be given
different biophysical and synaptic connection properties.  The regions are
defined as integer variables in "retsim_var.cc" and serve to index the columns
of the density file ("runconf/dens_xxx.n").  The "neuroman2nc" command sets the
regions "SOMA", "DEND", and "AXON", but you may want to redefine them using
these regions:

<pre>
SOMA
DEND
DEND_PROX, DENDP
DEND_MED,  DENDM
DEND_DIST, DENDD
HILLOCK, HCK
AXON
AXON_THIN, AXONT
AXON_PROX, AXONP
AXON_DIST, AXOND
VARICOS, VARIC
</pre>

Alternately, you can also use these regions:<p>

<pre>
R1,R2,R3,R4,R5,R6,R7,R8,R9,R10
</pre>
This "R" region set is useful, for example, to label radial regions by distance (see below).<p>

You may also mix the 2 above sets of regions. As variables they are given
different integer values. If you prefer, you can define another set of regions
as integer variables and use them in the morphology file and the density file.<p>

<h4>Setting radial regions in a morphology file</h4>

Sometimes it is helpful to define the regions in the morphology file as the
radial distance from the soma, i.e. the proximal region is "R1", the next is
"R2", and so on. You can use the "set_morph_file_reg" command to set the
regions. The variable "radincr" sets the radial size of the regions:

<pre>
set_morph_file_reg --radincr 15 morph_xxx > morph_xxx_regions
</pre>

Another version, useful for bipolar cells with dendrites that stick out in one direction and an axon that sticks out in the oppositie direction, allows different region sizes for dendrites and axon:

<pre>
set_morph_file_reg_ax --dendincr 10 --axincr 15 morph_xxx > morph_xxx_regions
</pre>

You can also set the scales in this operation:<p>

<pre>
set_morph_file_reg --dendincr 10 --axincr 15 --xyscale 1.5 --zscale 0.6 morph_xxx > morph_xxx_regions
</pre>

<h4>Other useful commands for modifying morphology files</h4>

The "center_soma" command moves the cell so its soma (normally node 0 on the first line) is located at (0,0,0). This allows "retsim" to make the cell correctly to a specific location. 

<p>

<h4>Creating an extended soma</h4>

Some neurons have an extended soma that looks like a tapered cylinder
("cable"). This may still function to some extent as an isopotential
compartment, i.e. like a sphere, but you may want to capture the extended
cylinder nature of the soma while preserving its location at a specific point,
normally (0,0,0). To do this, label all the soma nodes as "SOMA" in the region
column.  They should have parent nodes that point towards the soma center.
Then label the soma center, which must be the first line in the morphology
file, with "PSOMA". This means a soma with a point location but no biophyical
properties. The PSOMA node can have a diameter but this is ignored. Its parent
should be one of the other nodes. The reason is that a node with a parent of
itself generates a sphere. To make the tapered cylinders line up correctly,
their (X,Y) locations should be identical (i.e. a vertical tapered soma) or
linearly displaced proportionate to their Z distances (tilted tapered soma).

<pre>
-----------------------start of morphology file---------------------
#
#    node     parent   dia     xbio     ybio    zbio  region     dendr
#
       0        1      10      0        0        0    PSOMA       0
       1        0      8       0        0        2    SOMA        0
       2        1      2       0        0        4    SOMA        0
       3        2      1.33    23       0.7      0    DEND_DIST   0
       4        0      0.5     13      -6.3      0    DEND_DIST   0
       5        0      7.5     0        0       -3    SOMA        0
       6        5      3       0        0       -6    SOMA        0
       7        6      1.5    20        0       -10   AXON        0
</pre>

<h4>Setting variables in a morphology file</h4>

You can set any value in a morphology file (or nval file, or density file) to a
variable (i.e. a char string starting with a letter). This can be used, for
example, to set the diameters of some or all the nodes in the morphology file
to a preset value. You must then define the variable in the experiment file,
and then can set its value in the retsim command line:

<pre>
#    node     parent   dia      xbio     ybio    zbio   region      dendr
#
       0        0  SomaDia        0        0      -25   SOMA        0  # soma is variable diameter
       1        0     2.17       21    -2.47       -8   DEND_PROX   1
       2        1    0.833     22.8   0.0287       -5   DEND_DIST   1
       3        2     1.33     23.3    0.776        0   DEND_DIST   1
</pre>
Then, define SomaDia in the experiment file:

<pre>
double SomaDia;
...

void defparams(void)
{
   setptr("SomaDia", &SomaDia);
   ...
}

void setparams(void)
{
   if (notinit(SomaDia) SomaDia = 10;		# default value
   ...
}
</pre>

Then you run retsim like this:<p>

<pre>
retsim --expt gc_cbp_flash ----gca_file morph_morph_beta8b --SomaDia 11  ...
</pre>

Sometimes it is helpful to set all the dendrite diameters in a morphology file to a variable, for example, "dend_dia". This is useful when you don't have accurate diameter information and want to bracket the diameter values. You must define this variable in the experiment file as explained above. <p>

<pre>
retsim --expt gc_cbp_flash ----gca_file morph_morph_beta8b --SomaDia 11 --dend_dia 1.5...
</pre>

Note that the "scale_morph_file" and "set_morph_file_reg_ax" commands will preserve any variable names in the "dia" column (col 3) in the morphology file if you don't set "diascale".<p>

<h4>Setting a diameter multipication factor</h4>

Sometimes it is helpful to use the realistic morphology, but bracket the diameters of the dendrites when they cannot be precisely measured from the original images. You can do this at runtime by setting the predefined variables (see celseg.cc):

<pre>
dend_dia_factor      // dendrite dia multiplier factor
dendp_dia_factor     // proximal dendrite dia multiplier factor
dendd_dia_factor     // distal dendrite dia multiplier factor
ax_dia_factor        // axon dia multiplier factor
cell_dia_factor      // cell dia multiplier factor
</pre>

These "_dia_factor" multiplier factors are currently set to work with the DENDP,
DENDM, DENDD, AXON labels in the morphology file. To use them with the numbered
regions R1, R2, ... R10 you can reassign the R1, R2 ... labels in the "setparams()"
procedure in the expt_xxx.cc file:<p>

<pre>
R1 = DENDD;
R2 = DENDM;
R3 = DENDP;
R4 = SOMA;
R5 = AXON;
...

</pre>

<h4>Making a sphere that is not the soma</h4>

To make a sphere that is not the soma, you duplicate a node in the morphology
file and define its parent to be the same node number. For example, to make a
sphere or "varicosity" at node 3 with a 2.5 micron diameter, you dould duplicate
node 3 and give it a parent of node 3:

<pre>
#    node     parent   dia      xbio     ybio    zbio   region      dendr
#
       0        0       21        0        0      -25   SOMA        0
       1        0     2.17       21    -2.47       -8   DEND_PROX   1
       2        1    0.833     22.8   0.0287       -5   DEND_DIST   1
       3        0      0.5     13.9    -6.32        0   DEND_DIST   2
       3        3      2.5     13.9    -6.32        0   DEND_DIST   2   # make a sphere here
       4        0      1.5    -3.25    -33.6      -30   HILLOCK     0
       5        4      0.5    -25.5    -66.4      -30   AXON_THIN   0
       6        5      0.5    -121.2  -160.2      -30   AXON_PROX   0
</pre>



<h3><a name = "4.0">4. Array topology from connection algorithm</h3>

To generate an array of neurons, you specify the morphology type, either from a
digitized file, or from an artificial morphology type (in makcel.cc). You can
also specify the size and rotation of the cell.  Normally the rotation is
random so that you can use a digitized morphology without concern that its
dendrites will generate a regular array of dendritic overlaps.  However, you
can also specify the position of each cell and its rotation manually in the
experiment file.  The density of the array can be specified either using the
overall array size in microns along with a number of cells, or by defining the
cell density (cells/mm2).  <p>


<h3><a name = "4.2">4.2 Defining extent of neural arrays</a></h3>
<p>
Retsim first constructs the largest and most downstream neuron set in the
experiment file. Typically this is a ganglion cell, but it can also be another neuron
such as an amacrine cell (e.g. the starburst amacrine) or a bipolar or horizontal
cell.  The size of this cell determines how large the model and its arrays of
presynaptic cells will be. Next, the presynaptic array is generated, given a cell
density and regularity ("REGU", mean/s.d., specified in the nval.n file).  Typically
the regularity is set to 5-10, but very realistic arrays can be generated with
regularities from 3 (almost random), to 50 (triangular array as in foveal cones). The
extent of each neural array determines the size of the next higher presynaptic array
(typically photoreceptors). The neuron types included in the simulation are defined
by the user in the experiment file, by setting the "make_celltype" variables (e.g.
make_dbp1 = 1) variables in "setparams()".

<p>
If a smaller array is required, a large cell and array of presynaptic neurons
can be trimmed using the "arrsiz" parameter, which sets the maximum size in
microns for the entire array. Any neurons or parts of a neuron outside this limit are
trimmed away before the simulation is run.  <p>

<h3><a name = "4.3">4.3 Specifying exact locations for cells in an array</a></h3>

<p>
Besides the automatic way of generating cell arrays described above, you can
set the cell positions in several other ways. You can specify the size of the
array for each celltype, making it either square or rectangular, and use the
cell density and regularity specified in the nval.n file (using the ___arrsiz, or
___xarrsize and ___yarrsiz arrays, ___=cellname, see retsim_var.cc). The size of
the array for the different cell types can vary. Or you can specify cell arrays
using exact cell positions, defined by arrays of x-values, y-values, and
theta-values (rotations) (using the ___xarr, ___yarr, ___tharr arrays,
___=cellname). This is helpful when you are using an array of several cells of the
same real morphology and want to rotate the morphology by different amounts for each
cell. You can also set the cell numbers arbitrarily (with ___narr, ___=cellname).
This gives you more control over the precise cell and dendrite positions which
may be important when generating a synaptically interconnected network of
cells.  (See expt_aii_dbp.cc).

<h3><a name = "4.4">4.4 Specifying rotation for 2nd cell in stereo pair</a></h3>

You can make a stereo pair by creating 2 cells, then using the ___xarr,
___yarr, ___ytharr, ___tharr arrays (___ = cellname).  When looking from the
side (i.e. mxrot = -90), set ___tharr[1] to be in the range 3-5 degrees. When
looking from the bottom (i.e.  mxrot = 180), set instead ___ytharr[1] to be in
the range 3-5 degrees.  When using "povray" to render your images, create 2
cells, the perspective generated by povray will rotate the cells according to
their X axis location.  For cells 30 um apart, the rotation from the povray
perspective will be equivalent to a rotation of 1-2 degrees.

<h3><a name = "4.5">4.5 Specifying exact locations for cells vs. an automatic array</a></h3>


For arrays of small neurons, such as photoreceptors or bipolar cells, you can
choose between the 2 methods described above. You can set an array size which
then will contain as many cells as possible given the density _DENS set in the nval
file. For example, for rods, the variable controlling this is rodarrsiz. If you
set this variable (which starts out defined but set to an uninitialized value),
then retsim will automatically make a square array of rods. If instead you set
rodxarrsiz and rodyarrsiz, you can make a non-square rectangular array, and you
can move the array with rodarrcentx and rodarrcenty.  If you set n_rods along
with rodarrsiz (or rodx,yarrsiz), then this will override the rod density in the
nval file. See the "make rods" section of retsim.cc.<p>

If you instead set the variable "rodarr" to one of the values tested in the
setparams() procedure, you can then set rodxarr[], rodyarr[], rodtharr[], and/or
rodnarr[], and nrods -- these set the xloc, yloc, angle (not relevant for rods)
and cell number, and number of cells, respectively.  Of course if you set
rodarrsiz, the "rodarr" method doesn't work -- the 2 methods are mutually
exclusive.<p>

To make a judgment about how to construct the different cell types in your
model, if you need a lot of cells, probably using the "rodarrsiz" is the easiest
way. If you only need a few cells, and would prefer them to be located at
precise locations (which will not change) then you can use the rodxarr, rodyarr
method.<p>

Generally it's easier for photoreceptors to, for example, set rodarrsiz to make
a square array of rods. They will then connect to whatever rod bipolars exist
within the area of that array.  The CELCONV for RBPs is usually set 25, so 25
rods will connect to each RBP. This usually depends on having the RBP morphology
grow a new dendrite for each rod -- this is set by GROWPOST=1 for rod input to
the RBP.  The CELDIV for rods to RBPs is usually set to 2, so only 2 RBPs will
connect to each rod.<p>

<p>
<h3><a name = "4.6">4.6 Trimming the unconnected neurons</a></h3>
<p>
After the neural arrays are generated and interconnected according to a
connection algorithm, the neurons that didn't get connected are removed.
This is necessary because the excitatory presynaptic circuit of a ganglion cell
only extends typically 20-50 um beyond the ganglion cell's dendritic tips, yet
precisely which presynaptic neurons are connected depends on their lateral extent,
the specific connection algorithm, as well as the positions of the presynaptic
neurons.

<p>
During the synaptic connection procedure, for each neuron the numbers of
presynaptic and postsynaptic neurons it connects to are totaled and saved
in a table.  Any neurons that don't connect to a postsynaptic cell are
removed. The process is started by first checking the layer immediately
presynaptic to the ganglion cell, i.e. the bipolar cells, and afterwards
checking the more distal neurons, i.e. the photoreceptors. 

<p>
To preserve all the neurons, even those that didn't get connected, you can set
the parameter "remove_nconns" to 0, either on the command line or in the
setparams() procedure. 

<p>
<h3><a name = "5">5. Connecting the neurons</a></h3>
<p>

After the presynaptic arrays of neurons are generated, they are synaptically 
connected with an algorithm that connects each presynaptic neuron to a nearby
postsynaptic neuron(s), and extends the presynaptic axon or the postsynaptic
dendritic tree, if appropriate, to create an almost-realistic morphology.
Realistic numbers of connections are generated, so that a postsynaptic neuron
can receive synaptic connections from several presynaptic neurons, with
multiple contacts if appropriate, and a presynaptic neuron can connect to
several postsynaptic neurons if appropriate. For example, a bipolar cell
receives synaptic contacts from several photoreceptors, but the nearest ones
are most likely to make contacts.  <p> 

One connection algorithm available in retsim calculates a Gaussian probability
for making connections, so that each connection is made at random, yet the
closest presynaptic neurons are more likely to connect. This allows two random
arrays of neurons to be connected with Gaussian weighting functions relatively
smoothly. The exact number of connections between a presynaptic and a
postsynaptic cell can vary, but the average is closely controlled.<p>

<p> 
The type of connection algorithm used is specified by the type of presynaptic
arbor and the type of postsynaptic arbor.  These properties are specified
in the nval.n file as DENDARB and AXARBT.  A value of 0 means non-branched,
1 means branched, and 2 means highly branched. When connecting a synapse to an
unbranched postsynaptic dendritic tree, the postsynaptic tree is extended
to generate more branches from the soma if the GROWPOST parameter for that 
synapse is set.  A branched postsynaptic cell will extend new branches
from its proximal dendrites.  A highly branched postsynaptic cell will not
grow branches but will allow synaptic contacts to be made if the presynaptic
cell is within a criterion distance (MAXSDIST).<p>

The "synfuncs.cc" file contains the connection procedures.  For each pair of cell
types, retsim determines whether to attempt to connect them (using a set of
predefined variables such as "make_dbp1_gca"), and then looks up the connection
parameters in the "nval.n" file.  The algorithm for connecting each pair of cell
types depends on their dendritic and/or axonal morphology. For example, for 
presynaptic arbors that are NBRANCHED (not branched) but grow (i.e. for an artificial
bipolar cell morphology), retsim will make a new branch from the proximal axon to the
synapse onto the postsynaptic cell.  If the presynaptic cell (axon) is a relatively
unbranched real morphology and the postsynaptic cell has a branched dendritic arbor,
the presynaptic cell is connected to the closest point on the postynaptic cell if it
is within a criterion distance.<p>

<h4>Branched presynaptic </h4>

To specify where synaptic connections are made more precisely (without
specifying the node numbers), several synaptic connection parameters can limit
where connections are made from or to. These parameters are set in the
"nval_xxx.n" file (see below). The SYNREG parameter sets an allowable
region for output synapses from the presynaptic cell, and the SYNREGP
parameter sets an allowable region to connect to in the postsynaptic cell.
For real morphologies, the region is specified in the morphology file in the
"region" column, #7, and this can be a number or a variable (R1-R9 or DEND ...
AXON). If the region specified by the SYNREG or SYNREGP parameters in the
nval_xxx.n file is greater than the number of regions, i.e 100 or more,
then it is taken as a node label in column 8 of the morphology file.
Node labels are normally set to the region * 100 + an integer, and are handy to
allow specific nodes to be accessed in a similar way between different
morphologies. For artificial morphologies, the regions accessed by the
SYNREG and SYNREGP parameters are set by the makcell() procedure in makcel.cc
<p>


<h4>Branched presynaptic and postsynaptic </h4>

To connect 2 cells that both have BRANCHED dendritic arbors (e.g. the starburst
amacrine cell), if the SYNSPAC parameter is set (spacing between synapses),
retsim will make several synapses between the cells according to the synaptic
spacing. Also the SYNANNI, SYNANNO set an inner and outer radius of an allowed
annulus in the presynaptic dendritic arbor. If SYNANNI is greater than SYNANNO,
these parameters set an exclusion annulus zone. The SYNANPI and SYNANPO
parameters likewise specify an allowed annulus in the postsynaptic dendritic
arbor. The SYNANG and SYNRNG parameters set an allowable orientation angle for the
dendrites of the presynaptic cell to connect to the postsynaptic cell. <p>


<h4>Verifying the synaptic connections</h4>

To check which synaptic connections are created, you can start with "retsim ...
--ninfo 2" which will print out the average convergence and divergence from each
type of neuron. For example, a ganglion cell that receives many synaptic inputs
from bipolar cells will have a large convergence, and the divergence of the
bipolar cells will be 1 if they only connect to 1 ganglion cell.  <p>

To check the details of the synaptic connections in a complicated circuit, you
can visualize the synapses with a label that contains presynaptic and
postsynaptic node numbers. The default icon for a synapse is a line between
pre- and postsynaptic nodes with a circle at the midpoint (see "Redefining
neural element icons" in the NeuronC Statements and Syntax, and "syn_draw()" in
nc/src/ncdisp.cc). You can redefine the synaptic icon to include node labels
like this:

<pre>
void syn_draw2 (synapse *spnt, int color, double vrev, double dscale, double dia,
                                double length, double foreshorten, int hide)

/* draw synapse within small oriented frame */

{
    int fill=1;
    double tlen;
    char tbuf[10];

  if (!draw_synapse) return;
  dia *= dscale;                        /* draw circle with line
*/
  if (dia < 0) dia = -dia;
  color = -1;
  if (color < 0) {
     if (vrev < -0.04) color = RED;
     else              color = CYAN;
  }
  gpen (color);
  if (length > 1e-3) {
     gmove (length/2.0,0.0);
     if (dia > 0.001) gcirc (dia/2.0,fill);
     else             gcirc (0.001,fill);
     gmove (0,0);
     gdraw (length,0);
  }
  else                gcirc (0.001,fill);
  if (spnt->node1a==am) gpen (brown);
  else                  gpen (black);
  sprintf (tbuf,"%d>%d",spnt->node1b,spnt->node2b);     /* print pre and postsynaptic cell number */
  tlen = strlen(tbuf);
  gmove (length/2.0 -tlen*0.3, -1.0);
  gcwidth (2.5*dscale);
  gtext (tbuf);
}


// And in setparams, you activate the new procedure:

void setparams(void) {

{
  ...
  set_synapse_dr (syn_draw2);
}
</pre>

Then you display the model with: "retsim ... -d 1 -v | vid" and all the synapses
will appear as the icon you've defined in the new "syn_draw2()" procedure. <p>

<br>

<h5>List synaptic information</h5>

To make a listing of the synapses, you can set the "info" printout to a higher
level: "retsim --info 3 ...". You can also get this information by including a
"for" loop at the beginning of "run_expt(): <p>

<pre>
  for(epnt=elempnt; epnt = foreach (epnt, SYNAPSE, sbac, -1, &pa, &pb); epnt=epnt->next) {
     fprintf (stderr,"syn from %d %d to %d %d\n",epnt->node1b,epnt->node1c,epnt->node2b,epnt->node2c);
  }
</pre>
<p>

Printouts of more complex data from synapses is possible, for example, the
relative angles between dendrites connected by synapses (see
nc/models/retsim/expt_sbac_stim.cc).
<p>

<br>

<h5>Plot total synaptic conductances</h5>

To plot total conductances of all synapses during the experiment, you can generate lists of
synapses that are queried at run time to generate a plot trace:<p>

<pre>
nsynap = synapse_add (dbplist1,dbp1,-1,-1,sbac,1);  /* make list of bipolar synapses onto sbac 1 */

// Then, to make a plot of the total synaptic current and conductance:

 plot_funci(isyn_tot,dbplist1,imax=0,imin=-500e-12); plot_param("Itotbpsyn",green,2,0.3);
 plot_funcg(gsyn_tot,dbplist1,gmax,0);               plot_param("Gtotbp_sb1",blue,1,0.3);
</pre>

<br>
<p>
<h3><a name = "6">6. Neural and synaptic parameters: the "nval.n" file</a></h3>
<p>

The construction of the neural circuit in "retsim" is done using a table of parameters
called "nval.n".  Each column contains the parameters for one cell type, and each row
gives the values of one parameter for all the cell types. The table can be viewed and
modified using a standard text editor, which makes it easy to change/copy values. The
"nval.n" table sets the default values for the construction of the neural circuit.
<p>

Often it's helpful to create a different nval.n file for each experiment. This allows you
to set up different cell densities and synaptic connections. Several nval_xxx.n files are 
included in the Neuron-C distribution (in nc/models/retsim/runconf).<p>

<h4>Parameters (rows) and cell types (columns) in nval.n are optional</h4>

Note that you don't need to set all the parameters (i.e. the rows of the nval
file). When left with their original default value of zero, the parameters are
ignored or are given default values. You can also leave out parameter lines in
the nval file. This will leave that row of parameters with the default value of
zero. When one or more rows are omitted, the order of the nval table in memory
is not affected, because the paramter lines are defined (i.e. indexed) by the
last column (which is a variable), not by their order in the file.<p>

You can also omit any columns (i.e. any cell type) because the columns are
defined (i.e. indexed) by the first row that specifies the cell type.  Since the
full nval.n file is large and may be difficult to see with a text editor, you
can remove columns with the nval_subcol command (in nc/models/retsim/runconf),
and you can add new columns with nval_addcol command.  <p>

<h4> How to create a "nval.n" neuron parameter file</h4>

To create a new nval.n file, you can copy and modify an existing nval.n
file or you can make a new one by running "maknval":
<pre>
cd ~/nc/models/retsim
make maknval               # this compiles maknval.cc
maknval &gt; nval.n
</pre>
This makes an nval.n file with default parameters. At the end of the file
there are some other files that must be created separately with editing.
Follow the instructions at the top of the nval.n file. Copy the nval.n
file to nval.h, and edit nval.n to remove everything after the nval parameter rows.
Edit nval.h to remove the nval.n parameters, then copy it to nval_var.h,
nval_var.cc, and nval_var_set.cc, and edit these files to remove everything
but the content below the title of each file and ahove the title of the next.

<p>
<h4> Use an existing "nval.n" file</h4>

However, it is usually easier to start with an existing nval.n file instead of making
a new one. To do this, you can copy and existing nval.n file (recommended) and modify
the parameters for the particular model you are developing. Several example
nval_xxx.n files are provided in nc/models/retsim/runconf.  These nval.n files were
originally created by "maknval > nval.n" but have been modified for a specific retsim
experiment.<p>

<p>
To compare nval.n files, use the command "diff":

<pre>
diff nval.n nval_new.n | less
</pre>

<h4>Description of parameters in "nval.n"</h4>

<p> The first block of the nval.n parameters describes how a neuron is to 
be constructed, some of its biophysical parameters, and also the density and
maximum number of cells in an array.  The second block, starting with CELPRE1,
sets the input synaptic connections for a neuron.  The third, fourth, and all
the other blocks of parameters starting with CELPOST(1,2,3...) define the
output synaptic connections.  Note that the default values are set by
the "maknval.cc" (maknval.n) file that generates the nval.n file.
<p>

First block of parameters in nval.n, for constructing cells:
<p>

<pre>
_MAKE      # whether to make this cell type
_MAKE_DEND # whether to make dendrites
_MAKE_AXON # whether to make axon
_MAKE_DIST # whether to make axon distal
_NMADE     # number of cells made
_MAXNUM    # maximum number of cells of this type
_NCOLOR    # color of this cell type for display
_MAXCOV    # max coverage factor (for arrays)
_MAXSYNI   # max number of syn input cells per celltype
_MAXSYNO   # max number of syn output cells per celltyp
_DENS      # density of this type (per mm2)
_REGU      # regularity (mean/stdev) of spacing
_MORPH     # morphology (=0 -> file, or >0 -> artificial)
_COMPLAM   # compartment size (default=complam)
_BIOPHYS   # add biophys properties (use channel density file dens_xxx.n)
_CHNOISE   # add membrane channel noise properties  
_RATIOK    # set K density values as ratio from Na
_VSTART    # initial resting potential, when BIOPHYS==0
_VREV      # membrane potential for Rm (VCl), when BIOPHYS==0
_NRM       # the cell's Rm when BIOPHYS==0
_SOMADIA   # Soma diameter for artificial morphology
_SOMAZ     # Z location (x,y loc determined by array)
_DENDARB   # type of dendritic tree, non-branched, branched, etc (retsim.h).
_DENDARBZ  # dendritic arborization level for artificial morphology (synfuncs.cc)
_DENZDIST  # dendritic arborization z tolerance for synaptic input. (synfuncs.cc)
_STRATDIA  # stratif. annulus dia (fract of treedia) for artificial morphology. (synfuncs.cc)
_DTIPDIA   # diameter of dendritic tips for artificial morphology (makcel.cc,synfuncs.cc)
_DTREEDIA  # diameter of dendritic tree (for artificial and real morphology, allows synaptic connection). 
_AXARBT    # type of axonal tree 
_AXARBZ    # axonal arborization level for artificial morphology
_AXTIPDIA  # diameter of axonal tips for artificial morphology
_AXARBDIA  # diameter of axonal arbor (for synaptic connections, synfuncs.cc)
_MAXSDIST  # maximum synaptic distance (for synaptic connections, synfuncs.cc)
_TAPERSPC  # space constant of diameter taper for artificial morphology.
_TAPERABS  # abs diameter for taper for artificial morphology.
_NDENDR    # number of first-order dendrites for artificial morphology.
_GROWTHR   # distance thresh for growth of dendrites for artificial morphology.
_SEGLEN    # length of dendrite segments
</pre>

Second block of parameters in nval.n, describing synaptic inputs to a cell type.
Each of these ends in a number which is the "synaptic input number" for a cell type.
There are 10 possible inputs.
<p>

<pre>
_CELPRE1   # cell type to connect to (negative -> no connection)
_CONPRE1   # connection number of presyn cell
_CELCONV1  # number of presyn cells to connect to
_GROWPOST1 # grow when making conn from presyn cell
</pre>

Blocks for synaptic output parameters, note that each block ends
with the same number which is the "synaptic output number". There
are a maximum of 9 possible outputs, each consisting of these parameters:
<p>

<pre>
_CELPOST1  # cell type to connect to (negative, no connection)
_CONPOST1  # connection number for postsyn cell (its synaptic input number from above)
_CELDIV1   # number of postsyn cells to connect to (maximum)
_GROWPRE1  # grow when making conn to postsyn cell
_SYNREG1   # region for synapse in presynaptic cell (if positive, this allows synapses only from this region/label)
_SYNREGP1  # region for synapse in postsynaptic cell (if positive, this allows synapses only to this region/label)
_SYNSPAC1  # synaptic spacing in presyn dendritic tree (if positive, this enables many synaptic outputs per cell)
_SYNANNI1  # inner rad of annulus in dendritic tree (allows synapses outside this radius)
_SYNANNO1  # outer rad of annulus in dendritic tree (allows synapses inside this radius)
_SYNANPI1  # inner rad of annulus in postsynaptic dendritic tree (allows synapses outside this radius)
_SYNANPO1  # outer rad of annulus in postsynaptic dendritic tree (allows synapses inside this radius)
_SYNANG1   # angle for synapse onto postsynaptic cell (sets allowable angle in degrees)
_SYNRNG1   # range of angles for postsynaptic cell (if positive, sets allowable range, if neg, set angle from somas)
_USEDYAD1  # synapse is dyad using preexisting type 
_DYADTYP1  # type of dyad synapse to connect with (sets which type of presynaptic cell for dyad 1-&gt;2 cells )
_AUTAPSE1  # synapse back to presynaptic node (allows cell to connect to itself)
_SYNNUM1   # number of synapses per connection (sets more than 1 synapse per connection, typical for bipolar cells)
_SENSCA1   # synaptic release sensitivity calcium (use [Ca]i for driving release instead of expon function)
_SRRPOOL1  # synaptic readily releasable pool (sets initial size of pool)
_SRRPOOLG1 # synaptic readily releasable pool gain mult (default 0 -&gt; rrpool sets gain; 1-&gt; constant gain)
_SMRRPOOL1 # synaptic readily releasable pool maximum (sets max size of pool)
_SMAXRATE1 # maximum synaptic release rate (sets replenishment rate, 0 -&gt; no rrpool)
_SGAIN1    # synaptic gain (sets exponential gain, mV/efold increase, when not using [Ca] sensitivity)
_SVGAIN1   # synaptic vgain (sets additional linear gain factor, if set&lt=0, set linear synapse using SGAIN)
_SDURH1    # synaptic high pass time const. (sets high pass filter for release)
_SNFILTH1  # synaptic high pass nfilt (sets number of high-pass filters for release)
_SHGAIN1   # synaptic high pass gain (sets high pass filter gain relative to unfiltered release)
_SHOFFS1   # synaptic high pass offset (sets offset in mV for high pass func for release)
_SVSIZ1    # synaptic vesicle size (sets vesicle size without changing overall release, i.e. changes release rate)
_SCOND1    # synaptic conductance (maximum conductance when potsynaptic receptor is saturated)
_SCMUL1    # synaptic conductance multiplier for region of cell
_SCGRAD1   # synaptic conductance gradient from soma
_STHRESH1  # synaptic threshold (threshold for exponential release in mV).
_SVNOISE1  # 1-&gt;allow vesicle noise, override, vnoise=0 
_SCOV1     # 1=Poisson, &lt;1-&gt;more regular, gamma dist (sets properties of noise distribution for release)
_SDUR1     # synaptic event time const. (sets lowpass filter of vesicle release: shape of mini-PSP)
_SFALL1    # synaptic event fall time const. (sets separate first order fall time for mini PSPs)
_SNFILT1   # synaptic vesicle nfilt (sets number of lowpass filters for mini waveshape)
_STRCONC1  # synaptic transmitter concentration. (multiplier for neurotrans conc with ligand-gated channel)
_SRESP1    # synaptic response (ampa,gaba,gj,etc). (sets which Markov state diagram to use)
_SPCA1     # synaptic postsyn Ca relative permeability (default dpcaampa, dpcanmda, etc. range 0 - 1)
_SCAVMAX1  # synaptic postsyn Ca pump Vmax  (default dcavmax, 2e-7, rate per comp area)
_SCAKM1    # synaptic postsyn Ca pump Km (default dcapkm, 1e-6)
_SCNFILT1  # second mesng. nfilt (number of lowp filters in postsynaptic cascade)
_SCDUR1    # second mesng. time const.(time const of filter in postsynaptic cascade)
_SCGAIN1   # synaptic second messenger gain (gain of second messenger)
_SCOFF1    # synaptic second messenger offset (offset of second messenger)
_SCNOISE1  # 1-&gt;allow channel noise, override, cnoise=0 (sets noise of postsynaptic channel)
_SNCHAN1   # number of channels (sets number of postsyn channels)
_SUNIT1    # synaptic channel unitary conductace (sets conductance of unitary channel)
_SVREV1    # synaptic reversal potential (usually either 0 for excitatoryh, or -0.065 for inhibitory)
</pre>

<h4>Setting cell parameters in nval.n</h4>

The first block of parameters in nval.n describes features of the cell types,
such as the density of cells, the regularity of the array (mean/s.d.), the
diameter of the dendritic arbor, and the Z position of the cell soma. There are
also default biophysical parameters: RM, VSTART,VREV (for RM). These defaults
are used in case the BIOPHYS parameter is set to 0, which means do not use a
density file to set the biophysical parameters.<p>

<h3><a name = "6.2">6.2 Setting synaptic connection parameters in nval.n</a></h3>

The nval.n file defines the synaptic connections between all the neurons in the
retsim model. Each cell type can have (currently) 8 input cell types and 7
output cell types. Each input or output synapse must be defined in the nval.n
file.  To set up a new synaptic connection, you must set the connection number
for the other cell type on both input and output sections. This may seem
difficult at first but it is really quite straightforward:<p>

For each input synapse type, you must set _CELPRE and _CONPRE. The _CONPRE
parameter refers to the number of the _CONPOST parameter of the presynaptic
cell (i.e. _CONPOST2 = the second output synapse).<p>

For each output synapse type, you must set _CELPOST and _CONPOST. The _CONPOST
parameter refers to the number of the corresponding _CONPRE parameter for the
postsynaptic cell (i.e. _CONPRE1 = the first input synapse).<p>

Although at first thought there seems to be no need to have synapses described
with both their presynaptic and postsynaptic connection numbers, the advantage of
this format is that the nval.n file lists all the inputs and all the outputs
separately for each cell type. Thus, once you have correctly specifed both
input connection number and output connection number, you can see a convenient
listing of all inputs and outputs for a cell type.<p>

<pre>
------------------------------------------------------------------
For the input from dbp1 -&gt; dsgc (under the dsgc column):
#
#  dsgc  
#
   dbp1     _CELPRE1   # cell type to connect to (neg, no conn)
      2     _CONPRE1   # connection number of presyn cell

------------------------------------------------------------------
For the output from dbp1 -&gt; dsgc (under the dbp1 column):
#
#   dbp1
#
    dsgc   _CELPOST2  # cell type to connect to (neg, no conn)
       1   _CONPOST2  # connection number for postsyn cell
------------------------------------------------------------------
</pre>

Note: The synaptic biophysical parameters are specified only for the synaptic
outputs.  However, some connection parameters are specified for the synaptic
inputs (CELCONV = number of presyn cells to connect; GROWPOST = whether to grow
the postsynaptic cell to make the connection.<p>

You can set all the parameters for nval.n in the "maknval.cc" file, so that
when you run "maknval > nval.n" you get correctly set parameters. However, it
is often easier to start with an existing "nval.n" file and manually edit to add
parameter values and new connections.  The "nval.n" file is a 2D matrix so it is easy
to see the parameter values in neighboring columns and rows.<p>

<h4>Setting postsynaptic connection calcium parameters in nval.n</h4>

Some postsynaptic ligand-gated channels are permeable to calcium, for example,
AMPA, NMDA, TRPM1 channels. These channels are specified in the postsynaptic
mechanism using the SRESP parameter.  When you want to set calcium 
permeabililty, you set the SPCA parameter (relative permeabililty to calcium)
to a value between 0 and 1. This will automatically include a calcium compartment
at the postsynaptic node, along with a calcium pump (see ncman2.html, "Channels, 
"Calcium Compartment". If the SPCA parameter is not set (i.e. defaults to 0)
the synapse will not automatically include a calcium compartment. To set the
calcium pump parameters, use SCAVMAX for the Vmax (strength) of the pump, and
SCAKM for the half-max saturation of Vmax.  If you set any of these parameters
to -1 they will be activated but with default parameter values (e.g. dpcaampa,
dcavmax, dcapkm, defined in nc/src/init.cc).  <p>

<h4>Setting synaptic connection "where" parameters in nval.n</h4>

Several of the synaptic connection parameters allow you to specify where synapses
will be created. <p>

For branched presynaptic and postsynaptic cells, the SYNSPAC parameter allows 
you to set multiple synaptic outputs per cell, at a spacing in microns specified 
by SYNSPACx. Creation of synapses will be subject to the distance limits 
DENDARBZ and MAXSDIST, as well as the SYNREG, SYNANN, and SYNANG parameters 
(described below).<p>

<pre>
_SYNSPAC1  # synaptic spacing in presyn dendritic tree (if positive, this enables many synaptic outputs per cell)
</pre>

The SYNREG parameters allow you to specify a presynaptic (SYNREGx) or
postsynaptic region (SYNREGPx) for the synapse. If either of these parameters is
greater than zero, the synapse is created only when the parameter value is equal
to the cell's region, defined in the morphology file.<p>

When the SYNREG parameter value is greater than the number of regions, it is taken to
specify the node label, found in the eighth column of the morphology file. The
label gets identified, and the corresponding node number is determined.  The synapse
is created if the node number corresponding to the eighth column label is equal to
the synaptic node: <p>

<pre>
_SYNREG1   # region for synapse in presynaptic cell (if positive, this allows synapses only from this region/label)
_SYNREGP1  # region for synapse in postsynaptic cell (if positive, this allows synapses only to this region/label)
</pre>

The SYNANN parameters when set greater than zero define a permissible annulus
for synaptic locations, specified as a radius from the soma: <p>

<pre>
_SYNANNI1  # inner rad of annulus in dendritic tree (allows synapses outside this radius)
_SYNANNO1  # outer rad of annulus in dendritic tree (allows synapses inside this radius)
_SYNANPI1  # inner rad of annulus in postsynaptic dendritic tree (allows synapses outside this radius)
_SYNANPO1  # outer rad of annulus in postsynaptic dendritic tree (allows synapses inside this radius)
</pre>
If SYNANNO &gt; 0 and SYNANNO &lt; SYNANNI, then they define an "exclusion annulus" where synapses are
not permitted.<p>

The SYNRNG parameter when greater than zero defines the allowable range for SYNANG (in
degrees) for the presynaptic dendrite, measured relative to its soma.  If SYNRNG is
negative but greater than -1000, it sets the allowable range (-synrng) for contacting a
postsynaptic dendrite of the same orientation.  If SYNRNG is negative but less than -1000,
it sets the allowable range (-synrng-1000) for contacting a postsynaptic dendrite of the
opposite orientation:<p>

<pre>
_SYNANG1   # angle for presynaptic dendrite relative to its soma (sets allowable angle in degrees)
_SYNRNG1   # range of allowable angles (if positive, sets allowable range, if neg, sets range rel to post dendr)
</pre>

<h3><a name = "6.3">6.3 Setting and overriding values in nval.n</a></h3>

Typically you want to set default values in nval.n, and then run a series of
simulations that test different parameter sets. In this situation it's best to avoid
modifying the nval.n file for each simulation, which would require many copies of
nval.n and would be too confusing. Instead you can change the values corresponding to 
those defined in the nval.n file. The nval.n file is read into an array in RAM memory
from which its parameter values are taken when constructing the neural circuit. You
can change the values in the memory array after it is read in from the nval.n file. 
Retsim reads nval.n after "defparams()" and before "setparams()". This allows you to
set the nval file name in "defparams()" and override some of its parameter values in
"setparams()".  <p>

There are several ways to override individual parameter values in "nval.n" for a specific
simulation. You can override the nval.n values in the memory array with calls to the
"getn(ct, PARM)" and "setn(ct, PARM, val)" functions in the "setparams()" procedure. This
procedure runs after the nval.n file has been read into memory. A useful way to do this
is to define new variables and use them to set the corresponding value in the nval.n file.

You define the variables at the top of the experiment file:

<pre>
   int sbac_color;
   double soma_z;
</pre>

Then you add the variable names to the symbol table to allow setting the variables from
the command line. This sets the variables to an "uninitialized" value:

<pre>
   void defparams(void)
   {
     ...
     setptr("sbac_color",  &sbac_color);
     setptr("soma_z", &soma_z);
     ...
   }
</pre>

Then, you test to see whether the parameters have been set from the command line. The
"notinit()" function returns a "1" (true value) if the variable has not been
initialized, so "!notinit()" returns a 1 (true) if the variable has been set on the
command line:

<pre>
   void setparams(void)
   {
     ...
     if (!notinit(sbac_color)) setn(ct,NCOLOR,sbac_color);   /* set cell display color */
     if (!notinit(soma_z))     setn(ct,SOMAZ,soma_z);        /* set cell soma z location */
     ...
   }
</pre>

Then you can set these variables from the command line:

<pre>
   retsim --expt ... --sbac_color 4 --soma_z -45.5 ...
</pre>

<h4> A second way to set nval.n parameters from the command line</h4>

Another way to define individual values for nval.n parameters is to replace the
numeric value in nval.n by a variable: 

<pre>
#    rbp    dbp1    dbp2    hbp1    hbp2     a17     aii     sbac    am     amh     ams     gca     gcb    dsgc  gcaoff  gcboff
#
     0       0       0       0       0       0       synrng  synrng  synrng 0       0       0       0       0       0       0   _SYNRNG3   # range of angles for postsynaptic cell 
</pre>

This is especially useful when setting multiple parameters in the nval.n variable all
at once to the same value. You define and set default values for the variables
in "defparams()" which is run before nval.n is read into memory.  However, by default
the command line values are set after defparams(), so to allow them to be set 
from the command line before testing their values (i.e. setting default values)
in defparams(), you must call "setvar()" in defparams():

<pre>
   void defparams(void)
   {
   setptr("sbac_synrng", &sbac_synrng);
   ...
   setvar();					// sets values from command line
   if (notinit(sbac_synrng)) sbac_synrng = 30;
   }
</pre>
If you don't need to test the values or set default values of variables you've 
placed in the nval.n file, i.e. you'll always be setting the correct value from 
the command line, you don't need to call setvar() from defarams().
<p>
The variables you set up and/or access in defparams() can then be set on the
command line:

<pre>
   retsim --expt ... --sbac_synrng 15 ...
</pre>


<h4> Expressions in nval.n parameters</h4>

Instead of simple variables, you can also define expressions in nval.n. This
mode is turned on by setting fread_expr = 1, either on the command line or in
the experiment file. The expressions in the nval file must contain no spaces,
e.g.  "synrng*2+5", and any variables in the expression must be defined before
the nval.n file is read into memory, i.e. in the "defparams()" procedure or on
the command line. The numeric expression is interpreted by the "nc"
interpreter.  <p>

<h4>Adding new parameters to "nval.n"</h4>

To add new parameters (either colums = cell types, or rows = params) to nval.n,
you need to generate a new index parameter for the column or row. Add your 
new parameter to "maknval.cc", compile it with "make maknval", and run "maknval
> nval.n" as described above, then copy nval.n to "nval.h":<p>

<pre>
maknval > nval.n
cp nval.n nval.h
</pre>

Then remove the numerical parameter definitions from the end of nval.n using a
programming text editor such as vi or kwrite.  Next, remove the nval.n table at
the beginning of nval.h. Next, copy nval.h to "nval_var.h", "nval_var.cc", and
"nval_var_set.cc" and edit these files to leave only their correct contents,
shown in comments in the beginning of nval.n.  Then remove this content from
nval.h. Last, "make clean" and "make retsim".  This description is included in
the beginning of "nval.n".<p>

The last (right) column in the nval.n file is the name of the parameter. 
This name is a variable that has an integer value, which is preset by default. 
To add a new parameter, you can edit the nval.n file and add a new row. Then you
edit the maknval.cc file to add the new parameter, and run "maknval > nval.n".
Then copy the nval.n file to nval.h, and edit nval.h to give new versions
of nval.h, nval_var.h, nval_var.cc, and nval_var_set.cc.  <p>

You can simplify the nval.n file to remove the columns and rows that are
not required for your experiment.  This does not require any changes to
nval.h, nval_var.h, nval_var.cc, or nval_var_set.cc.  The rows and columns
can be in any order (except for the first row and the last column, which
contain the labels). This works because the rows and colums are
described by labels, and when retsim reads in the nval.n file, the data from
the file is placed in the correct row and column by referring to the labels.
The labels are predefined as variables with integer values in nval_var_set.cc.
You can also leave out any rows not needed for the simulation that have zero
default values, because the rows for any missing labels are automatically left
zero when the file is read into an array in working RAM memory.<p>

<h4> How to modify an existing "nval.n" neuron parameter file</h4>

If you want to add a new row parameter into an existing "nval.n" you can do
this manually with a programming editor. For example, to add a new cell type,
you must make a new column. However, adding a new column is not easy with most
editors. To add or subtract a column from an existing "nval.n" file, you can
use the commands nval_addcol and nval_subcol in the nc/models/retsim/runconf
folder. Their usage is described in the command files (i.e. look at nval_addcol
with: "less nval_addcol".<p>

<p>
For example, to duplicate column 5:
<pre>
nval_addcol 5 nval.n
</pre>

You can remove a column from an existing nval file with "nval_subcol".
<p>

For example, to remove column 5:
<pre>
nval_subcol 5 nval.n
</pre>

<p>

<h4> Column and row placement in a "nval.n" file is arbitrary</h4>
Note that the columns and rows in an nval file are ordered by their labels
(which are variables), so the order of columns and rows is not significant. You
can remove any columns or rows that are not needed, and their values will be
set to zero and not utilized in constructing the model.
<p>

<h3><a name = "6.4">6.4 Speeding construction of large models with many synapses</a></h3>

A large retsim model may take several minutes ore even hours to be constructed
because the synaptic connections are based on computing the proximity of
presynaptic and postsynaptic sites.  In order to speed the process, you can
save a list of synapses and then rerun the model using this list to regenerate
the synapses without requiring their proximity to be recomputed. This works as
long as the re-run model is exactly the same, i.e. it has the same cells, in
the same locations, with the same random number seed. Only the presynaptic and
postsynaptic node numbers are saved, so the regenerated synapses can have
different synaptic parameters than the originals.  <p>

To make a file containing a list of the synapses, define the "syn_savefile" variable,
either in the experiment file or on the command line. Then, to create the synapses
from the list, define the "syn_restorefile" variable:

To create the save file, define the save file on the command line:
<pre>
retsim --expt xxx ... --syn_savefile save_expt_xxx ...
</pre>
To restore the synapses from the file, define the restore file:
<pre>
retsim --expt xxx ... --syn_restorefile save_expt_xxx ...
</pre>

<br>

<h3><a name = "6.5">6.5 Channel density file "dens.n"</a></h3>

When the "biophys" parameter in the nval.n file is set to 1, retsim reads biophysical
parameters such as conductance densities of voltage-gated channels, the starting
voltage "Vstart", the reversal potential for Rm "Vrev", Rm and Cm, and possibly the
display color from a separate file (default name "retsim/runconf/dens_default.n").
This file contains a table that defines the channel types and their conductance
densities for each region of the neuron. Each cell type has a default density file
(e.g. "dens_dsgc.n"), but you can also give the file any name. You can specify on
the command line which density file to use with "--<celltype>_densfile.n file.n", where
file.n is your density file. You can also set this filename in the experiment file in
the "setparams()" procedure.  

<p>
Note that when the "biophys" parameter in the nval.n file is set to 0, then
retsim does not read the dens_xxx.n file, and takes the "vstart", "vrev", "Rm",
and "Cm" parameters from nval.n instead of a density file.  
<p>

<h4>Channel density file format</h4>

<p>
The "density file" (retsim/runconf/dens_xxx.n) defines the biophysical properties
of a cell, region by region. Each column defines the biophysical properties of
one region. The first (left) column of the density file is the name of the
biophysical parameter, such as NA, KDR, or RM. These labels are the names of
variables that have been set by default to have a value to index into the
internal list of channel types.  Some of the names, for instance, NA, KDR, KA,
SKCA1, are aliases for other internal variables that contain the correct index
number. The alternative internal values are in the last column, the comments to
the right of the "#".  The other columns (2-11) of the density file define
conductance density values for each membrane channel type to be inserted into
the cables and spheres of the model in the appropriate region.  
<p>
The rows and columns of the density file can be in any order, and
unused rows or columns can be deleted, because each column and
row is indexed by the label at the top or left column,
respectively.  Any rows or columns undefined in the density file
are set to zero.<p>

<h4> Channel types in the density file </h4>
For a listing of all the possible rows (channels and cell properties by
region), see the "dens_default_full.n" file in nc/models/retsim/runconf. For a
listing of all the channel types, see "Channel statement" in the Neuron-C manual.
<p>

Retsim uses dynamic calcium pumps and buffering. Internal Calcium-induced
calcium-release can also be set. In real cells, the calcium pump is
electrogenic, that is, the positive calcium ion flux it pumps out of the cell
is added to the total cell current. Since calcium is divalent and positively
charged, the calcium pump hyperpolarizes the cell.  To prevent this
electrogenic function, the parameter "dicafrac" is set by default to 0. To
enable the electrogenic effect of the pump, set dicafrac = 1.  To see more
details about the calcium pump and buffering parameters, see "Calcium pumps"
under "Channel statement" in the Neuron-C manual.<p>


A typical dens.n file for retsim is:
<p>

<pre>
# Default membrane properties (density) file
#
# Densities of currents for the cell's different regions (S/cm2).
#
#      DEND_DIST DEND_PROX SOMA HILLOCK AXON_THIN AXON  AXON_DIST VARICOS R9  R10  (LGRAD,EGRAD)
#
0       R1      R2      R3      R4      R5      R6      R7      R8     R9     R10
#
_NA     0e-3    0e-3    0e-3    0e-3    0e-3    0e-3    50e-3   0e-3   0e-3   0e-3  # Na2
_NA5    0e-3    0e-3    0e-3    0e-3    0e-3    0e-3    0e-3    0e-3   0e-3   0e-3  # Na5
_NA6    35e-3   0e-3    0e-3    4e-3    4e-3    0e-3    0e-3    0e-3   0e-3   0e-3  # Na6
_NA8    0e-3    0e-3    0e-3    0e-3    0e-3    0e-3    0e-3    0e-3   0e-3   0e-3  # Na8
_KDR    15e-3   0e-3    0e-3    15e-3   15e-3   20e-3   10e-3   0e-3   0e-3   0e-3  # K1
_KA     35e-3   0e-3    0e-3    35e-3   35e-3   0e-3    0e-3    0e-3   0e-3   0e-3  # K3
_KH     0e-3    0e-3    0e-3    0.09e-3 0e-3    0.8e-3  0e-3    0e-3   0e-3   0e-3  # K4
_SKCA1  0.12e-3 0e-3    0e-3    0.12e-3 0.00e-3 0e-3    0e-3    0e-3   0e-3   0e-3  # KCA4
_SKCA2  0.01e-3 0e-3    0e-3    0.04e-3 0.02e-3 0e-3    0e-3    0e-3   0e-3   0e-3  # KCA5
_BKCA   0e-3    0e-6    0e-3    0e-3    0e-6    0e-6    0e-6    0e-6   0e-3   0e-3  # KCA3
_CA_L   0.014e-3 0e-3   0e-3 0.014e-3 0.014e-3  0e-3    0e-3    0e-3   0e-3   0e-3  # Ca1
_CA_T   0e-3    0e-3    0e-3    0e-3    0e-3    0e-3    0e-3    0e-3   0e-3   0e-3  # Ca5
_CAP    2e-7    0e-3    0e-3    1e-7    1e-7    0e-12   0e-3    0e-3   0e-3   0e-3  # Capump, sets flux rate
_CAPK   1e-6    0e-3    0e-7    1e-6    1e-6    0e-3    0e-3    0e-3   0e-3   0e-3  # Capump km, sets pump affinity
_CABV   0e8     0e-3    0e8     1e8     1e8     0e-3    0e-3    0e-3   0e-3   0e-3  # Cabuf vmax, sets buffer velocity
_CABK   0e-2    0e-3    0e-7    3e-6    3e-6    0e-3    0e-3    0e-3   0e-3   0e-3  # Cabuf kd, sets buffer affinity
_CABT   0e-2    0e-3    0e-7    10e-6   10e-6   0e-3    0e-3    0e-3   0e-3   0e-3  # Cabuf btot, tot buffer in shells
_CABI   0e-2    0e-3    0e-7    5e-6    5e-6    0e-3    0e-3    0e-3   0e-3   0e-3  # Cabuf btoti, tot buffer 1st shell
_CASH   0e-2    0e-3    0e-7    0e-3    0e-3    0e-3    0e-3    0e-3   0e-3   0e-3  # Ca shells, >0 => sets number of shells
_CAE    0e-7    0e-3    0e-3    0e-7    0e-7    0e-12   0e-3    0e-3   0e-3   0e-3  # Caexch
_CAS    0e-2    0e-3    0e-7    0e-3    0e-3    0e-3    0e-3    0e-3   0e-3   0e-3  # CICR init [Ca] 
_VM2    0e-2    0e-3    0e-7    0e-3    0e-3    0e-3    0e-3    0e-3   0e-3   0e-3  # CICR Vmax uptake
_VM3    0e-2    0e-3    0e-7    0e-3    0e-3    0e-3    0e-3    0e-3   0e-3   0e-3  # CICR Vmax release
_VST    dvs     dvs     dvs     dvs     dvs     dvs     dvs     dvs    dvs    dvs   # Vstart, starting voltage
_VRV    vk      vk      vk      vk      vk      vk      vk      vk     vk     vk    # Vrev, battery voltage for Rm
_RM     drm     drm     drm     drm     drm     drm     drm     drm    drm    drm   # Rm
_CM     dcm     dcm     dcm     dcm     dcm     dcm     dcm     dcm    dcm    dcm   # Cm
_DIA    ddia    ddia    1       axdia    axdia  axdia   axdia   ddia   ddia   ddia  # Dia, multiplier 
_CPL    cplam   cplam   cplam   cplam   cplam   cplam   cplam   cplam  cplam  cplam # cplam, compartment lambda
_CMUL   1       1       1       1       1       1       1       1      1      1     # syncond, synaptic cond multiplier 
_COL    green   blue    red     blue    blue    magenta yellow  gray   ltred  brown # color

</pre>

<h4>Variables in the density file</h4>

For finer control, you can customize the density file by replacing the numerical
values in the density file with variables. For example, in the density file listing
above, "drm" means use the default value of Rm (drm) preset by retsim. When retsim reads
the numbers from the density file, it looks up any variables in the symbol table and
replaces the variable with its numeric value.  This means that you can use any
variable, either predefined internally in the simulator (in retsim_var.cc), or
defined in your experiment file, as long as the variable's value is defined before
the density file is read. You can define the variable in the "defparams()" procedure,
and you can set its value in the "setparams()" procedure or in the command line. The
density file is read after the setparams() procedure.  <p>

<h4>Other rows in the density file</h4>

<p>
The density file includes some other rows that define properties for the regions.
VST (also VSTART in retsim_var.cc) is the starting voltage for the region, and VRV is
the "battery potential" for the membrane resistance RM. DIA is a diameter
mulplication factor, like dendd_dia_factor, dendi_dia_factor, dendp_dia_factor, and
dend_dia_factor (used on command line).  These are useful to modify the diameters
when the exact thickness of dendrites or axon are unknown. CPL is the local complam
(size of compartments in terms of lambda) for the region (see "Setting complam"
below). CMUL is a conductance multiplier for synaptic conductances, which can also be
modified by SCMUL and SCGRAD in nval.n (i.e. for each type of synapse). The values
for SCMUL for each type of synapse are multiplied by CMUL for each region, which
multiply SCOND in nval.n.  COL is the color of each region, which defaults to 1 if
set to zero (see "Setting color" below).</p>

<h4> Expressions in the density file </h4>

<p>
The dens.n file can contain expressions when the parameter "fread_expr" is set
to 1, either in the experiment file or on the command line. The expressions
must not contain spaces, e.g. "nadens*2+0.03".  
<p>

<h4> Temporarily override channel densities </h4>

You can temporarily remove a row in the density file, for example, to remove
a channel type from all regions in the cell, by redefining the variable that
defines the row to a value outside the allowable range of values. Or you can
temporarily remove a region by redefining the variable that defines its column
to a value outside the number of regions. For example: 
<p>

<pre>
retsim --expt cell_vclamp --celltype dbp1 --dbp1_densfile dens_dbp1.n --KDR 99
or,
retsim --expt cell_vclamp --celltype dbp1 --dbp1_densfile dens_dbp1.n --R4 99
</pre>

The first example runs expt_cell_vclamp.cc with the density file dens_dbp1.n
file, except with the density of KDR set to 0 everywhere in the cell. The second
example runs expt_cell_vclamp.cc with values in region R4 set to zero. <p>

To see the actual values of channel densities and other cell properties, you can set 
the "info_chan" parameter to 1 on the command line. This prints out the density parameters
for all the cell types directly from the arrays in memory.<p>

<h4> Blocking channels </h4>

You can also block channels with simulated TTX (Na1-7), TEA (Kv), FourAP (IA), and ZD7288 (Ih).
You can set these blocking parameters in the experiment file or on the command line.  
These parameters reduce the channel density specified in the density file:<p>

<pre>
density of Na[all]  *= 1 - ttxbath;  // Na density for all cell regions
density of Na[soma] *= 1 - ttxsoma;  // Na density for soma region
density of Na[dend] *= 1 - ttxdend;  // Na density for dendritic regions

density of Kv *= 1 - tea;      // K0-K2
density of KA *= 1 - fourap;   // K3
density of Ih *= 1 - zd7288;   // K4
density of BK *= 1 - ibtox;    // KCA0,KCA2,KCA3
</pre>

The default values of these blocking parameters is 0, so if you don't 
set them, they won't affect the model. <p>

<h4>Setting density file to make gradient</h4>

<p>
The variables EGRAD and LGRAD define columns (default=0, i.e. none) in the density file 
that contain values to set conductance gradients. EGRAD defines a space constant for a 
gradient, positive to increase in the peripheral dendrites, or negative to decrease in 
the peripheral dendrites. LGRAD, defines a linear conductance gradient, which when 
multiplied by the distance from the soma, gives the conductance to be added
to the conductance defined for the region. In this way, EGRAD and LGRAD modify the
conductances for all the other regions.

<p>
To set a gradient of channel density from a density file, set the variable
EGRAD or LGRAD equal to one of the column variables in the density file, for example
R10. You can do this on the command line or in the experiment file. That column
must be otherwise unused.  Then the value for the channel density is equal to
the distance in microns from the soma multiplied by the density value in the
column for the channel. The density values in the other columns add to the 
gradient. In some cases you may want to leave them zero. If you want to have a
negative gradient (getting smaller distal from the soma) you can set the
channel density in the EGRAD or LGRAD column negative. When added to a normal density
value for all the other region columns, this will give a high density at the
soma and a lower value in the distal dendrites. It is also possible to use
both EGRAD and LGRAD simultaneously</p>

For channel conductances:

<pre>
cond = rcond * emul + lgrad * somadist 

Where:
   rcond = value from region column
    emul = exp (somadist / egrad), defult 1
   egrad = value from EGRAD column (expon cond)
   lgrad = value from LGRAD column (linear cond)
somadist = distance from soma
</pre>


For synaptic conductances:

<pre>
cond = scond * cmul * egrad + cgrad

Where:
cmul   = scmul * CMUL value from region 
cgrad  = scgrad * distance from soma
egrad  = exp (distance from soma/segrad), default 1
scond  = SCOND value from nval file
scmul  = SCMUL value from nval file
scgrad = SCGRAD value from nval file
segrad = SEGRAD value from nval file

</pre>

<p>
For some of the rows, the values that are not conductances (RM, RI, VST, VRV, CPL,
CMUL, COL) are set to non-zero default values when the indexes are set out of
range in this way. In "celseg.cc" look for zerodens (default densities).</p>


<h4> Setting 2 density files for one cell type.</h4>

In some cases, it's helpful to have different density files for 2 cells, both of the
same cell type.  This allows one cell to have biophysical parameters such as
channels, and the other cell to have a different combination of densities, for
example, none.  This is useful when subtracting the voltage-clamp currents to
remove the effect of capacitance. The idea is to create 2 cells, where each
cell has the same morphology but a different density file. 

The ndens[][] array sets which density file to use for each cell. The first density
file is called, for example, "dbp1_densfile" (the cell type followed by _densfile)
and the second density file is called dbp1_densfile2. The idea is to make
dbp1_densfile2 have zero for some or all the densities, so that the recordings
from the second cell don't include the effect of voltage-gated channels:

<pre>

  ndens[dbp1][cn=1] = 0;              // set cn 1 to use dbp1_densfile
  ndens[dbp1][cn=2] = 1;              // set cn 2 to use dbp1_densfile2
</pre>

Then, when you record the current from your voltage clamp, you subtract
the current recorded from cell 2 from the current recorded from cell 1.
This allows you to see only the effect of the channels in the first
density file, without any capacitive transients from the cell's capacitance. See the
"Onplot procedure" below:<p>


<h3>Temperature dependence</h3>

The channel conductances vary with temperature, but are defined by convention in the
dens_xxx.n file at 22 deg C. You must be careful to define them correctly for the
temperature at which you are running the model ("tempcel" default 37 deg C).  At
run-time, the conductance densities specified in the dens_xxx.n file are converted 
to number densities (n/um2) by dividing by the channel's unitary conductance (dxxxu) 
(see "celseg.cc"). If channel noise is set, this number density sets the amount
of noise generated by the channels. If you set the unitary conductance to 1e-8, then
the value of conductance density specified in the dens_xxx.n file (S/cm2) also
directly defines the channel number density (n/um2).  The unitary contuctance is
modulated by temperature (controlled by a Q10 "dqxxx" value, see "Channel statement"
in ncman2.html), but its value is specified at 22deg C.  

<p>
<h5>Other channel types</h5>

To see all the possible channel types, see the "retsim/runconf/dens_default_full.n" file.
If you want to add a channel type, if it's similar to an existing one, but
differs in the time constant and/or the voltage offsets, you an set these
parameters in the "runconf/chanparams" file.  If you need to add a new channel
type, see ncman3.html, "Adding New Channel Types".  Once the new channel type
has been added to the simulator, you can add it to retsim in the retsim_var.cc
and celseg.cc files.  Then you can add the new channel type to the dens_xxx.n
file.

<p>

<h5>Region labels</h5>

The region labels are listed in a density file in its first row, above the
numeric values of the table.  They are "R1", "R2", "R3", ..., and are defined
as integers by the simulator. They are used as an index into the internal array
that the simulator creates by reading in the density file.  Alternate labels
are: "DEND_DIST", "DEND_PROX", "SOMA", "AXON", etc.  Both sets of labels are
are defined in retsim.h, and they are supposed to be specified in column 7 of
the morphology file.  If you want to selectively add or remove some regions of
the model, there are selection variables (MAKE_DEND, MAKE_AXON, etc, set in the
nval.n file) that allow you to make one region while ignoring other regions.
You can also make up your own names for region labels and define them as
integers in the experiment file in the defparams() procedure.  Note that the
labels that you want to use (i.e. R1, R1 ..., or DENDD, DENDP, ...) must be
uncommented, that is, without a "#" in the first char on the line.
<p>

Since the region labels are variables, you can redefine them to facilitate
setting meaningful labels. For example, if you are using the standard
regions "R1", "R2", "R10", in some cases you may also want to use "SOMA".
In that case you can redefine the "SOMA" label:

<pre>
SOMA = R_3;      // defines SOMA to be R3, the value R_3 is defined in retsim_var.h
</pre>


<p>
<h5> Adding rows and columns to the dens.n file</h5>

You can also add or remove lines (rows) in the density file, because the index 
label in the first column allows the simulator to correctly insert the information
from the row into the internal channel density array. The first column contains 
names of variables that have been predefined with integer values to index into 
the density array. There are (currently) 38 possible biophysical properties that 
be defined by a row in the density file (see runconf/dens_default_full.n).  
Any properties that you don't include will be set to zero. You can add new lines 
into the middle of the array as long as their label in the first column is set
to a valid name.  You can change the value of the label variables in the
"setparams()" procedure.  You can also define alternate name labels as
variables in the experiment file and use these instead of the existing name
labels.  They only need to contain the correct integer index.  In addition, you
can add or remove columns to define a different number of regions as long as
the label at the top is set correctly. The columns can be in a different order
because they are indexed by the predefined column labels.

<p>
<h5> Setting complam for regions </h5>

The compartment lambda ("complam") sets the size of the compartments.  A larger
complam generates larger compartments, and thus fewer of them.  The default
complam is a global variable, but you can also set the complam separately for 
each celltype (in nval.n), and for each region within a cell (in dens.n). To
set the compartment size for a region, you can include a _CPL (=_CPLAM) row
containing variables or number constants.  If this row is not included, or if
the value is zero or negative, then the complam is taken from the COMPLAM row
in the nval_xxx.n file. If this value is zero or negative, the default complam
is used. Thus, the _CPL row in the density file is optional.  <p>

<h5> Setting color for regions </h5>

To set the color of a cell's spheres and cables for display, you can set the
colors of its regions by including the _COL row in the dens_xxx.n file with
number constants or variables (blue, green, cyan, red, ...).  To tell the
simulator to use these colors, you define the cell's color as "rcolor", which
is a special predefined value.  You can do this in the nval_xxx.n file, or by
setting the internal color value in the nval array using calls in "setparams()"
to "setn()" and "getn()" (defined in "retsim.h"). If you set the cell's
color to "rcolor", but don't include the _COL row in the density file, a
default color map will set the colors by region. You can also set the color for
the whole cell by setting the NCOLOR parameter for that cell type in the
nval_xxx.n file.  If this value is negative, the cell's color will be set by
the cell number (the second dimension of its node number).  

<h5> Setting color from a state variable </h5>

To set the color of a neural element to the voltage, you can set its color
to the predefined variable vcolor, which is set by default to the predefined
constant VCOLOR. This is useful to make a movie of the activity of the cell
(see "Making movies" below). Other useful colors are:

<pre>
CNCOLOR   /* display color from cell number */
VCOLOR    /* display color from voltage */
LCOLOR    /* display color from light inten */
RCOLOR    /* display color from cell region */
CACOLOR   /* display color from light inten */
NAACOLOR  /* display color from activated Na state (see ncdisp.cc) */
NAICOLOR  /* display color from inactivated Na state */
KACOLOR   /* display color from K state */
SGCOLOR   /* display color from syn cond */
SRCOLOR   /* display color from synaptic rate */
</pre>

<p>

<h4>Channel parameter offset file "chanparams"</h4>

In addition to the channel density file you can specify a modification in the
kinetics of the channels for a cell type. You can add an offset voltage to the
activation and inactivation functions, and you can speed or slow the kinetics
to modify the channel behavior. The "retsim/runconf/chanparams" file is a
symbolic file with columns for each cell type that has channels, and rows that
specify offsets or rate multipliers for each type of channel.
<p>

<p>
An entry in "chanparams" for the Na 1.2 channel type:

<pre>
columns:        gca     gcb     gcaoff  gcboff  sb      dsgc    aii

#Na 1.2 channel parameters
Na2.offm:        0.001   0.001   0.001   0.001   0.005   0.0025  0.002
Na2.offh:        0.001   0.001   0.001   0.001   0.005   0.0025  0.002
Na2.taua:        1       1       1       1       1       1       24
Na2.taub:        1       1       1       1       1       1       24
Na2.tauc:        1       1       1       1       1       1       24
Na2.taud:        1       1       1       1       1       1       24
</pre>

<p>
To add a column to the chanparams file, use the
"runconf/chanparams_dupcol" script, e.g.  to duplicate column 5:

<pre>
chanparams_dupcol 5 chanparams > chanparams.new
</pre>


<h3><a name = "7">7. Stimulus types</a></h3>
<p>
Stimuli can include voltage clamp, current clamp, and a variety of light
stimuli such as spots, bars, sine wave gratings, etc. A special "transducer"
element is available that voltage clamps the cell to which it is attached 
at a voltage specified by the stimulus intensity. When the stimulus
procedure is called, the stimulus is added to a list that is run at the
correct time during the simulation (i.e. during the "step()" procedure).
To generate complex stimuli, for example a bar moving to/fro, a set of
stimulus functions is available in "stimfuncs". 
<p>

<h3>Using a stimlus file</h3>

To save RAM memory space and computation time, you can run retsim in "stim" mode
(see nc manual for "stim") to generate a stimulus file, which contains the light
intensities that a stimulus generates in photoreceptors. For a large model with
many photoreceptors and/or complex stimuli such as full-field gratings, the
stimulus file can reduce RAM memory space used because only the stimulus currently
running at a particular time is read in from the stimulus file.  Also, a
stimulus file can can include optical blur and scatter. The convolution that 
computes blur and scatter may take a long time (i.e. many minutes).  <p>

To use a stimulus file, you define the stimulus file name in your experiment
file, and set the optical blur and scatter parameters. After these function
calls, you can define a background with "stim_backgr()" and define the stimuli 
as you would in any retsim experiment. <p>

To make the stimulus file, you run retsim with the "makestim" variable set 
to 1, either in the experiment file, or in the command line. This causes retsim
to make the photoreceptor array and generate a stimulus file according to the
optical blur and scatter parameters and your background and stimulus. Then, to
run the experiment using the stimulus file, you run retsim with "makestim" set
to zero. If you don't want to use a stimulus file, you must remove or comment
out the "stim_file" statement in your experiment file. <p>

You must make a different stimulus file for each unique set of photoreceptor
locations, stimuli, and contrasts.  A good way to do this is to generate a
stimulus file name that contains the name of the experiment, stimulus, and
contrast. You can then call the "stim_file()" procedure with the stimulus file
name, according to a variable (e.g.  "use_stimfile") set on the command line:

<pre>
In the experiment file:

    if (use_stimfile && (stimtype==3 || stimtype==5)) {         // if sineann or grating stimulus 
								//   and --use_stimfile 1 
             const char *fname;
             char stimfile[100];
        if      (stimtype==3) fname = "stim_sbac_sineann_%g_%g";        // set the stimulus file name
        else if (stimtype==5) fname = "stim_sbac_grating_%g_%g";
        sprintf (stimfile,fname,scontrast,barwidth);		// make filename with contrast, stimulus type
        stim_file (stimfile);                                   // set the stimulus file name
    }

retsim --expt_xxx --use_stimfile 1 --makestim 1 ...		// make the stim file
retsim --expt_xxx --use_stimfile 1 --makestim 0 ...		// run model with the stim file
</pre>

<p>

<h4>Setting the blur for a stimlus file</h4>

To learn more about how to define the optical blur and scatter, please see the
"nc" manual under "Stimulus".

<pre>
  In "ncfuncs.h":

    void stim_blur (double blurrad, double scatter_ampl, double scatter_rad, double scatter_pow, double sscale);

  In the experiment file:

    stim_file ("stim_sbac_sineann");          // set the stimulus file name
    stim_blur (10,0,0,0,1);                   // set the blur and stimulus arrays
    stim_backgr (10e3);                       // set the background and stimuli
    stim_spot (...)
</pre>

<h4>Setting center-surround blur</h4>

To make a "center-surround" blur function, useful with "transducers", you can
define 2 blur functions, one positive with amplitude = 1.0, and one negative,
with amplitude = 0.1, each with the same stimulus. Since stimuli are additive,
the 2 blur functions and stimuli will sum to make a center-surround. To set a
negative blur function, a second form of the "stim_blur()" function has a
"blur_ampl" parameter that can be set negative:

<pre>
  In "ncfuncs.h":

    void stim_blur (double blurrad, double blur_ampl, double scatter_ampl, double scatter_rad, double scatter_pow, double sscale);

  In the experiment file:

    stim_file ("stim_sbac_sineann");          // set the stimulus file name
    stim_blur (10,1.0,0,0,0,1);               // set the center blur 
    stim_backgr (0.045);                      // set the background (mV for transducer)
    stim_spot (...)
    stim_blur (100,-0.1,0,0,0,1);             // set the surround blur 
    stim_backgr (0.045);                      // set the background (mV for transducer)
    stim_spot (...)
</pre>
You can make different blur functions for different photoreceptors
(transducers) by setting up independent stimulus channels with the "stimchan"
parameter.  See "Stimulus Channels" in the nc manual.

<br>
<br>

<h3>Transducer photoreceptor type</h3>

To simplify retinal circuitry models, it is often helpful to eliminate the outer
retina (i.e. photoreceptors and horizontal cells) and apply a stimulus directly to an
array of another neuron type, for example, a bipolar cell (analogous to an
optogenetic channel!).  You can do this with a "transducer" which is a type of
photoreceptor that voltage clamps the neuron to which it is attached at the voltage
set by the stimulus intensity. The stimulus can then be set to produce the correct
range of voltages (e.g. -50 to -20 mV), with the pattern specified by the stimulus.
See the "Photoreceptor" statement in the Neuron-C manual.<p>

Example of how to set up transducers (or any other neural element) in an array
of neurons, in this example, dbp1 bipolar cells. A "foreach" (for) statement
finds all dbp1 somas, and "make_transducer" places a transducer with the (X,Y)
location set by the node location at the cell soma.  Place this code in the
beginning of the "runexpt()" procedure in your experiment file:<p>

<pre>

  for(npnt=nodepnt; npnt=foreach(npnt,dbp1,-1,soma,NULL,&cn,NULL); npnt=npnt->next) {
        p = (photorec*)make_transducer(ndn(dbp1,cn,soma));
        p->xpos=npnt->xloc;
        p->ypos=npnt->yloc;
        //      fprintf(stderr, "%g, %g\n", npnt->xloc, npnt->yloc);
  }
</pre>

<h3>Displaying the stimulus</h3>

To display the stimulus, you add a call to the "display_stim()" at an
appropriate time step.  Usually this is done inside a "for" loop so you can set
the start and end of the display times. It may also help to add a "simwait()"
call to slow down the display on the screen. You should add this code in the
"runexpt()" procedure, usually before the main experiment code.  See the
"Display" section in the Neuron-C manual.  Note that you must call the same
stimulus function that will also be run for the main experiment:<p>

<pre>
  if (!make_movie) {
     if (disp==16) {
          double t, dscale, starttime, disp_end, vmax, vmin;

        simtime = 0;                                         /* must be set ahead of stim_backgr() */
        stim_backgr(minten,start=simtime);                   /* turn on  background  */
        stimdur = move_stim(stimtime, celldia, barwidth, theta, velocity, ncycles,
                         econtrast, icontrast, eincr, iincr, direction, mask=1);
        display_size(800);
        disp_end = stimtime+stimdur + 0.05;
        for (starttime=0,t=stimtime; t &.lt; disp_end; starttime = t, t+= 0.002) {
               display_stim(starttime, t, dscale=4, vmax= -0.045, vmin= -0.049);
	       simwait(0.10);
        }
        return;
     }
  }
</pre>
Before the simulation runs, the "disp" variable is set to the value of the "-d"
command line switch. The stimulus will be displayed only when you run retsim
with the "-d 16" command line switch. See "retsim -h".  <p>

<br>

<h3><a name = "8">8. Record types</a></h3>
<p>
A variety of recording methods are available. An experiment can define a
list of nodes to record from, either current or voltage. Light flux into a
photoreceptor can be recorded, as well as the concentration of calcium or a
neurotransmitter or second messenger.  The recorded values can be stored
into an array or file or plotted onto the video screen.
<p>
Several plotting functions are available to generate plots. Plots can
include several traces, e.g. several recording points, and several of these
plots can be displayed simultaneously on the screen. Each trace can have
its own color and a label and units.  Plotting functions are available for
"voltage at a node", "synaptic release rate", or for displaying the voltage
or some other parameter of a neuron as a color applied to the display of
morphology. See the Neuron-C manual for a description of basic plot types, and
"nc/src/ncfuncs.h" for a listing of these functions. Higher level plotting
functions are defined in "plot_funcs.cc" and listed in "retsim.h". See "Useful
retsim functions" below.<p>

<h3>Recording voltage </h3>
Examples of how to plot voltage at a node. The first one plots the voltage at a
node defined by its 3-dimensional node number. The second one plots the voltage
at a node defined by a pointer:<p>

<pre>
     void plot_v_nod(int ct,int cn, int n, double vmin, double vmax,int pcolor,const char *label, int plotnum, double psize);
     void plot_v_nod(node *npnt, double vmin, double vmax,int pcolor,const char *label, int plotnum, double psize);
</pre>

You can use them like this:<p>

<pre>
     int ct, cn, n, pcolor, plotnum;
     double psize;
     int plmin, plmax;
     ...

     plot_v_nod(ct=gca, cn=1, n=324, vmin=plmin, vmax=plmax, pcolor=red,"alpha gc node", plotnum=4, psize=0.5);
   or
     plot_v_nod(ndn(ct=gca, cn=1, n=324), vmin=plmin, vmax=plmax, pcolor=red,"alpha gc node", plotnum=4, psize=0.5);
</pre>
The "ndn()" function returns the appropriate node pointer but will not create a
new node if the node doesn't exist.  The "nd()" function returns the
appropriate node pointer but will create a new node if the node doesn't
exist. See "nc/src/ncfuncs.h".<p>

<h3>Recording total synaptic current or conductance </h3>

To plot the total amount of conductance from synaptic inputs to a cell, you
first create a list of synapses, and then plot the total conductance from that
list. The "isyn_tot()" or "gsyn_tot()" functions do the calculation on the list:<p>

<pre>
  At the beginning of the "runexpt()" procedure:
     int dbplist
     dbplist = 20;

     nsynap = synapse_add (dbplist,dbp1,-1,-1,sbac,1);  /* make list of bipolar synapses onto sbac 1 */
     ...

  In the plotting section of "runexpt()":

     double gmax;
     int plotnum, psize;

     gmax = 1e-9;
     plot_func(gsyn_tot,dbplist,gmax,0);     plot_param("Gtotbp_sbac1",blue, plotnum=1,psize=0.3);
</pre>

<h3>Digital recording filters </h3>

<p>
You can add a digital filter to a recording statement with:

<pre>
     double tau;
    
     tau = 1/(2*PI*2000);
     plotfilt(1,make_filt(tau));			// first-order cutoff 2000 Hz
or e.g.
     plotfilt(3,make_filt(3.2e-5, tau, 0.8e-5));	// third-order, different cutoff freqs

</pre>
The filter is added to the previous plot statement.<p>

To make a 4th order Bessel filter:
<pre>
    plotbessfilt(2000);             // 4th order bessel filter, cutoff = 2000 Hz
</pre>

<p>
<h3><a name = "9">9. Onplot procedure</a></h3>
<p>
An "onplot" procedure can be defined which runs automatically at plot time,
i.e. when the plot traces are updated, controlled by the "ploti" ("plot
increment") variable.  This procedure is an alternative to running the
simulation incrementally using "step()" inside a "for" loop. For example, the
onplot procedure can call a special procedure to compute some function of the
neural circuit's responses, so that the function can be plotted.  The onplot()
function can be used to plot more complex functions, such as a heat map of the
color-coded voltage superimposed on the morphology. For the compiled version,
the onplot procedure is specified by the "setonplot()" procedure.  <p>

<pre>
(compiled:)

 setonplot(onplot);
</pre>

To subtract the currents from one cell from another cell (because you're using
identical morphology with different density files), you can do the subtraction in the
"onplot()" procedure. This runs automatically each plot time step:

<pre>

void onplot(void) {
   current              = i(ndn(ct, 1, elnode));
   if (dbpair) current2 = i(ndn(ct, 2, elnode));
   else        current2 = 0;
   idiff = current - current2;
}
</pre>


To make an I/V plot, you can determine the max or min current
inside the "onplot()" function. When "flag" is set to 1, this
code will compute maxCurrent and gmax, which can then be plotted in
the "runexpt()" procedure vs. voltage.

<pre>
void onplot(void) {
    voltage  = v(ndn(ct,  1, soma));

if (flag) {
   if (outward<=0) {
      cond = idiff / (voltage - gvrev);
      if (cond > gmax) gmax = cond;
      if (maxCurrent > idiff) {         // inward current
        maxCurrent = idiff;
        //fprintf(stderr, "v: %g, i: %g\n", voltage, maxCurrent);
      }
   } else {                             // outward current 
      cond = idiff / (voltage - vk);
      if (cond > gmax) gmax = cond;
      if (maxCurrent < idiff) {
        maxCurrent = idiff;
      }
   }
}
else cond = 0;
</pre>

Inside the "runexpt()" procedure:<p>
<pre>
    if (ivplot) graph(voltage, maxCurrent, gmax);
</pre>


<h3><a name = "10">10. Making movies</a></h3>
<p>
To make a movie, include "onplot_movie" in your experiment file, and call it at
plot time, i.e. inside the "onplot()" procedure.  At each plot step, it
displays the voltage (or other parameter such as inactivation) of the membrane
as a color code superimposed on the morphology. In the interpreted verstion,
you include "onplot_movie.n" and in the compiled version, you include
"onplot_movie.cc". Some experiment scripts have a special movie script, for
example, "onplot_dsgc_movie.cc", which includes "onplot_movie.cc" and sets up
variables and displays appropriate for that script. For example,
"onplot_dsgc_movie" contains a procedure to set up the display of the synaptic
inputs so they will appear in the movie. Both "onplot_movie.cc" and
"onplot_dsgc_movie.cc" have initialization procedures that must be called to
initialize variables.
<p>

<pre>
(interpreted:)

proc onplot()
{
  onplot_movie(); 	/* run movie plot routine at plot time*/
};

(compiled:)

defparams_dsgc_movie();
defparams_onplot_movie();

onplot_dsgc_movie_init();
onplot_movie_init();

if (make_movie) {
  setonplot(onplot_movie); /* set movie plot routine to run at plot time */
  ...
}
</pre>

<p>
You can look at the movie using the "vid" display, or you can 
generate separate frames using the "-P name" command line switch.
This creates an individual PostScript file for each frame, which
you can convert to another appropriate file format. Typically
you will need to convert all the frames to a ppm format, then 
use "mpeg_encode" or "ffmpeg" to create a movie.
<p>

For a black background:<p>
<pre>
retsim --expt dsgc_expt ... options ... --make_movie 1 --space_time 0 --Vmax -0.057 --Vmin -0.065 --colormap 1 --backgnd 0 -v | vid -B 0 -c -P dsgc_expt &
</pre>

For a white background:<p>
<pre>
retsim --expt dsgc_expt ... options ... --make_movie 1 --space_time 0 --Vmax -0.057 --Vmin -0.065 --colormap 1 --backgnd 7 -v | vid -B 7 -c -P dsgc_expt &
</pre>

This generates a sequence of frames: dsgc_expt0001.ps, dsgc_expt0002.ps ... dsgc_expt_xxxx.ps

Then you create the movie with a shell script like this:

<pre>
#! /bin/tcsh -f
#
# make_movie2 script
#
ps2ppm $argv*.ps
movconvert -f "$argv"_ -n 2000                        (compile "nc/src/movconvert.cc")
cp xxx_paramfile2 "$argv"_paramfile2
replace xxx "$argv" "$argv"_paramfile2
mpeg_encode "$argv"_paramfile2
rm "$argv"*.ppm
</pre>

Another script to make a movie:

<pre>
#!/bin/bash
#
#  make_movie3 script
#
ps2ppm $1_*.ps
cnt=0

# count files
for file in `find ./ -name "$1_*.ps"`
do
    fname=`basename $file`;
    dname=`dirname $file`;
    fullname=$dname/$fname;
    cnt=$(($cnt+1))
    
    #echo "cnt=$cnt, $fullname";
done

#blend together backgrounds using movconvert
# for a black background
movconvert -f $1_ -n $cnt

# for a white background,
# movconvert -b 255 -f $1_ -n $cnt

#join .ppms together into video
ffmpeg -f image2 -i $1_%04d.ppm $1.mpg

</pre>

To edit a movie into a shorter movie clip by frame number:

<pre>
#! /usr/mont/bin/nc -c

# subtract constant from filename
# usage: make_movie_cut --filename dsgc_model --begin 218 --end 361
#
# moves filecntb to filecnta
#
if (notinit(filename)) filename = "file";

if (notinit(begin)) begin = 218;
if (notinit(end))     end = 361;

sprintf (buf,"ls -l %s_????.ppm | wc -l\n",filename);
x = system (buf);
nfiles = atof (x);
print "nfiles: ",nfiles;

// erase the files past the end

for (i=end+1; i&lt;=nfiles; i++) {
   sprintf (buf,"rm %s_0%03g.ppm\n",filename,i);
   system (buf);
   printf (buf);
};

// erase the files before the beginning

dest=1;

for (i=dest; i&lt;begin; i++) {
   sprintf (buf,"rm %s_0%03g.ppm\n",filename,i);
   system (buf);
   printf (buf);
};

// copy files from beginning to end

for (i=src=begin; i&lt;=end; i++,src++,dest++) {
   sprintf (buf,"mv %s_0%03g.ppm %s_0%03g.ppm\n",filename,src,filename,dest);
   system (buf);
   printf (buf);
};
</pre>

To edit a movie, you run:

<pre>
make_movie3c dsgc_expt
make_movie_cut --filename dsgc_expt --begin 201 --end 351
make_movie3d dsgc_expt
</pre>

<p>
Since the vid display simply outputs the graphics from the simulator, which is
normally incremental, the frames it generates after the first do not contain
static objects (calibration bars, plot axes, etc) that should remain throughout
the movie.  The "movconvert" program integrates all the frames by adding any
changes that differ from the background color (white or black) in the movie for
the frames in .ppm format. These are then read and converted to a standard
movie format by "mpeg_encode" or "ffmpeg", which you can download from the web.
To view the movie in you can use "mplayer" or another multimedia player.  <p>

<table width="675">
 <tr>
  <td>
<IMG SRC="gcmodel.side.png" height="150" align="left" hspace="20">
   </td>
 </tr>
</table>

<h3><a name = "11">11. Compiling and linking retsim</a></h3>

<p>
An experiment in retsim consists of function calls to the Neuron-C library. These
functions (the NeuronC API) are defined in "nc/src/ncfuncs.h" and described in the
NeuronC User's Manual.  Each function call in "ncfuncs.h" replaces a statement in the
interpreted version of NeuronC.  The retsim script defines an array of neurons and
connects them using these function calls. To see an example of source code for this
compiled version, see the "retsim.cc" model in nc/models/retsim". The command-line
switches for "retsim" are identical to those listed by "nc -h", but note that running
"retsim" without arguments displays a list of simulation experiments and parameters.
In addition simulation variables can be set from the command line.

<p>
The NeuronC API is incorporated into a static library called "libnc.a". This
file is created in "nc/src" and must be linked with a neural circuit program
such as "nc/models/retsim/retsim.cc".  To link this library correctly you may
need to set the "NC_HOME" variable in nc/models/retsim/makefile, either by
setting it as an environment variable or by changing the makefile. The libnc.a
library is created as a static library because as a dynamic library it reduces
run-time speed.

<p>
The experiments defined for "nc/models/retsim" such as "expt_gc_cbp_flash.cc"
are compiled to be dynamically linked to the "retsim" program at runtime, i.e.
each experiment is compiled into a dynamic library, e.g.
"expt_gc_cbp_flash.so". To allow this process of dynamic runtime linking, you
must set the environment variable LD_LIBRARY_PATH or include the directory
where the experiment ".so" file is located in (for Linux) "/etc/ld.so.conf".
That will allow the runtime linker to find "expt_gc_cbp_flash.so" </p>

<pre>
(if using tcsh)  setenv LD_LIBRARY_PATH .            [[ place in your ~/.cshrc file ]]
(if using bash)  export LD_LIBRARY_PATH="."          [[ place in your ~/.profile file ]]
</pre>

<p>
Another way to direct the dynamic linking process is to make a symbolic
link from a file in /usr/local/lib to the experiment .so file in nc/models/retsim.
The dynamic linker will identify the file because it starts with "lib_":

<pre>
ln -s /usr/local/lib/lib_expt_gc_cbp_flash.so expt_gc_cbp_flash.so
</pre>


<p>
At the top of the "retsim.cc" script, several files are included:

<pre>
 #include "ncio.h"         // defines "ncfprintf()" for I/O to a C++ stream
 #include "ncfuncs.h"      // defines the C++ functions for the simulator
 #include "retcolors.h"    // defines the standard colors 0-15  
 #include "retsim.h"       // defines constants and functions for retsim.cc
 #include "retsim_var.cc"  // defines parameters and "setptrs()" which initializes them
 #include "ncinit.h"       // defines a null "setptrs()" in case it is not already defined
 #include "setexpt.h"      // defines "defparams()", "setparams()", "setdens()", "addcells()",
			   //    "addlabels()" and "runexpt()" for the experiment file
</pre>

Most of these header files are in the retsim directory, but some are in the nc/src 
directory.  If you are compiling retsim in a different location than nc/models/retsim,
you need to set the NC_HOME environment variable in "retsim/makefile":

<pre>
# NC_HOME = ~/nc
</pre>

<h4> Compiling retsim on Mac OSX </h4>
The Mac OSX uses a slightly different way to link dynamic libraries.  In the
nc/src and nc/models/retsim directories, you need to edit the "makefile" which is
responsible for compiling and linking retsim.  You only need to comment out/uncomment the
line (i.e. remove or add the "#" at the beginning of the line): 

Compiling nc under OSX is very similar to compiling under Linux. You will need
to have XCode (the C compiler) installed.
<p>

For some of the old Mac compilers, the -O and -O3 optimizations caused retsim
to crash.  You may need to remove the optimizations defined by CFLAGS at the
top of nc/src/makefile:
<p>
<pre>
cd nc/src
</pre>

Change this (lines 1-2, nc/src/makefile):
<pre>
CFLAGS = -O3
# CFLAGS =      # for Mac OSX
</pre>

to this:
<pre>
# CFLAGS = -O3
CFLAGS =      # for Mac OSX
</pre>

Then (in nc/src):
<pre>
make
</pre>

<p>

When compiling retsim (see "Retsim: a retinal simulator" in ncman6.html), you
will also have to modify the makefile for retsim's dynamic linking. The Mac OSX
uses a slightly different way to link dynamic libraries. From the
nc/models/retsim directory, you need to edit the "makefile" which is
responsible for compiling and linking retsim. You only need to uncomment the
line (i.e. remove the "#"):
<p>

<pre>
cd ~/nc/models/retsim
</pre>


Change this (line 1, nc/src/retsim/makefile):
<pre>
CFLAGS = -Ofast
</pre>

to this:
<pre>
# CFLAGS = -Ofast
</pre>

Change this (line 6, nc/src/retsim/makefile):
<pre>
# CFLAGS =               # for Mac OSX
</pre>

to this:
<pre>
CFLAGS =               # for Mac OSX
</pre>

Change this (line 47, nc/src/retsim/makefile)
<pre>
# OSFLAGS = -DMACOSX
</pre>

to this:
<pre>
OSFLAGS = -DMACOSX
</pre>

<p>

After you've modified the makefiles, then enter "make" on the
command line. If you need to modify nc/src/makefile, you'll need
to run make there, too. This will compile and link all the source code
correctly on the Mac. For this to work, you will need to have
XCode (the C compiler) installed. <p>

<h4> Compiling retsim on a 64-bit Linux machine </h4>

Edit nc/models/retsim/makefile, and near the beginning of the file
comment out the line:
<p>

<pre>
CFLAGS = -Ofast
</pre>

Uncomment the line:

<pre>
# CFLAGS = -Ofast -fPIC  # for 64-bit systems
</pre>

so it looks like this:
<p>
<pre>
# CFLAGS = -Ofast
CFLAGS = -Ofast -fPIC  # for 64-bit systems
</pre>

For Mac OSX systems you don't need to uncomment the -Ofast -fPIC lines.

<br>

<h3><a name = "12">12. Coding: parameter initialization</a></h3>

To set parameters from the command line, a function call to "setptr()" or
"setptrn()" is necessary.  These function calls find and set the address of a
parameter and store it in a symbol table for the simulator's run-time
initialization. The "setptr()" function initializes the variable to its
"undefined" value, so that later the "notinit()" function can tell whether the
variable has been initialized -- this is useful to decide whether a default
value should be applied.  The "setptrn()" function is exactly the same as
"setptr()" except that it does not initialize the parameter.  This is useful
when you want to initialize the variable to a certain value.  <p>

<h4>Examples of experiments </h4>

To see how to set up an experiment, please look at the functions and experiment files in
the "nc/models/retsim" folder described below.
<p>


<h4><a name = "12.2">12.2 Running a voltage clamp protocol</a></h4>

A common protocol for an experiment is to perform voltage clamp for a series of
voltage steps and record the currents. To do this you use a "for" loop that
sets time back to zero and increments the pulse voltage each time it runs.<p>

<pre>
  void runexpt(void)
  {
    double Vmin, Vmax;
    ...
    if (notinit(prestimdur))    prestimdur =  0.02;      /* sets default timing, override on command line
    if (notinit(poststimdur))  poststimdur =  0.05;
    if (notinit(tailcurdur))    tailcurdur =  0.02;
    ...
    plot_i_nod(ct=gca,cn=1,n=soma,Vmin=-.067,Vmax =-.027,colr=cyan,"", -1, -1); /* plot soma current*/
    ...

    sprintf (savefile,"vclamp_save%06d",getpid());       /* add process id to save file name */
    savemodel (savefile);				 /* make a save file to save simulation state
    if (vstart < vstop) sign = 1;
    else                sign = -1;
    for (i=0,vpulse=vstart; (vpulse*sign)<=(vstop*sign+1e-6); i++,vpulse += vstep) {
        simtime = 0;					/* set the simulation time back to zero */
        pulsedur = move_stim(stimtime, ...);		/* run the stimulus */
        vclamp (ndn(ct,cn, soma), vhold, simtime,  prestimdur);       /* clamp to vhold */
        vclamp (ndn(ct,cn, soma), vpulse, simtime,  pulsedur);        /* clamp to the pulse voltage */
        vclamp (ndn(ct,cn, soma), tailvolt, simtime,  tailcurdur);    /* look at the tail currents */
        vclamp (ndn(ct,cn, soma), vhold, simtime, poststimdur);       /* return to vhold */
        restoremodel (savefile);				      /* restore all states to before vclamp */
    }
    unlink (savefile);						      /* remove the save file */
  }
</pre>
Note that the variables tested by notinit() must be defined in "defparams()" in
order to be set from the command line.<p>

</p>

<h4><a name = "13">13. Examples of how to run retsim</a></h4>

<pre>
   retsim --expt gc_cbp_flash --ninfo 2 -d 1 -v                      | vid 

   retsim --expt gc_cbp_flash --ninfo 2 | less                                    # quit from less with "q" 

   retsim --expt gc_cbp_flash --ninfo 2 --node_scale -3.05 -d 9 -v   | vid 

   retsim --expt gc_cbp_flash --ninfo 2 -d 9 -v                      | vid -c &gt; file.ps  #  make .ps file.
   
   retsim --expt gc_cbp_flash -d 1 -R           &gt; file.pov

   povray +h1000 +w1000 +ifile.pov +dx                                              #  generate image with povray

   retsim --expt gc_cbp_flash --mxrot 90 -d 1 -v                     | vid 

   retsim --expt gc_cbp_flash --flip 1 -d 1 -v                       | vid 

   retsim --expt gc_cbp_flash --ninfo 2 --arrsiz 100 -d 1 -v         | vid 

   retsim --expt gc_cbp_flash --ninfo 2 --n_cbp 1 --n_gc 0 -d 1 -v   | vid 

   retsim --expt gc_cbp_flash --ninfo 2 -v                           | vid 

   retsim --expt gc_cbp_flash           &gt; file.r 

   plotmod file.r | vid                                                             #   display plots from data file
   
</pre>

<h4>The stderr and stdout streams</h4>

To have all the information from "ninfo" placed into the output file, you can 
redirect the stderr and stdout streams into a file:

<pre>

For csh/tcsh shell:

retsim --expt ... --ninfo 2 ... > file.r           [only the stdout (data) stream goes into the file]
retsim --expt ... --ninfo 0 ... > file.r           [no connection info printed, only the stdout stream goes into the file]
retsim --expt ... --ninfo 2 ... >& file.r          [both stdout and stderr streams go into the file] 
</pre>
Adding a second & after the file name runs the command in the background:
<pre>
retsim --expt ... --ninfo 2 ... >& file.r &


For some versions of the bash shell, you may need to change ">&" to "2>&1 >":

retsim --expt ... --ninfo 2 ... 2>&1 > file.r     [both stdout and stderr streams go into the file] 

</pre>



<h3><a name = "14">14. Useful retsim functions</a></h3>

<pre>
Plot functions defined in "plot_funcs.cc" and "retsim.h":

plot_v_nod()           Plots voltage at a node. Can be combined with searches for nodes by location.
plot_i_nod()           Plots current at a node. Can be combined with searches for nodes by location.
plot_l_nod()           Plots light flux at a node. Can be combined with searches for nodes by location.
plot_ca_nod()          Plots calcium conc at a node. Can be combined with searches for nodes by location.
plot_ca_syn()          Plots calcium conc at a synapse. Can be combined with searches for nodes by location.
plot_spike_rate()      Plots instantaneous spike rate as color of point.
plot_chan()            Plots channel conductance or the population of any Markov state
plot_chan_cond()       Plots channel conductance, can be combined with searches for nodes by location.
plot_chan_current()    Plots channel current, can be combined with searches for nodes by location.
plot_synrate()         Plots synaptic release, including vesicle release rate, vesicles, and postsynaptic conductance.

void plot_l_nod(int ct,int cn, int n, double lmin, double lmax,int pcolor,const char *label, int plotnum, double psize);
void plot_v_nod(int ct,int cn, int n, double vmin, double vmax,int pcolor,const char *label, int plotnum, double psize);
void plot_v_nod(node *npnt, double vmin, double vmax,int pcolor,const char *label, int plotnum, double psize);
void plot_i_nod(int ct,int cn, int n, double vmin, double vmax,int pcolor,const char *label, int plotnum, double psize);
void plot_ca_nod(int ct, int cn, int n,double maxca, int pcolor, const char *label, int plotnum, double psize);
void plot_ca_nod(int ct, int cn, int n, int sh, double maxca, int pcolor, const char *label, int plotnum, double psize);
void plot_ca_nod(node *n, int sh, double maxca, int pcolor, const char *label, int plotnum, double psize);
void plot_ca_syn(synapse *s, int sh, double maxca, int pcolor, const char *label, int plotnum, double psize);
void plot_ca_syn(synapse *s, double maxca, int pcolor, const char *label, int plotnum, double psize);
void plot_cabufb_nod(int ct, int cn, int n,double maxca, int pcolor, const char *label, int plotnum, double psize);
void plot_cabufb_nod(int ct, int cn, int n, int sh, double maxca, int pcolor, const char *label, int plotnum, double psize);
void plot_ph_nod(node *npnt, double maxnt, double minnt, int pcolor, const char *label, int plotnum, double psize);
void plot_ph_nod(int ct, int cn, int n, double maxnt, double minnt, int pcolor, const char *label, int plotnum, double psize);


Functions to add synapse to list(s) of synapses for run time recording, analysis, and display:

int synapse_add (int synlist, int ct, int cn, int nod, int ct2, int cn2);
int synapse_add (int synlist, int ct, int cn, int nod, int ct2, int cn2, double vrev);
int synapse_add (int synlist, int ct, int cn, int nod, int ct2, int cn2, int connum);

Functions to plot parameters from lists of synapses (defined by "synapse_add()" above):

double rsyn_avg (double sl, double time);           Plot average rate of list of synapses
double isyn_avg (double sl, double time);           Plot average current of list of synapses
double isyn_tot (double sl, double time);           Plot average conductance of list of synapses
double gsyn_avg (double sl, double time);           Plot total current of list of synapses
double gsyn_tot (double sl, double time);           Plot total conductance of list of synapses
double gnmda_syn_tot (double sl, double time);      Plot total conductance of list of NMDA synapses

Functions to plot synaptic parameters, using different combinations of arguments:

void plot_synrate(int ct, int cn, int nod, int prate, double rmin, double rmax, int pves, double fmin, double fmax, int pcond, double cmin, double cmax, int pcolor, int plotnum, const char *plname, double plsize);
void plot_synrate(int ct, int cn, int nod, double rmin, double rmax, int pcolor, int plotnum, const char *plname, double plsize);
void plot_synrate(int ct, int cn, int prate, double rmin, double rmax, int pves, double fmin, double fmax, int pcond, double cmin, double cmax, int pcolor, int plotnum, const char *plname, double plsize);
void plot_synrate(int ct, int cn, int prate, double rmin, double rmax, int pves, double fmin, double fmax, int pcolor, int plotnum, const char *plname, double plsize);
void plot_synrate(int ct, int cn, double rmin, double rmax, int pcolor, int plotnum, const char *plname, double plsize);
void plot_synves (int ct, int cn, int ves, double fmin, double mmax, int pcolor, int plotnum, const char *plname, double plsize);
void plot_synves (int ct, int cn, double fmin, double mmax, int pcolor, int plotnum, const char *plname, double plsize);
void plot_syncond(int ct, int cn, int nod, double cmin, double cmax, int pcolor, int plotnum, const char *plname, double plsize);
void plot_syncond(int ct, int cn, double cmin, double cmax, int pcolor, int plotnum, const char *plname, double plsize);
void plot_synrate(synapse *s, int prate, double rmin, double rmax, int pves, double fmin, double fmax, int pcond, double cmin, double cmax, int pcolor, int plotnum, const char *plname, double plsize);
void plot_synrate(synapse *s, double rmin, double rmax, int pcolor, int plotnum, const char *plname, double plsize);
void plot_syncond(synapse *s, double cmin, double cmax, int pcolor, int plotnum, const char *plname, double plsize);
void plot_syncondp(synapse *s, double cmin, double cmax, int pcolor, int plotnum, const char *plname, double plsize);
void plot_synves(synapse *s, double cmin, double cmax, int pcolor, int plotnum, const char *plname, double plsize);

Functions to plot output synaptic rate, using different combinations of arguments:

void plot_synrate_out(int ct, int cn, double rmin, double rmax, int colr);
void plot_synrate_out(int ct, int cn, double rmin, double rmax, int colr, const char *plname);
void plot_synrate_out(int ct, int cn, double rmin, double rmax, int colr, double plsize);
void plot_synrate_out(int ct, int cn, double rmin, double rmax, int colr, const char *plname, double plsize);

void plot_synrate_out(int ct, int cn, int ct2, int cn2, double rmin, double rmax, int colr, int prate);
void plot_synrate_out(int ct, int cn, int ct2, int cn2, double rmin, double rmax, int colr, int prate, const char *plname);
void plot_synrate_out(int ct, int cn, int ct2, int cn2, double rmin, double rmax, int colr, int prate, double plsize);
void plot_synrate_out(int ct, int cn, int ct2, int cn2, double rmin, double rmax, int colr, int prate, const char *plname, double plsize);

void plot_synrate_out(int ct, int cn, int ct2, int cn2, double rmin, double rmax, double fmax, int colr, int prate);
void plot_synrate_out(int ct, int cn, int ct2, int cn2, double rmin, double rmax, double fmax, int colr, int prate, const char *plname);
void plot_synrate_out(int ct, int cn, int ct2, int cn2, double rmin, double rmax, double fmax, int colr, int prate, double plsize);
void plot_synrate_out(int ct, int cn, int ct2, int cn2, double rmin, double rmax, double fmax, int colr, int prate, const char *plname, double plsize);

void plot_synrate_out(int ct, int cn, int nod, int ct2, int cn2, double rmin, double rmax, int colr,int prate);
void plot_synrate_out(int ct, int cn, int nod, int ct2, int cn2, double rmin, double rmax, int colr,int prate, const char *plname);
void plot_synrate_out(int ct, int cn, int nod, int ct2, int cn2, double rmin, double rmax, int colr,int prate, int pves, double plsize);
void plot_synrate_out(int ct, int cn, int nod, int ct2, int cn2, double rmin, double rmax, int colr,int prate, int pves, const char *plname, double plsize);

void plot_synrate_out(int ct, int cn, int nod, int ct2, int cn2, double rmin, double rmax, double fmax, int colr,int prate);
void plot_synrate_out(int ct, int cn, int nod, int ct2, int cn2, double rmin, double rmax, double fmax, int colr,int prate, const char *plname);
void plot_synrate_out(int ct, int cn, int nod, int ct2, int cn2, double rmin, double rmax, double fmax, int colr,int prate, int pves, double plsize);
void plot_synrate_out(int ct, int cn, int nod, int ct2, int cn2, double rmin, double rmax, double fmax, int colr,int prate, int pves, const char *plname, double plsize);

Functions to plot channel parameters:

void plot_spike_rate(int ct, int cn, int n, int pcolor, const char *label, int plotnum, double psize);

void plot_chan(int ct, int cn, int n, int ctype, int stype, int param, double pmax, double pmin);
void plot_chan(int ct, int cn, int n, int ctype, int stype, int param, int pval, double pmax, double pmin);
void plot_chan_current(int ct, int cn, int n, int ctype, int stype, double pmax, double pmin);
void plot_chan_current(int ct, int cn, int n, int ctype, int stype, double mult, double pmax, double pmin);
void plot_chan_cond(int ct, int cn, int n, int ctype, int stype, double pmax, double pmin);
void plot_chan_cond(int ct, int cn, int n, int ctype, int stype, double mult, double pmax, double pmin);
void plot_chan_state(int ct, int cn, int n, int ctype, int stype, int param, double pmax, double pmin,
		const char *label, int plotnum, double psize);

Example:

plot_chan(ct=dbp1, cn=1, dend_node, CGMP, 1, G, state=1, pmax=2, pmin=0);

Plot functions in "ncfuncs.cc" (defined in ncfuncs.h):

plot (V, <node>);
plot (V, <node>, max=<expr>, min=<expr>);
plot (I, <node>);
plot (L, <node>);
plot (V, <element>);

plot (FAn,  n, <elemnum>, max=<expr>, min=<expr>);
plot (FBn,  n, <elemnum>, max=<expr>, min=<expr>);
plot (FCn,  n, <elemnum>, max=<expr>, min=<expr>);
plot (Ca, n, <elemnum>, max=<expr>, min=<expr>);
plot (G,  n, <elemnum>, max=<expr>, min=<expr>);
plot_var 	       Plots value of variable at run time
plot_func()            Plots value returned by function at run time

Misc functions defined in "celfuncs.cc" and "retsim.h":

round()                Rounds up a floating point number to the nearest integer
modangl()              Converts angle to range 0 - 2PI
sindeg()               Sine function in degrees
cosdeg()               Cosine function in degrees
atanx()                Similar to atan2(y,x) function in the C library

inrange()              Determines whether number is within a range
rrange()               Returns random number within a range
mid()                  Returns middle element in array
midrow()               Returns start of middle row of array
ff()                   Returns 1 or -1 with 50% chance
gauss()                Returns gaussian function

node_angle()           Returns angle between 2 nodes
get_angles()           Calculates average orientation angle of dendrite 
rad_dist()             Computes distance from node along dendrite to soma
rad_dir()              Determines which node of a cable segment is closest to the soma

taperden()             Makes tapered dendrite
taperdistden()         Makes tapered dendrite, starting from existing dendrite
taperdia()             Finds diameter of distal dendrite
sigm()                 Returns y-val on specified sigmoidal function
comp_phase()           Computes phase for a sine wave with a specified delay time
sinewaves()            Adds 2 sine waves, returns sum
makanatfile()          Makes an anatomy file out of an existing artificial cell morphology
dendn_node()           Look up number in dendn column of morph file, return its node number

Misc functions defined in "synfuncs.cc" and "retsim.h":

print_connections()      Print connections for all cells of a given type. 
print_avg_connections()  Print the average number of connections to other types 
ncel_in()              Return number of presynaptic cells of a given type to a specific cell
tot_ncel_in()          Return total number of presynaptic cells to a specific cell
tot_ncel_ind()         Return total number of presynaptic cells of a different type to a specific cell
ncel_out()             Return number of postsynaptic cells of a given type to a specific cell
tot_ncel_out()         Return total number of postsynaptic cells to a specific cell
tot_ncel_outd()        Return total number of postsynaptic cells of a different type to a specific cell
connected()            Determine whether a cell is synaptically connected to another
connected2()           Determine whether a cell synaptically converges from a second to a third type
connected3()           Determine whether a cell converges from a second to a third type


Functions to find cells and nodes within cells:

findmid()              Finds middle cell in array, useful for recording
findmida()             Finds cell closest to x,y offset in array, useful for recording
findmidc()             Finds middle cell by count

findnodloc()           Finds node closest to x,y offset in celltype, cellnum. Maxdist is optional
findnodlocr()          Finds node closest to x,y offset from soma of celltype, cellnum. Maxdist is optional
findnodlocz()          Finds node closest to x,y offset of celltype, within z range

int findmid(int ct, double xoffset, double yoffset);
int findmida(int ct, double xoffset, double yoffset);
int findnodloc(int ct, int cn, double xoffset, double yoffset);
int findnodloc(int ct, int cn, double xoffset, double yoffset, double maxdist);
int findnodlocr(int ct, int cn, double xoffset, double yoffset);
int findnodlocr(int ct, int cn, double xoffset, double yoffset, double maxdist);
int findnodlocra(int ct, int cn, double roffset, double theta);
int findnodlocra(int ct, int cn, double roffset, double theta, double maxdist);
int findnodlocz(int ct, int cn, double xoffset, double yoffset,double zmax, double zmin);


findsynloc()           Finds synapse at node closest to x,y offset of celltype, cellnum is optional
findsynlocr()          Finds synapse at node closest to x,y offset from soma of celltype, cellnum, 
                         vrev, maxdist are optional, second cell of celltype2, cellnum2 is optional

Functions to find a synapse by cell and location:

synapse *findsynloc(int ct, double xoffset, double yoffset);
synapse *findsynloc(int ct, int cn, double xoffset, double yoffset);
synapse *findsynloc(int ct, int cn, double xoffset, double yoffset, double vrev);
synapse *findsynloc(int ct, int cn, double xoffset, double yoffset, double vrev, double maxdist);
synapse *findsynloc(int ct, int cn, int ct2, int cn2, double xoffset, double yoffset, double vrev);
synapse *findsynloc(int ct, int cn, int ct2, int cn2, double xoffset, double yoffset, double vrev, double maxdist);

Find by direction from center of array:

synapse *findsynloca(int ct, double roffset, double theta);
synapse *findsynloca(int ct, int cn, double roffset, double theta);

Find by distance from soma:

synapse *findsynlocr(int ct, int cn, double xoffset, double yoffset);
synapse *findsynlocr(int ct, int cn, double xoffset, double yoffset, double vrev);
synapse *findsynlocr(int ct, int cn, int ct2, int cn2, double xoffset, double yoffset, double vrev);
synapse *findsynlocr(int ct, int cn, int ct2, int cn2, double xoffset, double yoffset, double vrev, double maxdist);

Find by radius, theta from soma:

synapse *findsynlocra(int ct, int cn, double roffset, double theta);
synapse *findsynlocra(int ct, int cn, double roffset, double theta, double vrev);
synapse *findsynlocra(int ct, int cn, int ct2, int cn2, double roffset, double theta, double vrev);
synapse *findsynlocra(int ct, int cn, int ct2, int cn2, double roffset, double theta, double vrev, double maxdist);
int findsynlocx(int ct, int cn, double xoffset, double yoffset);

find_maxmin()          Calculates max,min in x,y of complete array, celltype and cellnum are optional
find_maxrad()          Calculates max radius of complete array, celltype and cellnum are optional


<h4> Stimulus functions for retsim, defined in stimfuncs.cc and stimfuncs.h: </h4>
<pre>
double movebar(double starttime, double xcent, double ycent, double r1, double r2,
                                double bwidth, double blength, double theta, double velocity, double sinten);

double movebar(double starttime, double xcent, double ycent, double r1, double r2,
		double bwidth, double theta, double velocity, double sinten);

double stepspot(double starttime,double x1,double x2,double y,double bdia,
		double velocity, double sinten);

double moveannulus(double starttime,double xcent, double ycent, double r1,double r2,
		double anndia, double velocity, double sinten);

void movesineann (double x,double y,int direction,double ann_gaussenv,double centdia,
                double phase,double speriod, double stfreq,double sinten,
                double contrast,int sq, double starttime,double sdur);

void movewindmill (double x, double y, int direction, double ann_gaussenv,double centdia,
		double phase, double speriod, double stfreq, double sinten, double scontr,
		int sq, double starttime, double sdur);
	
double twospot(double starttime, double xcent, double ycent, double r1, double r2,
		double dia, double theta, double sinten, double dur, double timestep);

void square_wave_i (node *nd, double freq, double i, double start, double dur);

void sine_wave_i (node *nd, double freq, double i, double start, double dur, double tstep);

void ramp_c (node *nd, double cstart, double cstop, double start, double dur, double tstep);
void ramp_v (node *nd, double vstart, double vstop, double start, double dur, double tstep);

</pre>
<br>

<h4>Standard stimulus functions in nc, defined in ncfuncs.h (ncstimfuncs.cc): </h4>

<pre>
void stim_node (node *npnt, double inten, double start, double dur, double wavel);

void stim_node (node *npnt, double inten, double start, double dur);

void stim_cone (node *npnt, double inten, double start, double dur, double wavel);

void stim_cone (node *npnt, double inten, double start, double dur);

void stim_rod  (node *npnt, double inten, double start, double dur, double wavel);

void stim_rod  (node *npnt, double inten, double start, double dur);

void stim_bar (double width, double length, double xloc, double yloc,
               double xcent, double ycent, double scale, double orient,
               double inten, double start, double dur, double wavel, double mask);

void stim_bar (double width, double length, double xloc, double yloc, double orient,
          double inten, double start, double dur, double wavel, double mask);

void stim_bar (double width, double length, double xloc, double yloc, double orient,
          double inten, double start, double dur);

void stim_spot (double dia, double xloc, double yloc, double xcent, double ycent,
                double scale, double inten, double start, double dur, double wavel, double mask);

void stim_spot (double dia, double xloc, double yloc, double inten,
                        double start, double dur, double wavel, double mask);

void stim_spot (double dia, double xloc, double yloc, double inten, double start, double dur);

void stim_ispot (double dia, double xloc, double yloc, double inten,
                        double start, double dur, double wavel, double mask, int invert);

void stim_grating (int type, double speriod, double sphase, double orient,
		double xloc, double yloc, double tfreq, double drift,
		double inten, double contrast, double wavel,
		double xenv, double yenv, double mask,
		double start, double dur);

void stim_sine(double speriod, double sphase, double orient,
		double xloc, double yloc, double xcent, double ycent,
		double tfreq, int drift, double scale,
		double inten, double contrast, double start, double dur,
		double wavel, double mask);

void stim_sine(double speriod, double sphase, double orient, double
		xloc, double yloc, double tfreq, int drift,
		double inten, double contrast, double start, double dur);
		
void stim_gabor(double speriod, double sphase, double orient,
		double xloc, double yloc, double xcent, double ycent,
		double tfreq, double drift, double scale,
		double inten, double contrast, double xenv, double yenv, int sq,
		double start, double dur, double wavel, double mask);

void stim_gabor(double speriod, double sphase, double orient, double xloc, double yloc,
		double tfreq, double drift, double inten, double contrast,
		double xenv, double yenv, int sq, double start, double dur);
		
void stim_sineann(double speriod, double sphase, double xloc, double yloc,
		double xcent, double ycent, 
		double tfreq, double drift, double scale,
		double inten, double contrast, double xenv, int sq,
		double start, double dur, double wavel, double mask);

void stim_sineann(double speriod, double sphase, double xloc, double yloc,
		double tfreq, double drift, double inten, double contrast,
		double xenv, double start, double dur);

void stim_sineann(double speriod, double sphase, double xloc, double yloc,
		double tfreq, double drift, double inten, double contrast,
		double xenv, int sq, double start, double dur);

void stim_windmill(double speriod, double sphase, double xloc, double yloc,
		double xcent, double ycent, double tfreq, double drift, 
		double scale, double inten, double contrast, double xenv, 
		int sq, double start, double dur, double wavel, double mask);

void stim_windmill(double speriod, double sphase, double xloc, double yloc,
		double tfreq, double drift, double inten, double contrast,
		double xenv, double start, double dur);

void stim_windmill(double speriod, double sphase, double xloc, double yloc,
		double tfreq, double drift, double inten, double contrast,
		double xenv, int sq, double start, double dur);

void stim_checkerboard(double width, double height, int xn, int yn,
		double orient, double xloc, double yloc,
		double xcent, double ycent, double scale,
		double tfreq, double inten, double contrast,
		double start, double dur, double **stim_rndarr, int *stim_nfr);

void stim_checkerboard(double width, double height, int xn, int yn, 
		double orient, double xloc, double yloc,
		double tfreq, double inten, double contrast,
		double start, double dur,double **stim_rndarr, int *stim_nfr);

void stim_file (const char *filename);
void stim_backgr (double backgr, double wavel, double mask, double start);
void stim_backgr (double backgr, double start);
void stim_backgr (double backgr);

void vclamp (node *npnt, double inten, double start, double dur);
void cclamp (node *npnt, double inten, double start, double dur);
void puff (node *npnt, int puffmsg, double inten, double start, double dur);
</pre>


</pre>

<h3><a name = "15">15. Experiment files</a></h3>

Several experiment files are included with retsim. They start with some
definitions and command line variables, and then set the cell types to be
generated. Then the nval_xxx.n and dens_xxx.n files are read in, followed by
the morphology file(s). 

<pre>
expt_aii_dbp.cc               Make a bipolar cell and run voltage-clamp 
expt_cbp_vclamp.cc            Voltage-clamp a bipolar cell                            
expt_cbp_cclamp.cc            Current-clamp a bipolar cell                            
expt_aii_flash.cc             Make an AII amacrine, RBPs, and rods with light stim
expt_cbp_feedback.c           Make a bipolar cell with amacrine feedback 
expt_cbp_flash.cc             Make a bipolar cell with light stim
expt_cell_vclamp.cc           Voltage-clamp a cell 
expt_cone_hz.cc               Construct cone-horizontal cell circuit and run voltage clamp 
expt_cone_hz_cvc.cc           Construct cone-horizontal cell circuit and run voltage clamp  
expt_cone_hz_hvc.cc           Construct cone-horizontal cell circuit and run voltage clamp    
expt_dsgc_calib.cc            Voltage clamp a cell  
expt_dsgc_cbp_bar.cc          Construct a bipolar cell and stimulate with light bar 
expt_dsgc_cbp_stim.cc         Construct a bipolar cell and stimulate with light   
expt_dsgc_cbp_twospot.cc      Construct a bipolar cell and stimulate with spots   
expt_dsgc_chans.cc            Voltage clamp a DS ganglion cell
expt_dsgc_pair.cc             Voltage clamp 2 DSGCs, one with chans and other without, subtract
expt_dsgc_sbac_bar.cc         Construct DSGC with SB amacrine, stimulate with light bar
expt_gc_Rin.cc                Compute Rin for ganglion cell
expt_gc_cbp_flash.cc          Construct On ganglion cell and its feedforward cone bipolar circuit
expt_gc_bphz_flash.cc         Construct On ganglion cell and its presynaptic cone bipolar circuit
expt_gc_cbp_aii_flash.cc      Construct On ganglion cell and its bipolar and AII amacrine circuit
expt_gc_cbp_am_flash.cc       Construct On ganglion cell with bipolar cells and amacrine feedback
expt_gcoff_hbp_flash.cc       Construct Off ganglion cell and its feedforward cone bipolar circuit
expt_gcoff_hbp_flashes.cc     Construct Off ganglion cell and its feedforward cone bipolar circuit
expt_gcoff_hbp_flicker.cc     Stimulate Off ganglion cell circuit with flickering spot
expt_rbp_aii_a17.cc           Construct rod bipolar connected to AII and A17 amacrines
expt_sbac_stim.cc             Construct arrays of SB amacrine cells and stimulate with moving bar
expt_sbac_vclamp.cc           Voltage-clamp a SB amacrine cell
expt_wfamac.cc                Make a wide-field amacrine cell

expt_cell_Rin.cc              Make a cell from a morphology file and measure Rin (temporal) 
expt_surf_area.c              Make a cell from a morphology file and measure surface area, Rin (static)
expt_morph_props.cc           Make a cell from a morphology file and display morphological props 
expt_test.cc                  Very simple test file to start an experiment

</pre>

<p>

A useful experiment is "expt_surf_area.cc".

<pre>
# surface area and conductances
#
retsim --expt surf_area --celltype dsgc --n_dsgc 1 --dsgc_file morph_ds1e --dsgc_densfile dens_dsgc.n 
       --nvalfile nval_dsgc_sbac.n --dvrev -0.06 --dvst -0.06 --drm 10e3 --dendrm 35e3 --dri 200 
       --ninfo 2 > dsgc_surf_area.txt
</pre>

This command gives the printout:

<pre>


# Retina simulation
#
#   retsim version:    1.7.56     
#   nc version:        6.2.15     
#   date:              Fri Jan 30 16:30:00 EST 2015     
#   machine:           bip     
#   experiment:        surf_area     
#   confdir:           runconf
#   nvalfile:          nval_dsgc_sbac.n
#   dsgc  morph:       morph_ds1e,   densities: dens_dsgc.n
#   chanparams file:   chanparams
#
#c 3315 neural elements (21.6 MB) converted to compartments.
#c 3315 neural elements saved.
#c Total memory space used 24.3 MB.
#c 453 comps, 3287 nodes, 452 connections, 2532 channels.
#
# Surface area and conductances of dsgc
#
# nval file          nval_dsgc_sbac.n
# density file       dens_dsgc.n 
#
# Region   R12       R15       R16       R17       R18       R19       Tot 
# Label    DendD     Soma      HCK       AxonT     AxonP     AxonD     Cell 
# color    blue      red       blue      cyan      magenta   green     
#
# Area     1.464e+04 917.6     5.235     34.59     1475      7689      2.476e+04 um2
# CompLam  0.1       0.2       0.1       0.1       0.1       0.1                 Lambda/comp
#
# Rm       1e+04     1e+04     1e+04     1e+04     1e+04     1e+04     1e+04     Ohm-cm2
# Ri       200       200       200       200       200       200                 Ohm-cm
# Cm       1         1         1         1         1         1                   uF/cm2
#
# Rin      68.3      1.09e+03  1.91e+05  2.89e+04  678       130       40.39     MOhm (from Rm only)
# Cond     1.464e+04 917.6     5.235     34.59     1475      7689      2.476e+04 pS   (from Rm only)
# Cm       146.4     9.176     0.05235   0.3459    14.75     76.89     247.6     pF
# Cond/cap 100       100       100       100       100       100       100       pS/pF
#
# NA2      0         0         0         0         50        50        18.51     mS/cm2
# NA6      35        4         4         100       0         0         20.98     mS/cm2
# K1       15        15        15        20        10        10        13.16     mS/cm2
# K3       35        35        35        0         0         0         22        mS/cm2
# K4       0         0.09      0         0.8       0.8       0         0.05211   mS/cm2
# KCA4     0.12      0.12      0         0         0         0         0.07539   mS/cm2
# KCA5     0.01      0.04      0.02      0         0         0         0.007399  mS/cm2
# CA0      0.014     0.014     0.014     0         0         0         0.008799  mS/cm2
#
# NA2      0         0         0         0         737.5     3845      4582      nS
# NA6      5123      36.7      0.2094    34.59     0         0         5195      nS
# K1       2196      137.6     0.7853    6.917     147.5     768.9     3258      nS
# K3       5123      321.1     1.832     0         0         0         5446      nS
# K4       0         0.8258    0         0.2767    11.8      0         12.9      nS
# KCA4     17.57     1.101     0         0         0         0         18.67     nS
# KCA5     1.464     0.367     0.001047  0         0         0         1.832     nS
# CA0      2.049     0.1285    0.000733  0         0         0         2.179     nS
</pre>

For each region of the cell, the printout gives several types of information: the surface area, the compartment size "complam", the Rm, Ri, and Cm, the input resistance Rin and the conductance calculated from Rm, the capacitance h, and the ratio of conductance/capacitance.  It also gives the channel densities for all of the channel types defined in the density file.<p>

Another experiment is "expt_gc_cbp_flash.cc".

To make a display of the model:

<pre>
retsim --expt gc_cbp_flash -d 1 -v | vid
</pre>

To run the experiment:

<pre>
 retsim --expt gc_cbp_flash -v | vid
or:
 retsim --expt gc_cbp_flash  &gt; gc_cbp_flash.r
 plotmod gc_cbp_flash.r | vid
or:
 retsim --expt gc_cbp_flash --temp_freq 4 --ntrials 40 --dstim 0.1 --sdia 100 
           --scontrast 0.8 &gt; gc_cbp_flash_n40.d100.c0.8.r

</pre>

The experiment:

<pre>
/* Experiment gc_cbp_flash */
/*  for nc script retsim.cc */

#include <stdio.h>
#include <string.h>
#include <math.h>
#include "ncfuncs.h"
#include "retsim.h"
#include "retsim_var.h"

double temp_freq;
double ntrials;
double dstim;
double sdia;
double stimtime;
double minten;
double scontrast;
double setploti;

int rec_ct;
int rec_cn;

/*------------------------------------------------------*/

void defparams(void) 
{
  setptr("temp_freq", &temp_freq);
  setptr("ntrials",   &ntrials);
  setptr("dstim",     &dstim);
  setptr("sdia",      &sdia);
  setptr("stimtime",  &stimtime);
  setptr("minten",    &minten);
  setptr("scontrast", &scontrast);
  setptr("setploti",  &setploti);
  nvalfile = "nval_gc_cbp_flash.n";
}

/*------------------------------------------------------*/

void setparams(void)
{
  make_rods = 0;
  make_cones= 1;        /* make cones, dbp, gc */
  make_ha   = 0;
  make_hb   = 0;
  make_hbat = 0;
  make_dbp1 = 1;
  make_dbp2 = 0;
  make_rbp  = 0;
  make_gca  = 1;
  make_gcb  = 0;
  make_dsgc = 0;

  if(notinit(rec_ct)) rec_ct = gca;
  //if (notinit(arrsiz)) arrsiz = 300;
  if (notinit(bg_inten)) bg_inten = 2.0e4;      /* background light intensity */
  //if (arrsiz==100) {
  //  setsv (dbp1,SCOND,1, 25e-10);
  //} 
}

/*------------------------------------------------------*/

void runexpt(void)

{
    int ct, cn, n, plnum;
    int colr;
    int midcone, midcbp, midcbp2;
    int synin1, synin2;
    double t, fmax,fmin;
    double rmin, rmax, plsize;
    double dtrial,exptdur;
    double Vmin, Vmax;

  if (notinit(temp_freq)) temp_freq = 2;
  if (notinit(ntrials)) ntrials = 1;
  if (temp_freq == 0) {
    fprintf (stderr,"## retsim1: temp_freq = 0, STOPPING\n");
    temp_freq = 1;
  };
  dtrial = 1 / temp_freq;
  exptdur = dtrial * ntrials;
  endexp  = exptdur;
  ploti = 1e-4;

  if (notinit(dstim))         dstim = .05;      /* stimulus duration */
  if (notinit(sdia))           sdia = 300;      /* spot diameter */
  if (notinit(stimtime))   stimtime = .10;      /* stimulus time */
  if (notinit(minten))       minten = bg_inten; /* background intensity (for make cone)*/
  if (notinit(scontrast)) scontrast = .5;       /* intensity increment */
  if (!notinit(setploti))     ploti = setploti; /* plot time increment */

  midcone = findmid(xcone,0,0);
  midcbp  = findmid(dbp1,0,0);
  midcbp2 = findmid(dbp1,10,10);
  //midcbp2 = find_gtconn(dbp1, 8);
  synin1 = ncel_in(dbp1,midcbp,xcone);
  synin2 = ncel_in(dbp1,midcbp2,xcone);
  if (ninfo >=1) fprintf (stderr,"# mid cone # %d\n", midcone);
  if (ninfo >=1) fprintf (stderr,"# mid cbp  # %d ncones %d\n",  midcbp,synin1);
  if (ninfo >=1) fprintf (stderr,"# mid cbp2 # %d ncones %d\n",  midcbp2,synin2);


  plot_v_nod(ct=xcone,cn=midcone,n=soma,Vmin=-.030,Vmax =-.025,colr=cyan,"", -1, -1); /* plot Vcones*/
  plot_synrate_out(ct=xcone,cn=midcone,rmin=0,rmax=400,colr=magenta);	              /* plot rate out */
  plot_v_nod(ct=dbp1,cn=midcbp,n=soma, Vmin=-.045,Vmax =-.035,colr=red,"", -1, -1);     /* plot Vcbp */
  plot_v_nod(ct=dbp1,cn=midcbp2,n=soma,Vmin=-.045,Vmax =-.035,colr=green,"", -1, -1);  /* plot Vcbp */
  plot_synrate_out(ct=dbp1,cn=midcbp,rmin=0,rmax=200,colr=magenta);	              /* plot rate out */
  plot_v_nod(ct=gca, cn=1,n=soma,Vmin=-.070,Vmax =-.050,colr=blue,"", -1, -1);	      /* plot Vgc */
  if (make_gca && getn(gca,BIOPHYS)) {plot(CA, 1, ndn(gca,1,soma), fmax=0.5e-6, fmin=0); 
			plot_param("Cai", colr=yellow,plnum=0,plsize=0.3);}

  stim_backgr(minten);
  for (t=0; t&lt;exptdur; t+= dtrial){
     double start, dur;

    stim_spot(sdia, 0, 0, minten*scontrast, start=t+stimtime,dur=dstim);
    step(dtrial);
  }
}
</pre>

<h3><a name = "16">16. Running retsim from a batch file</a></h3>

To run several versions of a model, it is useful to use a batch file that contains exactly the
same command you can run from the command line in the shell. You can name the output file with
some combination of the parameters you've used on the command line. This allows you to know 
exactly which command corresponds to each output file:
<p>
<pre>
#
# batch file for running retsim
#
 retsim --expt gc_cbp_flash --minten -0.045 --scontrast 0.005 >& gc.0.005.r
 retsim --expt gc_cbp_flash --minten -0.045 --scontrast 0.006 >& gc.0.006.r
 retsim --expt gc_cbp_flash --minten -0.045 --scontrast 0.007 >& gc.0.007.r
</pre>

You can automate the process of running batch files so that you don't have to write
out each command line. Instead they are generated at runtime by the batch file. An
excellent way to automatically run retsim jobs is to use perl. Here is a script
called "run_gc_cbp_flash. Note that after you create this text file, you must make
it executable with "chmod +x run_gc_cbp_flash":

<pre>
#! /usr/bin/perl
#
#  run_gc_cbp_flash
#
#  run gc with different values of scontrast and ri
#
@rivals = (100,110,120,130,140,160,180,200);
$rinum = $#rivals + 1;

# $ristart = 100;
# $ristop  = 500;
# $ristep  = 50;

$cstart = 0.002;
$cstop  = 0.006;
$cstep  = 0.001;

minten = -0.045

use Getopt::Long;

&GetOptions ("ristart=f"   => \$ristart,
             "ristop=f"    => \$ristop,
             "ristep=f"    => \$ristep,
             "cstart=f"    => \$cstart,
             "cstop=f"     => \$cstop,
             "cstep=f"     => \$cstep,
             "minten=f"    => \$minten
            );

for ($r=0; $ri&lt;=$$rinum; $r++) {
     ri = $rivals[$r];
     for ($c=$cstart; $c&lt;=$cstop; $c+=$cstep) {
          system ("echo gc_cbp_flash $ri $c");
          system ("mosrun -l -b -g retsim --expt gc_cbp_flash --dbp1_densfile dens_gc_cbp_flash.n 
                 --dbp1_densfile2 dens_gc_cbp_flashx.n gc_file morph_1234 --minten $minten 
                 --scontrast $c --dri $ri --plotlabel gc_cbp_flash.$c.$ri &gt; gc_cbp_flash.$c.$ri.r &");
          sleep(2);
    }
}
</pre>

This script uses 2 methods to run models with different values: a) "$rivals" is defined as an array initialized with the values of ri to be set; and b) cstart, cstop, and cstep define a "for" loop. The density files contain the channel density values selected. The variables defined before the GetOptions call are default values that will be overridden by paramater values set in the command line. To run this script, you can set the variables defined in GetOptions in the command line (as in retsim itself):

<pre>
run_gc_cbp_flash --cstart 0 --cstop 0.008 --cstep 0.002 --minten -0.047
</pre>

Another script to run multiple retsim jobs uses the nc interpreter, "nci", with arrays of parameters to generate multiple runs.  The "nci" interpreter is equivalent to nc without any neural modeling statements. The reason for 2 sprintf statements is that the interpreted version of nc only takes up to 16 parameters per sprintf.
<p>

<pre>
#! /usr/mont/bin/nci -c
#
#

if (notinit(job)) job = 1;
if (notinit(run)) run = 17;

dim gaba_null_vals[] = {{5, 20}};
gaba_null_num = sizeof(gaba_null_vals);

dim ri_vals[] = {{0.2,2}};
ri_num = sizeof(ri_vals);

dim elnode_vals[] = {{0,5000}};
elnode_num = sizeof(elnode_vals);

// For 4 nS ampa at soma, we need 3.2 * 400pS = 1280 pS at synapses, make it 1200ps.
//   Divide 4 by 3.2, mult by 1e-9 to get cond

ampa = 0;
ampa_cond  = ampa * smult * sconv * 2.5;
eincr = 0;

nmda = 0;
nmda_cond = nmda * smult * sconv;

icontrast = ncontrast - v_incr;
iincr = v_incr;

for (e=0; e&lt;elnode_num; e++) {
  elnode = elnode_vals[e];
  for (r=0; r&lt;ri_num; r++) {
    ri = ri_vals[r];
    for (g=0; g&lt;gaba_null_num; g++) {
         gaba = gaba_null_vals[g];
         gaba_cond = gaba * smult * sconv * 1.2;

      sprintf (buf1, "mosrun -l -b -g retsim --expt dsgc_chans --n_dsgc 1 --n_sbac 0 --sbarr -1 --dsgc_file morph_ds1e 
         --dsgc_densfile dens_dsgc_chans.n --nvalfile nval_dsgc_sbac_chans.n --sbac_file morph_sbac3c --minten %g 
         --econtrast %g --eincr %g --icontrast %g --iincr %g --velocity 2000 --prestimdur 0.05 --poststimdur 0.05 
         --dvst -0.06  --dvrev -0.06 --drm 10e3 --dendrm 35e3 --dri %g --elnode %g --light_inhib 1 
         --ampa_cond %%g --nmda_cond %%g --gaba_cond %%g --movein -1 --set_vclamp 1 
         --ttxbath 1 --tea 0.995 --fourap 1 --ioffset 0 --use_ghki 1 --ninfo 2 &gt; 
           dsgc_chans%%g.a%%g.n%%g.g%%g.r%%g.e%%g.r &",job,minten,econtrast,eincr,icontrast,iincr,ri,elnode);
      sprintf (buf2,buf1,  ampa_cond,nmda_cond,gaba_cond, run,ampa,nmda,gaba,ri,elnode);
      system (buf2);
      print (buf2);
    };
 };
</pre>

The "mosrun" command is from the "mosix" job management system
(http://www.mosix.cs.huji.ac.il). This allows jobs to be run in
parallel in a cluster of computers connected on a fast local net.
Although it is easy to install on a 64-bit Linux system, "mosrun"
is not necessary to run modelfit or retsim, because you can run
jobs in parallel in the shell using "&" after each command. The
above script runs several jobs in parallel using "mosrun" and the
"&" at the end of the command line. If you don't have a cluster
of machines, you can remove the "mosrun -l -b -g" at the
beginning of the command line and the jobs will run in parallel
on your computer with the SMP kernel.

<p>

<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
 
</body>
</html>
